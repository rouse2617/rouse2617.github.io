<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/06/09/cccccc/"/>
    <url>/2022/06/09/cccccc/</url>
    
    <content type="html"><![CDATA[<p>阿帆</p><p>fs</p><p>去</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/06/09/test/"/>
    <url>/2022/06/09/test/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo 搭建记录</title>
    <link href="/2022/06/09/hexo%E6%90%AD%E5%BB%BA%20&amp;&amp;%20%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/06/09/hexo%E6%90%AD%E5%BB%BA%20&amp;&amp;%20%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>就记录下 blog ，一开始 是放在GitHub page上，但是 哪个访问太慢了，而且有时候 push不上去，于是后来 在直接在 服务器上 运行hexo，刚 开始想怎么在本地 直接发布，并并部署在 服务器，一开始的做法 ， git 同步 hexo整个代码，额。。。后来发现只需要同步 public的文件夹的内容就可以，服务器后来也没有用 hexo 部署，而是 用Nginx  做静态资源的服务器，端口直接定向到 80，后面 还加了 git hook，实现git自动 pull 部署， 目前 大致 框架算是完成好了（能写就行的原则），后续在添加功能</p><h3 id="Nginx-做域名指向"><a href="#Nginx-做域名指向" class="headerlink" title="Nginx 做域名指向"></a>Nginx 做域名指向</h3><p>​域名备案完成，想使用域名代替ip，域名解析指向ip就行，但没那么简单，最后还是修改了 Nginx 的配置文件</p><h3 id="图床的搭建"><a href="#图床的搭建" class="headerlink" title="图床的搭建"></a>图床的搭建</h3><p>​起初： 直接把图片上传，好像装个什么插件(这个忘了)，用是挺好用的，但有时候路径不对，还没找到原因</p><p>​    后面： 一直想尝试用图床，但懒得折腾；恰好现在有 备案好的域名，于是 就捣鼓了下七牛云的云储存，其实也不难~</p><h4 id="1-注册七牛云并实名-然后点-对象存储-创建空间"><a href="#1-注册七牛云并实名-然后点-对象存储-创建空间" class="headerlink" title="1. 注册七牛云并实名 然后点  对象存储  创建空间"></a>1. 注册七牛云并实名 然后点  <strong>对象存储</strong>  创建空间</h4><p>​![image-20220206134637817](img&#x2F;hexo搭建 &amp;&amp; 优化过程记录&#x2F;image-20220206134637817.png)</p><p>![image-20220206134748451](img&#x2F;hexo搭建 &amp;&amp; 优化过程记录&#x2F;image-20220206134748451.png)</p><h4 id="2-添加域名"><a href="#2-添加域名" class="headerlink" title="2.添加域名"></a>2.添加域名</h4><p>如果你自己没有备案的域名只能 用七牛云的但是只有30 天…..</p><p><img src="http://imt.rui.vin/image-20220206135215658.png" alt="image-20220206135215658"></p><p>剩下就是添加域名啦</p><p>![image-20220206135312503](img&#x2F;hexo搭建 &amp;&amp; 优化过程记录&#x2F;image-20220206135312503.png)</p><p>缓存配置 我直接选默认（我也还没搞明白这个怎么用…）</p><p>![image-20220206135405161](img&#x2F;hexo搭建 &amp;&amp; 优化过程记录&#x2F;image-20220206135405161.png)</p><p>这里需要注意的是  域名的问题：  我直接用一级域名 会404，可能是因为 一级域名 被Nginx解析了，要在Nginx配置文件中修改下，于是我用了个二级域名（这个可以去对应的域名网站解析），一切完成后 下载 </p><h4 id="3-PicGO-图床上传工具"><a href="#3-PicGO-图床上传工具" class="headerlink" title="3.PicGO 图床上传工具"></a>3.PicGO 图床上传工具</h4><p>存储区域： 华南的是z2，以此类推</p><p>key和secretkey可以在找到</p><p><img src="http://imt.rui.vin/202202061425030.png" alt="image-20220206140329112"></p><p><img src="http://imt.rui.vin/202202061425172.png" alt="image-20220206140148172"></p><p>我用 typora   这个可以直接贴图上传，在偏好设置 配一下就可以</p><p><img src="http://imt.rui.vin/202202061425433.png" alt="image-20220206140424154"></p><h3 id="hexo-功能完善记录"><a href="#hexo-功能完善记录" class="headerlink" title="hexo 功能完善记录"></a>hexo 功能完善记录</h3><h4 id="实现文章置顶功能"><a href="#实现文章置顶功能" class="headerlink" title="实现文章置顶功能"></a>实现文章置顶功能</h4><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">$ npm uninstall hexo-generator-index --save<br><br>$ npm install hexo-generator-index-pin-top --save<br></code></pre></td></tr></table></figure><p>在 format 中 加入 top :1 </p><p><img src="http://imt.rui.vin/202203101455909.png" alt="image-20220310145545576"></p><p>置顶了但是没有标志</p><p>&#x2F;blog&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_macro 目录下的<code>post.swig</code>文件，定位到<code>&lt;div class=&quot;post-meta&quot;&gt;</code>标签下，插入如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;% <span class="hljs-keyword">if</span> post.<span class="hljs-property">top</span> %&#125;<br>  &lt;i <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;fa fa-thumb-tack&quot;</span>&gt;&lt;/i&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">7D26CD</span>&gt;</span>置顶<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure><p>效果展示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">        &lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;post-meta&quot;</span>&gt;<br>          <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post-time&quot;</span>&gt;</span></span><br><span class="language-xml">在此之下插入代码，包含在 span块内        </span><br><span class="language-xml">          &#123;% if post.top %&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-thumb-tack&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">7D26CD</span>&gt;</span>置顶<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">          &#123;% endif %&#125;</span><br></code></pre></td></tr></table></figure><h4 id="实现首页背景每天更新图片"><a href="#实现首页背景每天更新图片" class="headerlink" title="实现首页背景每天更新图片"></a>实现首页背景每天更新图片</h4><p>今天打开必应搜索，突然突然想到我的blog背景图能不能和必应一样每天更新，于是搜了下必应背景图的api，果然有，于是直接在 配置文件上更换了这个，但是第一次加载没那么快了</p><h4 id="开启评论功能"><a href="#开启评论功能" class="headerlink" title="开启评论功能"></a>开启评论功能</h4><p>这个主题都集成了好多功能！！ 评论模块也有，这次选用 leancloud 提供的平台，只需要注册 拿到 api key就行，一步搞定…. 我在想自己有服务器，是不是也可以在后台搭建个评论系统 ; 这里留一个坑吧…. leancloud好像提供提供许多服务的</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编指令 记录</title>
    <link href="/2022/06/09/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%20%E5%B0%8F%E7%BB%93/"/>
    <url>/2022/06/09/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%20%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="符号定义伪指令"><a href="#符号定义伪指令" class="headerlink" title="符号定义伪指令"></a>符号定义伪指令</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">.global`,`.local`,`.set`,`.equ<br></code></pre></td></tr></table></figure><h4 id="global"><a href="#global" class="headerlink" title=".global"></a>.global</h4><p>使得符号对连接器可见，变为对整个工程可用的全局变量</p> <span id="more"></span><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">.<span class="hljs-keyword">global</span> symbol<br></code></pre></td></tr></table></figure><h4 id="local"><a href="#local" class="headerlink" title=".local"></a>.local</h4><p>表示符号对外部不可见，只对本文件可见</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">.<span class="hljs-keyword">local</span> symbol<br></code></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title=".set"></a>.set</h4><p>给一个全局变量或局部变量赋值，和<code>.equ</code>的功能一样</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-meta">.set</span> symbol expr<br><span class="hljs-meta">.set</span> start, <span class="hljs-number">0x40</span><br><span class="hljs-meta">.set</span> start, <span class="hljs-number">0x50</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-meta">#start      ;r1里面是0x50</span><br></code></pre></td></tr></table></figure><h4 id="equ"><a href="#equ" class="headerlink" title=".equ"></a>.equ</h4><p>和<code>.set</code>一样，只是格式不同</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">symbol <span class="hljs-meta">.equ</span>  expr<br>start  <span class="hljs-meta">.equ</span>, <span class="hljs-number">0x40</span><br>start  <span class="hljs-meta">.equ</span>, <span class="hljs-number">0x50</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">r1</span>, <span class="hljs-meta">#start      ;r1里面是0x50</span><br></code></pre></td></tr></table></figure><h3 id="数据定义伪指令"><a href="#数据定义伪指令" class="headerlink" title="数据定义伪指令"></a>数据定义伪指令</h3><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">.byte`,`.short`,`.long`,`.quad`,`.float`,`.string`,`.asciz`,`.ascii`,`.rept<br></code></pre></td></tr></table></figure><h4 id="byte"><a href="#byte" class="headerlink" title=".byte"></a>.byte</h4><p>在存储器中分配<strong>1个字节</strong>，用指定的数据对存储单元进行初始化</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">label:</span>  <span class="hljs-meta">.byte</span>   expr    <span class="hljs-comment">;label是程序标号，expr可以是-128~255的数字，也可是字符</span><br><span class="hljs-symbol">a:</span>  <span class="hljs-meta">.byte</span>   <span class="hljs-meta">#1  ;等价于C中的char a=1;</span><br></code></pre></td></tr></table></figure><h4 id="short"><a href="#short" class="headerlink" title=".short"></a>.short</h4><p>在存储器中分配<strong>2个字节</strong>，用指定的数据对存储单元进行初始化</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">a</span>: .<span class="hljs-keyword">short</span> <span class="hljs-number">0x1234</span><br></code></pre></td></tr></table></figure><h4 id="word-x2F-long"><a href="#word-x2F-long" class="headerlink" title=".word &#x2F; .long"></a>.word &#x2F; .long</h4><p>在存储器中分配<strong>4个字节</strong>，用指定的数据对存储单元进行初始化</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">a</span>: .<span class="hljs-built_in">word</span> <span class="hljs-number">0x12345678</span><br></code></pre></td></tr></table></figure><h4 id="long"><a href="#long" class="headerlink" title=".long"></a>.long</h4><p>在存储器中分配<strong>个字节</strong>，用指定的数据对存储单元进行初始化</p><h4 id="quad"><a href="#quad" class="headerlink" title=".quad"></a>.quad</h4><p>在存储器中分配<strong>8个字节</strong>，用指定的数据对存储单元进行初始化</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">a</span>: .quad <span class="hljs-number">0x12345678</span> ;等价于C中的<span class="hljs-keyword">long</span> <span class="hljs-keyword">a</span>=<span class="hljs-number">0x1234567812345678</span><br></code></pre></td></tr></table></figure><h4 id="float"><a href="#float" class="headerlink" title=".float"></a>.float</h4><p>在存储器中分配<strong>4个字节</strong>，用指定的<strong>浮点</strong>数据对存储单元进行初始化</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">a</span>: .float <span class="hljs-number">1</span>.<span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><h4 id="space-x2F-skip"><a href="#space-x2F-skip" class="headerlink" title=".space&#x2F;.skip"></a>.space&#x2F;.skip</h4><p>用于分配一块连续的存储区域并初始化为指定的值，如果后面的填充值省略不写则在后面填充为0;</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">label</span>: .space size,expr     ;expr可以是<span class="hljs-number">4</span>字节以内的浮点数 <br><span class="hljs-attribute">a</span>:  space <span class="hljs-number">8</span>, <span class="hljs-number">0</span>x1<br></code></pre></td></tr></table></figure><h4 id="string"><a href="#string" class="headerlink" title=".string"></a>.string</h4><p>定义一个字符串，默认是string8，还有string16，string32，string64</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">a</span>: .<span class="hljs-literal">space</span> <span class="hljs-string">&quot;hello world!&quot;</span><br></code></pre></td></tr></table></figure><h4 id="rept"><a href="#rept" class="headerlink" title=".rept"></a>.rept</h4><p>重复执行接下来的指令，以.rept开始，以.endr结束</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-title">.rept cnt   ;cnt是重复次数</span><br><span class="hljs-bullet">...</span><br><span class="hljs-bullet"></span><span class="hljs-title">.endr</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/09/hello-world/"/>
    <url>/2022/06/09/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何对大文件进行排序</title>
    <link href="/2022/04/20/%E5%A6%82%E4%BD%95%E5%AF%B920G%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/04/20/%E5%A6%82%E4%BD%95%E5%AF%B920G%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>排序问题虽然有了解，很多只是基于理论上，实践比较少，刚好最近遇到个问题：</p><p><img src="http://imt.rui.vin/202204201529678.png" alt="侵删"></p><p><img src="http://imt.rui.vin/202204201538979.png" alt="image-20220420153810671"></p><p>这个以前遇到过类似的问题， 假如 你有一个20GB的文件，对文件的内容排序，内存限制在 1G，你要怎么排序</p><p>以前有做过总结，就是分割文件，逐个文件先排好序，最后然后再合并，说起来很简单，但做起来就。。。。 </p><p>这次题目有 分割文件，我下载了这个压缩包，解压 看有1000个 20M的文件 </p><p><img src="http://imt.rui.vin/202204201531613.png" alt="image-20220420153113356"></p><p>思路：   将这个一 千个文件，文件名读取出来，按照条件逐个抽出来，并且排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read_lryic</span><span class="hljs-params">(<span class="hljs-type">char</span> *path)</span></span><br><span class="hljs-function"></span>&#123;<br>    DIR *dir = <span class="hljs-built_in">opendir</span>(path); <span class="hljs-comment">//打开目录文件</span><br>    cout &lt;&lt; path &lt;&lt; endl;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> *entry;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((entry = <span class="hljs-built_in">readdir</span>(dir)) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(entry-&gt;d_name, <span class="hljs-string">&quot;.txt&quot;</span>))<br>        &#123;<br>            filename.<span class="hljs-built_in">push_back</span>(entry-&gt;d_name);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d %s\n&quot;</span>, i++, entry-&gt;d_name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在文件名有了，进行筛选排序，这里用map来存放临时的数据，key 为时间戳，value 为对应的数据，为什么用map，map是会自动自动排序，根据key的值，而这里的没条数据都是 json，用了一个jsoncpp 库（如果用 go 估计已经写完了），原本想直接解析字符串，发现有点麻烦，还是用库吧， 提取出  时间戳，作为key，提取完一个文件后，重新写入到新的文件里</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortfile</span><span class="hljs-params">()</span></span>&#123;<br>    Json::Reader reader;<br>    Json::Value obj;<br>    <span class="hljs-comment">//读文件名字 </span><br>    <span class="hljs-built_in">read_lryic</span>(<span class="hljs-string">&quot;/home/hrp/Cpp/recore/&quot;</span>);<br>    string file;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> str : filename)&#123;<br>        file = <span class="hljs-string">&quot;/home/hrp/Cpp/recore/&quot;</span> + str;<br>        <span class="hljs-function">std::ifstream <span class="hljs-title">fIn</span><span class="hljs-params">(file)</span></span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (fIn)<br>        &#123;<br>            std::string str;<br>            <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(fIn, str))<br>            &#123;<br>                <span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;张三&quot;</span>) != string::npos)&#123;<br>                    <br>                    <span class="hljs-comment">//std::cout &lt;&lt; i++ &lt;&lt; endl;</span><br>                    reader.<span class="hljs-built_in">parse</span>(str, obj);<br>                    <span class="hljs-type">long</span> timestamp = obj[<span class="hljs-string">&quot;timestamp&quot;</span>].<span class="hljs-built_in">asInt64</span>();   <br>                    ret[timestamp] = str;             <br>                &#125;<br>            &#125; <br>            cout &lt;&lt; file &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Open file faild.&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-function">ofstream <span class="hljs-title">out1</span><span class="hljs-params">(file)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i=ret.<span class="hljs-built_in">begin</span>();i!=ret.<span class="hljs-built_in">end</span>();i++)&#123;<br>            <span class="hljs-comment">//cout &lt;&lt; i-&gt;second;</span><br>            out1 &lt;&lt; i-&gt;second ;<br>            out1 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> ;<br>        &#125;<br>        ret.<span class="hljs-built_in">clear</span>();<br>        out1.<span class="hljs-built_in">close</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在完成 按照条件 完成每个文件的排序了</p><p>接下来就是 归并，如何归并呢，现在有1000个文件，逐个遍历这1000个文件，每次都提取一行来，一次遍历 提取了1000行数据，此时可以用大顶堆的特性，就是1000个数据放进这个大顶堆，堆顶肯定是最大数，按照这个特性，先读取一千条，放在大顶堆了，每次 pop出堆顶的（肯定最大），然后要 补上一个，读哪个文件的呢，肯定是pop出去哪条数据所在的文件，所以现在就是要去那个文件里再读一条数据，以此类推，说是这样说 ，但是这题还有其他附加条件（根据时间分类写）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">clock_t</span> start,end;<span class="hljs-comment">//定义clock_t变量</span><br>   start = <span class="hljs-built_in">clock</span>();  <span class="hljs-comment">//开始时间</span><br><br>   Json::Reader reader;<br>   Json::Value obj;<br><br>   map&lt;string,ifstream*&gt; filesmap;<br>   map&lt;string,ofstream*&gt; outfile;<br><br>   <span class="hljs-built_in">sortfile</span>();<br>   <span class="hljs-type">time_t</span> tt;<br>   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tm</span> *ttime;<br><span class="hljs-comment">//用 map 保存文件的读写流，这里是读</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> file: filename)&#123;<br>       <span class="hljs-keyword">auto</span> temp = file;<br>       file = <span class="hljs-string">&quot;/home/hrp/Cpp/recore/&quot;</span> + temp;<br>       filesmap.<span class="hljs-built_in">emplace</span>(file, <span class="hljs-keyword">new</span> ifstream(file)); <br>   &#125;<br><span class="hljs-comment">//这里用c++ 的优先队列 来模拟堆，插入的数据  为 时间戳和文件的字符名字</span><br>  priority_queue&lt;pair&lt;<span class="hljs-type">long</span>, string&gt;&gt; topTime;<br>   map&lt;<span class="hljs-type">long</span>,string&gt; Temp;<br>   string data;<br><span class="hljs-comment">//先读取 全部文件的 第一条数据，push到 优先队列中 </span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter = filesmap.<span class="hljs-built_in">begin</span>(); iter != filesmap.<span class="hljs-built_in">end</span>(); iter++) &#123;<br>       std::<span class="hljs-built_in">getline</span>(*iter-&gt;second, data);<br><br>       reader.<span class="hljs-built_in">parse</span>(data, obj);<br>       <span class="hljs-type">long</span> timestamp = obj[<span class="hljs-string">&quot;timestamp&quot;</span>].<span class="hljs-built_in">asInt64</span>();<br>       <span class="hljs-function">pair&lt;<span class="hljs-type">long</span>,string&gt; <span class="hljs-title">b</span><span class="hljs-params">(timestamp,iter-&gt;first)</span></span>;<br><br>       topTime.<span class="hljs-built_in">push</span>(b);<br>       Temp[timestamp] = data;<br>   &#125;<br><span class="hljs-comment">// 现在 对队列操作，此时队列是 出一个，进一个，维持平衡，没有进，就一直出，知道 队列为空位止</span><br><span class="hljs-comment">// Temp 维护 这1000个数据，动态增减</span><br>   <span class="hljs-keyword">while</span> (!topTime.<span class="hljs-built_in">empty</span>())&#123;<br>       <span class="hljs-comment">// cout  &lt;&lt; Temp[topTime.top()] &lt;&lt; endl;</span><br>       <span class="hljs-comment">//时间戳转 日期</span><br>       <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tm</span> *ttime;<br>       tt = topTime.<span class="hljs-built_in">top</span>().first/<span class="hljs-number">1000</span>;<br>       ttime = <span class="hljs-built_in">localtime</span>(&amp;tt);<br>       <span class="hljs-type">char</span> formatime[<span class="hljs-number">64</span>];<br>       <span class="hljs-built_in">strftime</span>(formatime, <span class="hljs-number">64</span>, <span class="hljs-string">&quot;%Y-%m-%d&quot;</span>, ttime);<br>       <span class="hljs-function">string <span class="hljs-title">strtime</span><span class="hljs-params">(formatime)</span></span>;<br><span class="hljs-comment">//这里是写文件，根据时间戳 转换的日期来 写文件</span><br>       <span class="hljs-comment">// outfile   key 为文件名 value 对应的读写流</span><br>       <span class="hljs-comment">// 为 0 ，说明第一次，创建文件</span><br>       <span class="hljs-keyword">if</span>(outfile.<span class="hljs-built_in">count</span>(strtime)  == <span class="hljs-number">0</span>)&#123;<br>           <br>           outfile.<span class="hljs-built_in">emplace</span>(strtime,<span class="hljs-keyword">new</span> <span class="hljs-built_in">ofstream</span>(strtime));<br>           <span class="hljs-keyword">if</span> (!outfile[strtime]-&gt;<span class="hljs-built_in">is_open</span>()) <br>               cout &lt;&lt; strtime &lt;&lt; <span class="hljs-string">&quot;error&quot;</span> &lt;&lt; endl;<br>           *outfile[strtime] &lt;&lt; Temp[topTime.<span class="hljs-built_in">top</span>().first]+ <span class="hljs-string">&quot;\n&quot;</span>;<br>           Temp.<span class="hljs-built_in">erase</span>(topTime.<span class="hljs-built_in">top</span>().first);<br><br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-comment">//根据 日期写入 数据</span><br>           *outfile[strtime] &lt;&lt; Temp[topTime.<span class="hljs-built_in">top</span>().first] + <span class="hljs-string">&quot;\n&quot;</span>;<br>           Temp.<span class="hljs-built_in">erase</span>(topTime.<span class="hljs-built_in">top</span>().first);<br><br>       &#125;<br><span class="hljs-comment">// top是最大的，此时pop出去，记录下 pop去的是哪个文件 </span><br>       <span class="hljs-keyword">auto</span> TopTemp = topTime.<span class="hljs-built_in">top</span>();<br>       topTime.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-comment">//如果 读取到了，更行 优先队列的数据</span><br>       <span class="hljs-keyword">if</span>(std::<span class="hljs-built_in">getline</span>(*filesmap[TopTemp.second], data))&#123;<br>           reader.<span class="hljs-built_in">parse</span>(data, obj);<br>           <span class="hljs-type">long</span> timestamp = obj[<span class="hljs-string">&quot;timestamp&quot;</span>].<span class="hljs-built_in">asInt64</span>();<br>           <span class="hljs-function">pair&lt;<span class="hljs-type">long</span>,string&gt; <span class="hljs-title">b</span><span class="hljs-params">(timestamp,TopTemp.second)</span></span>;<br>           Temp[timestamp] = data;<br>           topTime.<span class="hljs-built_in">push</span>(b);<br>       &#125;<br>     <br><br>   &#125;<br><span class="hljs-comment">//最后 要关闭文件，才会保存</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter = outfile.<span class="hljs-built_in">begin</span>(); iter != outfile.<span class="hljs-built_in">end</span>(); iter++) &#123;<br>       iter-&gt;second-&gt;<span class="hljs-built_in">close</span>();<br>   &#125;<br>   end = <span class="hljs-built_in">clock</span>();   <span class="hljs-comment">//结束时间</span><br>   cout&lt;&lt;<span class="hljs-string">&quot;time = &quot;</span>&lt;&lt;<span class="hljs-built_in">double</span>(end-start)/CLOCKS_PER_SEC&lt;&lt;<span class="hljs-string">&quot;s&quot;</span>&lt;&lt;endl;  <span class="hljs-comment">//输出时间（单位：ｓ）</span><br><br><br></code></pre></td></tr></table></figure><p>运行的机器是：  腾讯云服务器   4核 4g</p><p><img src="http://imt.rui.vin/202204201626331.png" alt="耗时 117 .s"></p><img src="http://imt.rui.vin/202204201607730.png" alt="内存使用不大，500M 以内解决，就是 cpu 占用率高" style="zoom: 80%;" />  <p><img src="http://imt.rui.vin/202204201609407.png" alt="排序好的"></p><p> <strong>总结：</strong></p><ul><li>认清了 知道 和 做到的差距！！！！！</li><li>有些api 日常少使用， 很不收悉，都是在查查查 </li><li>要先有整体思路  然后细化问题，逐个解决</li></ul><p>代码整体设计 不是很好，后续在改进， 用多线程 多路归并？</p>]]></content>
    
    
    
    <tags>
      
      <tag>有趣的问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cmake的初步使用</title>
    <link href="/2022/04/19/Cmake%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/04/19/Cmake%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>以前 接触Ros是有用过cmake，以及 clickhouse 编译源码时也有用过cmake，但是只是执行命令，没怎样看，最近了解了下</p><p>cmake 相对于 Makefile 更加便捷，cmake会根据 CMakeLists.txt的内容  会自动生成 Makefile，想着最近捣鼓的项目代码量也上来了，所以试试 cmake，这里记录做下记录</p><p>最近想着一个 项目源文件和头文件如何布局，以及一些模块的代码要在那个文件夹，这里现在考虑的不是很完善，现在方案是  .h 和 .cpp 分离开，并且一个功能模块占用一个文件夹</p><p><img src="http://imt.rui.vin/202204190055109.png" alt="image-20220419005501875">build 里面就是 cmake 生成的文件，在项目根目录编写 个 CmakeLists.txt ,cmake 会根据这个生成对应的makefile文件</p><p>aux_source_directory(路径 变量名字)   是指定路径的源文件 保存到指定的变量（这里都是用空格隔开的）<br>期初一直提示没有找   <strong>undefined reference</strong>  原因就是 没有导入相对应的文件</p><ul><li><p>$是取值的符号</p></li><li><p>set是赋值</p></li><li><p>message相对于 print</p></li><li><p>include_directories(路径)   是找到相对应的头文件</p></li><li><p>ADD_EXECUTABLE(生成文件  源文件….)  </p></li><li><p>target_link_libraries()  链接对应库  相当于  gcc 中的 -L</p></li><li><pre><code class="hljs">file(GLOB_RECURSE SRC_DIR_LIST &quot;src/*.cpp&quot; &quot;src/*.c&quot;)    这个可以一次性遍历出全部的源文件</code></pre></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#cmake最低版本需求，不加入此行会受到警告信息</span><br>CMAKE_MINIMUM_REQUIRED(VERSION 2.6)<br>PROJECT(Server) <span class="hljs-comment">#项目名称</span><br><br>aux_source_directory(./src/common SRC_common)<br>aux_source_directory(./src/threadpool SRC_threadpool)<br><span class="hljs-comment">#file(GLOB_RECURSE SRC_DIR_LIST &quot;src/*.cpp&quot; &quot;src/*.c&quot;)#遍历获取source/路径下所有的*.cpp和*.c文件列表</span><br><br><span class="hljs-comment">#打印SRC_DIR_LIST中列表信息</span><br><br>set(SRC_ROOT_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)<br>message(<span class="hljs-string">&quot;SRC_ROOT_PATH $&#123;SRC_ROOT_PATH&#125;&quot;</span>)<br><br>include_directories($&#123;SRC_ROOT_PATH&#125;/<span class="hljs-keyword">include</span>)<br><span class="hljs-comment"># 指定可执行文件的输出目录  </span><br>set( $&#123;PROJECT_SOURCE_DIR&#125;/bin)<br><br>ADD_EXECUTABLE(main main.cpp $&#123;SRC_common&#125; $&#123;SRC_threadpool&#125; )<br>target_link_libraries(main pthread)<br><br></code></pre></td></tr></table></figure><hr><p>现在看来 cmake 是比较方便，不用写编译的命令，威力很强大，以后遇到什么需求了再来完善，用着学，学着用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>cmake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gogs 搭建和githook自动化部署</title>
    <link href="/2022/04/16/Gog%E6%90%AD%E5%BB%BA%E5%92%8Chook%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/04/16/Gog%E6%90%AD%E5%BB%BA%E5%92%8Chook%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>​昨天 体验到了 rm 的威力（ 手残 把自己服务器的 &#x2F;home都给删除了,好多代码都寄了…..  ）… 导致 早期的搭建的git服务器 挂了，无法更新博客，想到备份而了镜像进行回滚，但是 回滚的是好久之前的，什么都没搭好，于是今天用了一下午的时间 搭建… </p><p>​   搭建 git的时候按照老办法，突然发现了一个 叫 Gogs的git管理工具，从介绍上看  <strong>Gogs</strong> 是一款极易搭建的自助 Git 服务，没试过，我也就试试，搭建一气呵成，我选择用 二进制安装的，方便快捷，搭建好后，开放了一个端口，然后需要用户登录，这就有点类似于 github 了</p><p><img src="http://imt.rui.vin/202204161748964.png" alt="image-20220416173330870" style="zoom:50%;" /> 按照 网上教程很快就完成了</p><p>服务器搭建好了后，还是和以前一样方案    本地push到主分支 ， 触发githook ，执行指定代码，在服务器上 pull最新的源码， 最后用 Nginx做解析</p><p>遇到个问题就是   触发githook 后无法 执行pull ，一直说目录 没有  .git ,这个搞了很久，我忘记 上次是怎么弄了 （没总结的后果！！）</p><p>后来在 Stack Overflow 找到了答案 ，完美解决！！！</p><img src="http://imt.rui.vin/202204161748271.png" alt="image-20220416174052831" style="zoom:67%;" /><p>为什么会这样呢？</p><blockquote><p>  原来 git 首选使用路径是 GIT_DIR, 其次 才是PWD ，用  unset GIT_DIR 把这个环境变量，git 则会用 PWD！</p></blockquote><p>想着以后可不可以将这个打包成一个镜像，以后直接用 docker 运行这镜像？</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>error while loading shared libraries错误解决办法</title>
    <link href="/2022/04/10/error%20while%20loading%20shared%20libraries%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2022/04/10/error%20while%20loading%20shared%20libraries%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>最近想实现 Reactor 多线程模式，因为线程池可以使用了，接下来尝试 将epoll 封装下一些api， 后来想到 有个框架 Libevent 也是基于事件通知机制的库，将epoll封装成api，方便调用，以前有看过一点，但是没有用过，所以现在站在巨人的肩膀上看看他们是怎样写的：</p><p>看源码之前需要将这个代码跑通，起码会用才行，从编译源代码，到运行demo都遇到了些问题，这里做个总结吧</p><p>clone 源码然后 make 这些就不说了，make 时出现个问题 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">bufferevent_openssl.c:<span class="hljs-number">228</span>:<span class="hljs-number">19</span>: error: storage size of <span class="hljs-string">&#x27;methods_bufferevent&#x27;</span> isn<span class="hljs-number">&#x27;</span>t known<br> <span class="hljs-type">static</span> BIO_METHOD methods_bufferevent = &#123;<br>                   ^~~~~~~~~~~~~~~~~~~<br>Makefile:<span class="hljs-number">793</span>: recipe <span class="hljs-keyword">for</span> target <span class="hljs-string">&#x27;bufferevent_openssl.lo&#x27;</span> failed<br></code></pre></td></tr></table></figure><p>后来查了下 是 openssl 版本不不兼容， 期初我在官网下的 Libevent是2.0.2 </p><blockquote><p>  openssl 是什么： openssl则是SSL的实现版（SSL https加密哪个 ），另外openssl还包含了公钥私钥的生成、摘要生成等各种工具</p></blockquote><p><img src="http://imt.rui.vin/202204100020544.png" alt="image-20220410001448008"></p><p>libevent 2.0.x版本的  openssl &lt; 1.1.0 ，不兼容，现在 Linux openssl  普遍  版本都是1.1.0+  </p><p><img src="http://imt.rui.vin/202204100017635.png" alt="image-20220410001724343"></p><p>解决方法： 用  libevent 2.1.x+ 以上的版本</p><hr><p>使用 libevent 库 编译过了，执行程序时报错 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">error <span class="hljs-keyword">while</span> loading shared libraries: libevent<span class="hljs-number">-2.1</span>.so<span class="hljs-number">.6</span>: <br>cannot open shared object file: No such file or directory<br></code></pre></td></tr></table></figure><p>问题 找不到共享库？</p><p>原因：  <a href="https://so.csdn.net/so/search?q=%E7%BC%96%E8%AF%91%E5%99%A8&spm=1001.2101.3001.7020">编译器</a>只会使用   <strong>&#x2F;lib</strong>  和   <strong>&#x2F;usr&#x2F;lib</strong>   这两个目录下的库文件， 编译源码的时候没有指定 库安装的目录，运行程序需要链接动态库时就找不到，所以现在需要添加 这个库的目录</p><p>解决方法：  </p><ul><li>先看下系统 是否有这个库  ，找到 库的位置</li></ul><p>​      <img src="http://imt.rui.vin/202204100026453.png" alt="image-20220410002648057"></p><ul><li><p>动态库文件所在的目录 在    **&#x2F;etc&#x2F;ld.so.conf **   ，将 libevent-2.1.so.6所在的目录添加到该文件下</p><p>​    <img src="http://imt.rui.vin/202204100031469.png" alt="image-20220410003108601">     </p></li><li><p>执行 &#x2F;sbin&#x2F;ldconfig  -v   才会生效</p></li></ul><p>如果还不行，而且确实有 有库存在，可以看下 是否是 权限问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指针数组和数组指针</title>
    <link href="/2022/04/01/%E5%87%BD%E6%95%B0%20%E6%8C%87%E9%92%88%20%E6%95%B0%E7%BB%84%20%E6%90%AD%E9%85%8D/"/>
    <url>/2022/04/01/%E5%87%BD%E6%95%B0%20%E6%8C%87%E9%92%88%20%E6%95%B0%E7%BB%84%20%E6%90%AD%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<!--==-->指针 ，数组， 函数  这个概念并不会陌生，但是组合起来 就有很多含义，总是搞混，如    数组指针 ，数组指针 ，函数指针等等...  死记硬背是不可能的，在这里总结下规律==<h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>这个比较容易理解 ，我们日常使用的数组有  整型的数组，如 <strong>int a[100];</strong> 有100个空间，里面都是存放整型变量的 ， 也有浮点型的数组  <strong>float b[100];</strong>   从前两个可以总结出这一类数组叫法都是   类型名 + 数组 ，  我们也知道 <strong>指针也是类型！</strong> 只不过是比较特殊的类型（存地址）！ 所以说 指针数组是存在指针的数组，那如何标识呢？</p><p>int *p[100]    —-&gt;    int * (p[100])         </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> d = <span class="hljs-number">4</span>;<br>    <span class="hljs-type">int</span> e = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> *p[<span class="hljs-number">5</span>] = &#123;&amp;a, &amp;b, &amp;c, &amp;d, &amp;e&#125;;<br>    <span class="hljs-type">int</span> i; <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *p[i]);<br>    &#125;<br>    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><p>还是按照 上面 指针数组的推理：    指针也是有很多种类型的，如 int * p，说明这个 指针p指向 指向整型的内存，那数组指针呢？ 我们可以重新理解为 这个指针是指向<strong>数组类型</strong>的，  数组指针的写法和指针数组很像，就是多了个括号   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span> (*pa)[<span class="hljs-number">3</span>] = &amp;a;<br></code></pre></td></tr></table></figure><p>pa 是指向 数组a[3] 的指针 ，   int (*pa)[3]  是挺难理解的 ， 我的理解是  *<em>（）和[ ] 是相同的优先级，现在是从左到右开始结合  int 代表着 <em>p指向的内容是整型的，[3] 是说明有3个这样的空间</em></em></p><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数即我们写的代码，代码也有有专门存放的空间，从内存布局上看，是存放在代码区，<strong>所以也是有地址的！</strong> 通过 函数名可以找到 代码块的地址</p><p>同数组指针一样的理解， 这个这个指针的类型是函数的（有点拗口，但还是抽象的形容吧） ，函数回调就可以用函数指针来实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;;   <span class="hljs-comment">/*声明一个函数*/</span><br><span class="hljs-type">int</span> (*p) (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);;  <span class="hljs-comment">/*定义一个函数指针*/</span><br>p = Func;          <span class="hljs-comment">/*将Func函数的首地址赋给指针变量p  不用 &amp; 符号*/</span> <br></code></pre></td></tr></table></figure><p>p是一个指针，返回的值是 整型的，后面 (int, int)  是函数的参数<br>这个规律是 返回值要相同，形参也要一致</p><h3 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h3><p>同上，这个数组的类型是 函数指针类型的，数组中的每一项都保存这个一个函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*p[<span class="hljs-number">10</span>])();<br></code></pre></td></tr></table></figure><p>p和 [10]相结合  有了个数组，然后和 * 结合 是个指针数组，和 int 结合 ，返回的值是 int 类型的， 然后和 （） 就是形参列表</p><h3 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h3><p>这个不用说都明白的了，函数 返回值是 指针类型的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *<span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>;<br></code></pre></td></tr></table></figure><hr><p>待更新</p>]]></content>
    
    
    
    <tags>
      
      <tag>基础语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写线程池-第一版</title>
    <link href="/2022/03/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2022/03/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="线程池是什么"><a href="#线程池是什么" class="headerlink" title="线程池是什么"></a>线程池是什么</h3><p>举个例子，在以前文章又提到过 好几种reactor模式</p><img src="http://imt.rui.vin/202203291923967.png" alt="单Reactor多线程模式" style="zoom:50%;" /> <p>可以大概分为这几种</p><p>  单 Reactor 单进程 &#x2F; 线程：    **接收数据  –&gt;  解析数据  –&gt; 发送数据 **           </p><p>  单 Reactor 多线程 ：             接收数据  –&gt; fd 交给线程        –&gt;  线程全程处理</p><p>​ 接收数据  –&gt; 从fd中抽出数据 –&gt; 数据交给线程</p><p>如果接收一次数据，创建一次线程处理完后又销毁线程，这样太消耗cpu资源了,为了改善这个性能，可以先创建好一定数量的线程，线程处理饥渴的模式，有业务需要处理了，就派一个线程去处理，处理完后，又处于饥渴的转态，其实典型的空间换时间的问题，有很设计都是这样，如内存池（减少系统调用的次数），连接池等。</p><p>如何设计呢一个池呢？ 好像Java有现成的类可以调，这次用C++ 写一个线程池，第一次写，有很多东西没考虑到，以后继续迭代吧</p><p>看了一个视频，用c写线程池，大致理解了思路，于是自己 用 c++写一遍（ c with class …) </p><p>思路： </p><ul><li>一个线程池类， 可以初始初始化线程 ，任务队列，锁</li><li>工作类， 一个线程对应个工作类，工作类从任务队列中抽取任务</li><li>任务类 ，产生一个任务 插入任务队列中</li><li>线程锁类， 用的还是 POSIX标准下的互斥锁，不过封装一遍（我看别人写的代码好多都是基本api在封装一遍的，所以我也尝试下）， 还有一个条件变量，没任务全部线程等待，有任务 发送信号，通知一个等待的线程获取任务</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">pool</span>&#123;<br><span class="hljs-keyword">private</span>:<br>list&lt;Job*&gt; Jobs;  <span class="hljs-comment">//用双向链表 存放任务  应该用队列比较好的</span><br>mylocker *mutelock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">mylocker</span>(); <span class="hljs-comment">// 初始化一个锁</span><br><span class="hljs-keyword">public</span>:<br>         <span class="hljs-comment">//初始化线程</span><br><span class="hljs-built_in">pool</span>(<span class="hljs-type">int</span> maxNumber)&#123;   <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; maxNumber; i++)&#123;<br>                Worker *work = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Worker</span>(); <span class="hljs-comment">//工作类  </span><br>                work-&gt;lock = mutelock;       <span class="hljs-comment">//全部线程公用一个锁</span><br>                work-&gt;Jobs = &amp;Jobs;          <span class="hljs-comment">//任务队列包含    我想着尽量不要用到 全局的变量，全部归到一个类里面</span><br>                <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_create</span>(&amp;work-&gt;tid, <span class="hljs-literal">NULL</span>, fun, (<span class="hljs-type">void</span> *)work);  <span class="hljs-comment">// 开启线程  还有传参，工作类传进去</span><br>                <span class="hljs-built_in">pthread_detach</span>(work-&gt;tid);  <span class="hljs-comment">//线程分离，脱离主程序</span><br><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addjob</span><span class="hljs-params">(Job *job)</span></span>&#123; <span class="hljs-comment">//添加一个任务</span><br>            mutelock-&gt;<span class="hljs-built_in">mutelock</span>(); <span class="hljs-comment">//此时还是需要锁 保持同步  </span><br>            <span class="hljs-keyword">if</span>(job-&gt;state == run)&#123; <span class="hljs-comment">//添加了任务的转态，不是需要运行的就加进去  </span><br>                  <span class="hljs-comment">//这里做的不是很好，是不是应该分为待处理，马上处理的任务队列呢，以后在补充</span><br>                cout &lt;&lt; <span class="hljs-string">&quot;添加队列中&quot;</span> &lt;&lt; endl;<br>                Jobs.<span class="hljs-built_in">push_back</span>(job);<br>                mutelock-&gt;<span class="hljs-built_in">condsignal</span>();  <span class="hljs-comment">//通知线程</span><br>            &#125;<br>            mutelock-&gt;<span class="hljs-built_in">muteunlock</span>(); <br>&#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jobSize</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> Jobs.<span class="hljs-built_in">size</span>();<br>        &#125;<br>~<span class="hljs-built_in">pool</span>()&#123;<br>            <span class="hljs-built_in">delete</span>(mutelock);<br>&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//任务类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Job</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> state = run;<br>        <span class="hljs-type">int</span> data;<br>        <span class="hljs-built_in">void</span> (*job_function)(<span class="hljs-type">int</span> fd);  <span class="hljs-comment">// 这里 添加个回调函数，可以自定义 要怎样的任务类</span><br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Job</span>()&#123;<br><span class="hljs-comment">//这里初始化</span><br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">runFun</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-built_in">job_function</span>(data);<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;    <br>    <span class="hljs-comment">//cout &lt;&lt; &quot;创建成功 &quot; &lt;&lt; pthread_self() &lt;&lt; endl;  </span><br>    Worker *work = (Worker *)arg;  <span class="hljs-comment">//参数类型转换   这个arg参数太好用了！</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<br>        work-&gt;lock-&gt;<span class="hljs-built_in">mutelock</span>();    <span class="hljs-comment">//条件变量需要 互斥锁</span><br>        <span class="hljs-comment">// cout &lt;&lt; &quot;原地待命，等通知&quot; &lt;&lt; endl;</span><br>        <span class="hljs-comment">// 队列空的话 等待等通知</span><br>        <span class="hljs-keyword">while</span> (work-&gt;Jobs-&gt;<span class="hljs-built_in">empty</span>())&#123;  <br>            cout &lt;&lt; <span class="hljs-string">&quot;等待任务队列 &quot;</span> &lt;&lt; work-&gt;Jobs-&gt;<span class="hljs-built_in">empty</span>() &lt;&lt; endl; <br>            work-&gt;lock-&gt;<span class="hljs-built_in">condwait</span>();<br>        &#125;<br>        <span class="hljs-comment">//走到这说明有任务了，此时还是锁的转态可以保持线程同步</span><br>        <span class="hljs-keyword">if</span>(work-&gt;<span class="hljs-built_in">getTer</span>() == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>        &#125;<br>        <span class="hljs-comment">//从任务队列中 抽一个任务</span><br>        Job *job = work-&gt;Jobs-&gt;<span class="hljs-built_in">front</span>();<br>        <span class="hljs-comment">//pop掉任务</span><br>        work-&gt;Jobs-&gt;<span class="hljs-built_in">pop_front</span>();<br>        work-&gt;lock-&gt;<span class="hljs-built_in">muteunlock</span>();<br>        <span class="hljs-comment">//此时解锁，因为我已经拿到任务里，应该不锁了，好像也不是很安全，如果是对处理的是共享的数据呢....</span><br>        cout &lt;&lt; <span class="hljs-built_in">pthread_self</span>() &lt;&lt; <span class="hljs-string">&quot;   data : &quot;</span>;<br>        job-&gt;<span class="hljs-built_in">runFun</span>(); <span class="hljs-comment">//线程运行任务的回调函数</span><br>        <span class="hljs-built_in">delete</span>(job);      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> terminate;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Worker</span>()&#123;<br>terminate = <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getTer</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> terminate;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br><br>        &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">pthread_t</span> tid;  <br>        mylocker *lock;    <br>        list&lt;Job*&gt; *Jobs;<br><br><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//封装 互斥锁 和 条件变量</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mylocker</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">pthread_mutex_t</span> mutexlock;<br><span class="hljs-type">pthread_cond_t</span> cond;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">mylocker</span>()&#123;<br>            mutexlock = PTHREAD_MUTEX_INITIALIZER;<br>cond = PTHREAD_COND_INITIALIZER;<br>        &#125;<br>        ~<span class="hljs-built_in">mylocker</span>()&#123;<br>            <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutexlock);<br>            <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;cond);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">mutelock</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutexlock) == <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">muteunlock</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutexlock) == <span class="hljs-number">0</span>;<br>        &#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">condwait</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_cond_wait</span>(&amp;cond,&amp;mutexlock);<br>&#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">condsignal</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_cond_signal</span>(&amp;cond);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> &amp;mutexlock;<br>        &#125;    <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的简单使用</title>
    <link href="/2022/03/25/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/03/25/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>线程方面的知识一直是很薄弱的， 所以再次翻开 《APUE 》 ，重新再看一遍  第11 章 线程，有不一样的收获，在这总结下线程的一些使用方法 ； （PS： 发现以前好多看的云里雾里的书籍，现在重头看，有种恍然大悟的感觉！）</p></blockquote><h3 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h3><blockquote><p>   进程是程序执行时的一个实例，是担当分配系统资源（CPU时间、内存等）的基本单位。在面向线程设计的系统中，进程本身不是基本运行单位，而是线程的容器。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。</p><p>　　线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。线程包含了表示进程内执行环境必须的信息，其中包括进程中表示线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno常量以及线程私有数据。进程的所有信息对该进程的所有线程都是共享的，包括可执行的程序文本、程序的全局内存和堆内存、栈以及文件描述符。在Unix和类Unix操作系统中线程也被称为轻量级进程（lightweight processes），但轻量级进程更多指的是内核线程（kernel thread），而把用户线程（user thread）称为线程。</p><p>线程和进程一样也有标志号作为识别 </p></blockquote><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a><strong>线程创建</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span> <span class="hljs-params">(<span class="hljs-type">pthread_t</span> *__restrict __newthread, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *__attr,<span class="hljs-type">void</span> *(*fun) (<span class="hljs-type">void</span> *),<span class="hljs-type">void</span> *arg)</span>;<br></code></pre></td></tr></table></figure><p>​参数分别是 线程的pid，线程属性，线程的函数，传入线程的参数，创建失败会返回错误码</p><p>​对于 传参 的arg指针，不需要给线程传入参数的话直接 设置为 null即可</p><h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><p>终止有三种方式</p><ul><li><p>运行完线程代码return 结束</p></li><li><p>被其他线程中终止</p></li><li><p>线程可以调用 pthread_exit  ( 自己终结自己 )</p><p>  pthread_exit（） 可以携带返回值</p></li></ul><p>如果需要 现有线程的返回值怎么办？ 有一个函数可以做到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Make calling thread wait for termination of the thread TH.  The</span><br><span class="hljs-comment">   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN</span><br><span class="hljs-comment">   is not NULL.</span><br><span class="hljs-comment">让调用线程等待线程TH的终止。线程的退出状态存储在*THREAD_RETURN中</span><br><span class="hljs-comment">This function is a cancellation point and therefore not marked with</span><br><span class="hljs-comment">   __THROW.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pthread_join</span> <span class="hljs-params">(<span class="hljs-type">pthread_t</span> __th, <span class="hljs-type">void</span> **__thread_return)</span>;<br><br></code></pre></td></tr></table></figure><p>线程的返回转态可以保存在 __thread_return 中；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/tcp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cleanup : %s \n&quot;</span>,(<span class="hljs-type">char</span> *)arg);<br>&#125;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br>    <span class="hljs-type">char</span> *str = (<span class="hljs-type">char</span> *)arg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str);    <br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">char</span> *ret = <span class="hljs-string">&quot;hrrrr&quot;</span>;<br>    <span class="hljs-keyword">return</span> ((<span class="hljs-type">void</span> *)ret);  <br>&#125;<br><span class="hljs-type">void</span>* <span class="hljs-title function_">fun2</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br>    <span class="hljs-type">char</span> *str = (<span class="hljs-type">char</span> *)arg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str);    <br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">char</span> *ret = <span class="hljs-string">&quot;cccc&quot;</span>;<br>    pthread_exit((<span class="hljs-type">void</span> *)ret);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">pthread_t</span> pid[<span class="hljs-number">5</span>];<br>    <span class="hljs-type">char</span> *str1 = <span class="hljs-string">&quot;str1 传入的参数内容&quot;</span>;<br>    <span class="hljs-type">char</span> *str2 = <span class="hljs-string">&quot;str2 传入的参数内容&quot;</span>;<br><br>    pthread_create(&amp;pid[<span class="hljs-number">0</span>],<span class="hljs-literal">NULL</span>,fun,str1);<br>    pthread_create(&amp;pid[<span class="hljs-number">1</span>],<span class="hljs-literal">NULL</span>,fun2,str2);<br><br>    <span class="hljs-type">void</span> *tre,*tre1;<br>    pthread_join(pid[<span class="hljs-number">0</span>],&amp;tre);   <br>    pthread_join(pid[<span class="hljs-number">1</span>],&amp;tre1);   <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s \n&quot;</span>,(<span class="hljs-type">char</span> *)tre);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s \n&quot;</span>,(<span class="hljs-type">char</span> *)tre1);<br>    sleep(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://imt.rui.vin/202203261542936.png" alt="image-20220326154257729">   </p><p>线程结束后可以得到返回值，返回值分别是return返回的和  pthread_exit结束时返回的</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>​提到线程必然有很多问题 ，多线程并发的时，同时读取相同变量，不是原子性 可以能会有数据不一致的情况（i++）</p><p>​i++ 操作 是</p><ul><li>将内存读取寄存器</li><li>操作寄存器的值</li><li>新的值写内存单元</li></ul><p>哪如何保证线程的同步呢？</p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a><strong>互斥锁</strong></h4><p>对资源加锁后，任何线程试图再次对该互斥量加锁的线程都会阻塞，直到到该锁释放为止，这样可以确保每次只有一个线程可以获取资源</p><p>使用互斥锁得先初始化 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// pthread_mutex_t 是一个结构体</span><br><span class="hljs-type">pthread_mutex_t</span> __mutex;<br><span class="hljs-comment">//init</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_init</span> <span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *__mutex,</span><br><span class="hljs-params">       <span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span> *__mutexattr)</span><br>     __THROW __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>))</span>;<br><br><span class="hljs-comment">/* Destroy a mutex.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_destroy</span> <span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *__mutex)</span><br>     __THROW __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>))</span>;<br><br><span class="hljs-comment">/* Try locking a mutex.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_trylock</span> <span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *__mutex)</span><br>     __THROWNL __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>))</span>;<br><br><span class="hljs-comment">/* Lock a mutex.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_lock</span> <span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *__mutex)</span><br>     __THROWNL __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>))</span>;<br><br><span class="hljs-comment">/* Unlock a mutex.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_unlock</span> <span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *__mutex)</span><br>     __THROWNL __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>))</span>;<br><br></code></pre></td></tr></table></figure><p>使用的话就是在 访问临界区资源之前对 互斥量加锁，尽管这样可以解决线程同步的问题，但是如果存在多个锁，没有设计好加锁顺序，可能造成死锁，看代码</p><p>此时有两个锁和两个线程，每个线程加锁顺序相反的话，就会造成<strong>死锁，</strong>互相等待对方释放资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">pthread_mutex_t</span> plock2;<br><span class="hljs-type">pthread_mutex_t</span> plock1;<br><span class="hljs-type">pthread_mutex_t</span> plock3 = PTHREAD_MUTEX_INITIALIZER;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//以不同顺序加锁</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br><br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>)<br>    &#123;<br>      <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;plock1);<br>      cout &lt;&lt; <span class="hljs-string">&quot;plock1 已经上锁，准备获取plock2锁 &quot;</span> &lt;&lt; endl;<br>      <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;plock2);<br>      cout &lt;&lt; <span class="hljs-string">&quot;plock2 已经上锁&quot;</span> &lt;&lt; endl;<br><br>      <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;plock2);<br>      <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;plock1);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>) <br>    &#123;<br>      <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;plock2);<br>      cout &lt;&lt; <span class="hljs-string">&quot;plock2 已经上锁，准备获取plock1锁&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;plock1);<br>      cout &lt;&lt; <span class="hljs-string">&quot;plock1 已经上锁&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;plock2);<br>      <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;plock1);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">pthread_t</span> pid[<span class="hljs-number">5</span>];<br>    <span class="hljs-type">char</span> *str1 = <span class="hljs-string">&quot;str1 传入的参数内容&quot;</span>;<br>    <span class="hljs-type">char</span> *str2 = <span class="hljs-string">&quot;str2 传入的参数内容&quot;</span>;<br>    <span class="hljs-built_in">pthread_mutex_init</span>(&amp;plock2,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_mutex_init</span>(&amp;plock1,<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">pthread_create</span>(&amp;pid[<span class="hljs-number">0</span>],<span class="hljs-literal">NULL</span>,fun,str1);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;pid[<span class="hljs-number">1</span>],<span class="hljs-literal">NULL</span>,fun2,str2);<br>    <span class="hljs-comment">// pthread_create(&amp;pid[2],NULL,fun3,str2);</span><br><br>    <span class="hljs-type">void</span> *tre,*tre1;<br>    <span class="hljs-built_in">pthread_join</span>(pid[<span class="hljs-number">0</span>],&amp;tre);   <br>    <span class="hljs-built_in">pthread_join</span>(pid[<span class="hljs-number">1</span>],&amp;tre1);   <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s \n&quot;</span>,(<span class="hljs-type">char</span> *)tre);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s \n&quot;</span>,(<span class="hljs-type">char</span> *)tre1);<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>)<br>    &#123;<br>          cout &lt;&lt; <span class="hljs-string">&quot;i的值&quot;</span> &lt;&lt; i++ &lt;&lt; endl;<br>          <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://imt.rui.vin/202203272046460.png" alt="image-20220327204645817">  plock1 和  plock2都 已经上锁，两个线程都在等待对方释放锁，才能进行下去，这种情况下双方都不会释放</p><h4 id="读写锁（-共享互斥锁）"><a href="#读写锁（-共享互斥锁）" class="headerlink" title="读写锁（ 共享互斥锁）"></a>读写锁（ 共享互斥锁）</h4><p>写操作的时候才会互斥，而在进行读的时候是可以共享的进行访问临界区的，    在写少读多的情况下用读写锁更好，为什么呢？  写的时候临界区加锁，这没毛病，读的时候并不需要进修改数据，多线程读数据并不影响数据内容，所以读的时候不用锁共享资源，也节省了系统的开销</p><p>读写锁的分配规则：</p><ol><li>只有线程没有使用读写锁的写转态，那么任意数目的线程都可以使用读写锁</li><li>当有线程持有读写锁的写转态时，其他线程使用读写锁都会被阻塞</li><li>如果读写锁的读模式加锁时，所有线程以读模式它进行加锁的线程都可以得到访问权</li></ol><p>做了实验  使用读写锁，一个线程写数据，两个线程读数据</p><p>写的时候，读线程全部被阻塞<br>读的时候，读线程全都可以获取资源，写线程被阻塞</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">pthread_mutex_t</span> plock2;<br><span class="hljs-type">pthread_mutex_t</span> plock1;<br><span class="hljs-type">pthread_rwlock_t</span> rw_lock;<br><span class="hljs-type">pthread_rwlock_t</span> rwlock;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">13</span>;<br><span class="hljs-comment">//写数据</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">char</span> *arg1 = (<span class="hljs-type">char</span> *)arg;<br><br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>)<br>    &#123;<br>        <span class="hljs-built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);<br>        <br>        cout &lt;&lt; <span class="hljs-string">&quot;开启 写的锁后  i = &quot;</span> &lt;&lt; i++  &lt;&lt; <span class="hljs-string">&quot; 并且i++&quot;</span>&lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;此时所获取这个锁的线程都会被堵塞 3s&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; endl;<br>        cout &lt;&lt; endl;<br><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">pthread_rwlock_unlock</span>(&amp;rwlock);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//以下为读数据</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">char</span> *arg1 = (<span class="hljs-type">char</span> *)arg;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>) <br>    &#123;<br><br>        <span class="hljs-built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);<br>        cout &lt;&lt; <span class="hljs-string">&quot; 我是 fun2  开启只读的锁后  i =&quot;</span> &lt;&lt; i &lt;&lt; endl;<br><br>        <span class="hljs-built_in">pthread_rwlock_unlock</span>(&amp;rwlock);<br><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">fun3</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">char</span> *arg1 = (<span class="hljs-type">char</span> *)arg;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>) <br>    &#123;<br>        <span class="hljs-built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);<br>        cout &lt;&lt; <span class="hljs-string">&quot; 我是 fun3  开启只读的锁后  i =&quot;</span> &lt;&lt; i &lt;&lt; endl;<br><br>        <span class="hljs-built_in">pthread_rwlock_unlock</span>(&amp;rwlock);<br><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-type">pthread_t</span> pid[<span class="hljs-number">5</span>];<br>    <span class="hljs-type">char</span> *str1 = <span class="hljs-string">&quot;str1 传入的参数内容&quot;</span>;<br>    <span class="hljs-type">char</span> *str2 = <span class="hljs-string">&quot;str2 传入的参数内容&quot;</span>;<br>    <span class="hljs-built_in">pthread_rwlock_init</span>(&amp;rwlock,<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">pthread_create</span>(&amp;pid[<span class="hljs-number">0</span>],<span class="hljs-literal">NULL</span>,fun,str1);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;pid[<span class="hljs-number">1</span>],<span class="hljs-literal">NULL</span>,fun2,str1);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;pid[<span class="hljs-number">2</span>],<span class="hljs-literal">NULL</span>,fun3,str1);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">pthread_rwlock_destroy</span>(&amp;rwlock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>条件变量也是同步线程的同步的方式，但还是得借助互斥锁；  当一个线程获取锁之后，他需要等待一定的条件才能继续执行，执行完成再释放锁，这个条件可能是其他线程计算的结果，等待条件的时候可以 一直判断这个条件是否成立（加个while）但这样太消耗CPU的资源了，资源会被一个线程都占用，使用条件变量可以 使线程进入等待转态，等待其他线程完后发送信号给条件变量，从而继续执行</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>​ 与互斥锁类似，等待互斥锁时线程是阻塞的，而自旋锁是一直在询问这个锁是否可用（会占用CPU），所以自旋锁适用于锁持有时间短的场景，长时间占用自旋锁是很占用CPU资源的，使用自旋锁的话对于 竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗，也是自旋锁适用于所持有时间的场景的原因。</p><p>待更新</p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http的小总结</title>
    <link href="/2022/03/24/http%E5%92%8Chttps%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <url>/2022/03/24/http%E5%92%8Chttps%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>最近看图解网络，在这里做个笔记</p><h4 id="http的概念"><a href="#http的概念" class="headerlink" title="http的概念"></a>http的概念</h4><p>​http -&gt; 超文本传输协议，早期只是用来传输文本，现在可以用了传输音频图像，所以称为超文本协议</p><h4 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a><strong>GET</strong> <strong>与</strong> <strong>POST</strong></h4><ul><li><p>get请求： get 意为得到，取得  get请求就是  请求<strong>从服务器获取资源</strong>，这个资源可以是静态的⽂本、⻚⾯、图⽚视频等。</p></li><li><p>post请求： post 投递的意思，他将指定的资源通过http协议提交服务器</p></li></ul><p>  说到get和post 又得提到 安全 和 幂等</p><ul><li>安全是指 多次请求不会对服务区产生副作用，即不会改变资源的转态，打个比方，我想用get请求一个网页，无论操作多少次，对服务器上的数据都不影响，而post有新增或提交数据的操作，会修改服务器上的资源，所以不是安全的</li><li>幂等是指多次执⾏相同的操作，得到的结果都是相同的，每次get请求一个页面，都是一样的则这个是幂等的</li></ul><h4 id="http特性"><a href="#http特性" class="headerlink" title="http特性"></a>http特性</h4><ul><li><p>跨平台，易扩展</p><p>  手机端，PC端都可以使用</p></li><li><p>简单，http 格式   有 header + body（数据 ),头部 key -value形式存储如下所示</p></li></ul><blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/admin_ui/rdx/core/images/close.png</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://xxx.xxx.xxx.xxx/menu/neo<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en-US<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C; .NET4.0E)<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>xxx.xxx.xxx.xxx<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Keep-Alive<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>startupapp=neo; is_cisco_platform=0; rdx_pagination_size=250%20Per%20Page; SESSID=deb31b8eb9ca68a514cf55777744e339<br></code></pre></td></tr></table></figure></blockquote><ul><li>无状态  服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存⽤来对外提供服务 ，就好像  登录了某个网站，正常来说验证一次密码（那是有cookie情况下），没状态情况是 每次操作都得重新输入一次密码，这样肯定不方便，后来引入cookie；</li><li>不安全：<ul><li>明文传输，抓包一下子就数据就泄漏了</li><li>没有验证对方的真实身份，可能访问到伪装的网站</li><li>可以篡改报文内容，抓包后修改里面的内容也是可以的</li></ul></li></ul><hr><h4 id="http-和-https（重点）"><a href="#http-和-https（重点）" class="headerlink" title="http 和 https（重点）"></a>http 和 https（重点）</h4><p>上文收到htpp传输是明文传输不安全的，数据有篡改和冒充的风险，为了提高安全性，目前都基本使用 https, 这里的s指的 是SecureSocket Layer（SSL） 的首字母，意为安全套接层</p><h5 id="https是什么？"><a href="#https是什么？" class="headerlink" title="https是什么？"></a>https是什么？</h5><p>​HTTPS 可以解决 HTTP 不安全的缺陷，在TCP 和 HTTP ⽹络层之间加⼊了 SSL&#x2F;TLS 安全协议，使得报⽂能够加密传输。HTTPS 在 TCP 三次握⼿之后还需要进行 SSL&#x2F;TLS的握手过程，才可进⼊加密报⽂传输； HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的（防止伪装站点）。</p><p><img src="http://imt.rui.vin/202203271518389.png" alt="image-20220327133731705" style="zoom: 50%;" /> HTTP和TCP直接加了一层SSL&#x2F;TLS</p><h5 id="公钥-私钥-对称加密"><a href="#公钥-私钥-对称加密" class="headerlink" title="公钥 私钥 对称加密"></a>公钥 私钥 对称加密</h5><ul><li>公钥 和 私钥  ：  可以类比为 公钥→锁头  私钥→钥匙（私钥只有一把只有一把） 我用公钥加密数据，那我就的用对应的私钥解密数据</li><li>非对称加密：  使用两个秘钥来加密数据， 就是上面提到的 公钥和秘钥</li><li>对称加密：  使用一个共同加密方式来 加密数据，简称 会话秘钥</li><li>证书： 可以理解为一种合法身份的象征，把公钥放在证书里，只要证书是可信的，公钥就是可信的</li></ul><h5 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h5><p>HTTPS 采⽤的是对称加密和⾮对称加密结合的「混合加密」⽅式：</p><ul><li>在通信建⽴<strong>前</strong>采⽤⾮对称加密的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。</li><li>在通信过程<strong>中</strong>全部使⽤对称加密的「会话秘钥」的⽅式加密明⽂数据。</li></ul><h5 id="如何实现的呢？"><a href="#如何实现的呢？" class="headerlink" title="如何实现的呢？"></a><strong>如何实现的呢？</strong></h5><p>在TCP三次握手后，   首先使用非对称加密的方式 生成会话秘钥，接下来服务端和客户端都是使用 这个会话秘钥加密数据（对称加密），所以现在分为两部分来讲，以下也会SSL&#x2F;TLS协议基本流程</p><ul><li><p>非对称加密</p><p>  <strong>这部分的目标是生成 会话秘钥，双方都可用的秘钥！</strong></p><p>  这里我先用通俗的语言来说</p><blockquote><p>服务器 自己有 公钥和秘钥， 他把公钥 交给比较权威的机构，生成证书，机构使用自己的私钥加密这个证书</p><p>客户端这边 携带了 机构的公钥，然后客户想服务端请求证书，然后用机构的公钥确定这个证书是否是可信的，如果用记过的公钥能解锁这个证书，说明服务端是经过机构认证的，就可通过证书获得服务端的公钥！</p></blockquote><ul><li>为什么要通过第三方来过去服务端的公钥呢？</li></ul><p>  ​      如果直接把服务端的公钥发给客户端没有加密的话，中间如果有人拦截了并伪造了公钥，那就后果不堪设想了，所以有了证书确认身份，可以减少这个风险发生；</p><p>  ​     现在客户端获得了服务端的公钥，用服务端的公钥加密消息，和服务端通信，商定好 会话秘钥，而这这个会话秘钥如何生成的呢？ 是通过 ssl协议的四次握手生成的<br>    - 首先客户端向服务器发起加密通信请求，加密内容包含了客户端产生的随机数， SSL&#x2F;TLS 协议版本，如 TLS 1.2 版本，以及客户端支持的解密算法，最后用从证书获取服务端的公钥进行加密。这里就保证了只有服务端才能看到这个消息（只有服务端才有私钥）。<br>    - 服务端收到后，给客户端发出响应，内容如下</p><pre><code class="hljs">    （1）确认 SSL/ TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。</code></pre><p>  ​       （2）服务器⽣产的随机数（ Server Random ），后⾯⽤于⽣产「会话秘钥」。 </p><p>  ​       （3）确认的密码套件列表，如 RSA 加密算法。 （确定使用那种算法） </p><p>  ​       （4）服务器的数字证书</p><p>  ​          服务端也会产生随机数，且确定使用那种加密算法，此时还需要确定这个消息真实性，防止被别人篡改了，所以还需要再一次            验证证书是否可信</p><ul><li><p>客户端收到后，⾸先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。没问题的话取出证书的公钥来加密待会要发送的数据，待发送的数据如下</p><pre><code class="hljs">（1）⼀个随机数（ pre-master key ）。该随机数会被服务器公钥加密。</code></pre></li></ul><p>  ​         （2）加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。 </p><p>  ​ （3）客户端握⼿结束通知，表示客户端的握⼿阶段已经结束。同时把之前所有内容的发⽣的数据做个摘要，⽤来供服务端校验</p><ul><li>服务端收到后，也会回应，也是最后一次回应了，通过私钥解密，服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发⽣最后的信息。</li></ul><p>  ⾄此，整个 SSL&#x2F;TLS 的握⼿阶段全部结束。接下来，客户端与服务器进⼊加密通信，实际上还是使用基本http通信，只不过是 通信前双方 约定好加密解锁方式而已</p></li></ul><p>​       对于https 介绍到这里先结束，其实这其中还有很多的细节没有阐述清楚，后续又遇到关于https的问题再补充下；</p><hr><h4 id="https1-1-改进和瓶颈"><a href="#https1-1-改进和瓶颈" class="headerlink" title="https1.1 改进和瓶颈"></a>https1.1 改进和瓶颈</h4><ul><li><p>长链接</p><p>  http1.0 中 每一次的请求都建立三次握手（http是基于tcp的），增加了开销，http1.1 增加了长链接方式，建立了一次tcp链接后，接下来都不需要重新握手</p></li><li><p>管道传输</p><p>  hhtp1.0 中发一次请求，等待回应，有回应后然后在发送下一个请求，在1.1中，使用过管道传输则可以同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以<strong>减少整体的响应时间</strong>  </p></li><li><p>瓶颈</p><ul><li>但是可能会造成对头堵塞  多个请求发个服务器后，服务器处理请求还是按照先后顺序来，如果某个请求耗时长，堵塞了接下来的请求（可以加开多几条连接）</li><li>协议头部无法压缩，只能压缩 Body 部分，传输效率低</li><li>请求只能客户端开始，服务器只能被动响应（websocket 可以）</li></ul></li></ul><h4 id="http2-0-改进"><a href="#http2-0-改进" class="headerlink" title="http2.0 改进"></a>http2.0 改进</h4><ul><li><p>头部压缩</p><p>发送多个请求如果 是头部数据相似，协议会使用头部压缩算法（HPACK）清除重复的部分</p></li><li><p>使用二进制文本</p><p>从明文报文改进为二进制格式的报文，对计算机来说，可以直接解析，增加数据的传输效率</p></li><li><p>多路复用</p><p>一个连接并发多个请求或回应，不用像上一代版本会有阻塞，通俗的说就是服务端处理这A和B两个请求，A的处理时间比较长，于是就先回应A处理好的部分，然后回应B请求，然后再回复A请求剩下的（如果出现丢包还能回阻塞的）</p></li><li><p>服务器推送</p><p>HTTP2.0新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确的请求。HTTP 2.0 可以使<strong>服务器主动返回资源</strong>给客户端用户。</p></li></ul><h4 id="http3-0"><a href="#http3-0" class="headerlink" title="http3.0"></a>http3.0</h4><p>基于UDP的QUIC协议，主要改进的问题还是 请求阻塞的问题（udp传输特性），减少了tcp三次握手时间，以及tls握手时间</p><hr><p>待更新</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCI/IP网络模型（层）</title>
    <link href="/2022/03/23/TCI-IP%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%BA%94%E5%B1%82%EF%BC%89/"/>
    <url>/2022/03/23/TCI-IP%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%BA%94%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  看图解网络的一些理解：  总的来说数据通过一层一层封装后 ，最终转换成电信号发送到另外一台主机，数据也从底层开始，一层一层的解包得到想要的数据；将每一层都专注自己的职责，对于开发者说更多只需要 关注应用层的处理就可以了。</p><p>此外本文 网络模型 整体做个介绍，后续会对每一层 比较主要的 知识点进行详解</p></blockquote><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>​ 使用的一些http，ftp，ssh，这些都是属于应用层，要发送的数据通过 应用层的协议包装起，传到传输层，而且应用层是处于用户态，传输层是处于内核态</p><h4 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h4><p>​收到应用层的数据包，传输层又会对这些这些数据进行打包，或者将数据分割后打包，传输层有两种协议： TCP 和UDP （这两种区别不在本文细说），此时这些操作处于内核态操作了。</p><h4 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h4><p>​传输层是准备好数据，网络层则是将数据传输到另外一个设备，此外网络层用到的是IP协议，通过该协议进行再一次封装，</p><p><img src="http://imt.rui.vin/202203231557336.png" alt="image-20220323155745319" style="zoom: 80%;" /> 参考图解网络的图</p><h4 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h4><p>​同一个局域网内可以通过子网地址和主机号来区别，而不同子网呢？则需要跨网络传输，在这层也是需要对数据进行封装，而且要附带设备的mac地址，路由器计算出了下⼀个⽬的地 IP 地址，再通过 ARP 协议找到该⽬的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了</p><p><img src="http://imt.rui.vin/202203231534067.jpeg" alt="TCP/IP协议的组成"></p><p>接下来的任务就是交给 物理层里，，需要把数据包转换成电信号，让其可以在物理介质中传输</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于虚函数的一些总结</title>
    <link href="/2022/03/12/%E5%85%B3%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2022/03/12/%E5%85%B3%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>说到多态又可以联想到虚函数，虚函数又有很多相关问题，这次做个小总结</p><p>1 . 什么是虚函数</p><ul><li><p>虚函数在有多态的前提下才有的特性，现在问题是多态是什么？</p><p>  多态可以分为：</p><p>  ​静态多态：函数重载，根据参数不同，从而调用不同的函数（这里不做重点介绍）</p><p>  ​    动态多态： 根据操作的对象不同，从而调用不同的函数（使用虚函数实现）</p><p>  总的来说：  同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结</p></li></ul><p>​     现在看下动态多态是怎么使用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Shape</span>() &#123;&#125;<br>  ~<span class="hljs-built_in">Shape</span>() &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">int</span> x, y;<br>  <span class="hljs-built_in">Rectangle</span>(<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">0</span>) &#123;<br>    x = a;<br>    y = b;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot; Rectangle area &quot;</span> &lt;&lt; x * y &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Round</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">int</span> x, y;<br>  <span class="hljs-built_in">Round</span>(<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">0</span>) &#123;<br>    x = a;<br>    y = b;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot; Rount area &quot;</span> &lt;&lt; <span class="hljs-number">3.14</span> * y &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  Shape *t;<br>  <span class="hljs-function">Round <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>  <span class="hljs-function">Rectangle <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>  t = &amp;r;  <span class="hljs-comment">//基类指针指向 Round 类r</span><br>  t-&gt;<span class="hljs-built_in">area</span>(); <span class="hljs-comment">//Rount area 6.28</span><br>  t = &amp;y;  <span class="hljs-comment">// 基类指针指向 Rectangle </span><br>  t-&gt;<span class="hljs-built_in">area</span>(); <span class="hljs-comment">// Rectangle area 6</span><br>  <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>基类用 virtual 声明了函数，用基类的指针指向不同的派生类，然后基类的指向的函数也有不同的效果</p><p>那这个的原理是怎样的呢？即虚函数如何实现的？</p><p>如果一个带有虚函数的类的大小他的大小是多大呢？<br><img src="http://imt.rui.vin/202203151407880.png" alt="image-20220314163106660" style="zoom:80%;" /></p><p>先不说为什么空类大小为1 ，我们先说带有虚函数的类大小为4,  因为带有虚函数的类有一个<strong>指向函数数组</strong>的指针，而指针是4个字节的，指针指向的数组可以函数，那么能否直接自己直接通过指针来调用虚函数呢？  答案是可以的</p><p><img src="http://imt.rui.vin/202203151448327.png" alt="image-20220315144827997"></p><p>如上图所示，用通过 base 实例化的 b地址 可以调用类中的虚函数，通过偏移值的不同，调用不同的函数 ，可以看出 实例化后的 b是有个指针指向一个指针数组 ，就该base类而言，内存布局如下：</p><p><img src="http://imt.rui.vin/202203151506531.png" alt="image-20220315150631707"></p><p>现在我们知道了虚函数表的如何存在的，那如何通过这个实现多态的呢？</p><p>用一个基类的指针指向派生类时候，如果派生类中有函数重载了父类的虚函数，则会替换虚函数表中对应的函数<br>就是说 ： 假如派生类也有函数 f();  此时 虚表中 f()的函数地址 会被 派生类的 f() 函数替换（也称为动态联编）<br>与基类指针 指向 f() 时，执行的是派生类的 f()</p><p><img src="http://imt.rui.vin/202203151520475.png" alt="image-20220315152052778"></p><p>大致上的原理 就这样，其实还有多细节没有补充，想着通过反汇编来看下动态联编是怎么实现，后续再来吧..</p><p>一些虚函数的问题</p><h4 id="什么函数不能声明为虚函数"><a href="#什么函数不能声明为虚函数" class="headerlink" title="什么函数不能声明为虚函数"></a>什么函数不能声明为虚函数</h4><ol><li><p>构造函数</p><p> 虚表指针的初始化时在构造函数进行的，而虚函数需要放到虚表中。在调用虚函数前，必须首先知道虚表指针，所以不行</p></li><li><p>普通函数</p><p> 虚函数需要在继承多态下使用才有意义</p></li><li><p>静态函数</p><p> 静态函数可以直接调用不需要指针</p></li><li><p>内联函数</p><p> 内联函数属于静态联编，即是编译阶段就确定调用哪个函数了，虚函数是动态联</p></li><li><p>友元函数</p><p> 有元函数不支持继承</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>C++语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reactor模式的介绍</title>
    <link href="/2022/03/12/reactor%E6%A8%A1%E6%8B%9F%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/03/12/reactor%E6%A8%A1%E6%8B%9F%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>说Reactor模式前 我们看下epoll实现的服务器有什么改进的地方</p><p>在上几篇博客有介绍 <a href="http://rui.vin/2022/03/10/%E5%AF%B9io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/">io多用复用</a> 其中主要介绍了epoll，最后 epoll实现了 io多路复用的服务器，我们再捋一捋<br>目前大致情况就是这样，现在是可以用，但是呢？ 还可以优化下吗？因为每次都是要问三次情况,有点冗d余了</p><p><img src="http://imt.rui.vin/202203121406752.png" alt="image-20220312140629959"></p><p>客户端有连接也是通过一个fd来管理，也是可读事件，那么讲 客户端连接也纳入 可读事件里</p><p>现在如下图所示： </p><p><img src="http://imt.rui.vin/202203121408096.png" alt="image-20220312140829460"><br>确实是比较精简了，现在分为两部分，可读，可写，但实际上，可读里面还是得再分 是客户端连接还是有数据可读，还可不可再改进一点呢？</p><p>现在分为两大类，一类是 可读io，一类是可写io，这些都是对文件描述符进行操作，而且都是独一无二的，如果说每个文件描述符都对应一个函数的话，会不会方便很多呢？对应的函数也可以分为三类，可读，可写，建立连接；那可以建立一个结构体，用来保存fd和对应的操作函数，对应的操作函数，还有一个最为关键的是  结构体 epoll_event 不但可以保存fd，和io事件响应类型，其中还有个空指针</p><p><img src="http://imt.rui.vin/202203121424505.png" alt="image-20220312142311053"><br>每次加入 epoll_event 之前，将 *ptr执行一个结构体，该结构体包含一个  fd 和 一个函数指针<br><img src="http://imt.rui.vin/202203121424851.png" alt="image-20220312142445086"></p><p>现在呢 可是这样来处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nready; i++) &#123;<br>   <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;   <span class="hljs-comment">//可读</span><br>     <span class="hljs-comment">// printf(&quot;sockitem\n&quot;);</span><br>     <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockitem</span> *si = (<span class="hljs-keyword">struct</span> sockitem *)events[i].data.ptr; <span class="hljs-comment">//抽出 events里的保存的结构体</span><br>     si-&gt;<span class="hljs-built_in">callback</span>(si-&gt;sockfd, events[i].events, si); <span class="hljs-comment">// 通过结构体调用对应的函数（回调函数）</span><br>   &#125;<br><br>   <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;<br>     <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockitem</span> *si = (<span class="hljs-keyword">struct</span> sockitem *)events[i].data.ptr;<br>     si-&gt;<span class="hljs-built_in">callback</span>(si-&gt;sockfd, events[i].events, si);<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>到了这里 代码模式 转化为 事件驱动  ： 有是三种事件  ，建立连接，读取数据，写入数据，有两种 fd ，listenfd 和 clientfd</p><h2 id="reactor-是什么？"><a href="#reactor-是什么？" class="headerlink" title="reactor 是什么？"></a>reactor 是什么？</h2><p>reactor 有反应堆的意思，这个堆则是 那些已经建立好的回调函数，当有 事件来了，ractor就有相对应的反应<br>这也是中思想，本文中的代码也是朝着这种思想改进；reactor有三种模式</p><ul><li><p>单 Reactor 单进程 &#x2F; 线程；</p><pre><code class="hljs"> 目前现在就是处于这种模式</code></pre><p>  <img src="http://imt.rui.vin/202204062335512.png" alt="image-20220312150155896"><br>  单 Reactor 单进程的方案因为全部工作都在<strong>同一个进程</strong>内完成，所以实现起来比较简单，不需要考虑进程间通信，也不用担心多进程竞争。</p><ul><li>第一个缺点，因为只有一个进程，<strong>无法充分利用 多核 CPU 的性能</strong>；</li><li>第二个缺点，如果读写事件（业务）时间很长，而此时又突然有大量的连接接入，可能会成延迟</li></ul><p>  所以，单 Reactor 单进程的方案<strong>不适用计算机密集型的场景，只适用于业务处理非常快速的场景</strong>。</p></li><li><p>单 Reactor 多线程 &#x2F; 进程；</p><ul><li>单 Reactor 多线程</li></ul><p>  开始时和 单 Reactor 单进程 一样，但在每个事件（业务）中，handle （fd对应的函数）用一个线程来处理这些业务，处理好了返回给handle<img src="http://imt.rui.vin/202203121514636.png" alt="image-20220312151449241"></p><p>  发挥了多核cpu的威力，线程直接通讯比较方便，但是使用多线程必然会产生资源竞争的问题，那要考虑线程锁的问题了</p><ul><li><p>单 Reactor 多线程</p><p>  单 Reactor 多线程 用的比较少，不过还是可以实现，用fork则是可以实现，进程间通讯比较麻烦…</p></li></ul><p>  「单 Reactor」的模式还有个问题，<strong>因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方</strong>。</p></li><li><p>多 Reactor 多进程 &#x2F; 线程；</p><p>  该模式和前两者相比是把Reactor线程拆分了mainReactor和subReactor两个部分，mainReactor只处理连接事件，读写事件交给subReactor来处理。业务逻辑还是由线程池来处理</p></li></ul><p><img src="http://imt.rui.vin/202203121528400.png" alt="image-20220312152848304"></p><p>通俗点就是说 ： 一个线程用于接收客户端连接，处理业务的用一个线程池来处理，池里有多少个线程按照多少个cpu的核心数而定</p><p>带更新…</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>char*和char[]的区别</title>
    <link href="/2022/03/11/char-%E5%92%8Cchar-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/03/11/char-%E5%92%8Cchar-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>关于此类的问题都放在这里了，不另起文章了</p><p>遇到了一道题目：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">char</span> *x = <span class="hljs-string">&quot;abcd&quot;</span>;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">fun2</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;abcd&quot;</span>;  <span class="hljs-comment">//存放在静态数据区</span><br>  <span class="hljs-keyword">return</span> str;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cout &lt;&lt; <span class="hljs-built_in">fun1</span>() &lt;&lt; endl;  <span class="hljs-comment">//abcd</span><br>  cout &lt;&lt; <span class="hljs-built_in">fun2</span>() &lt;&lt; endl;  <span class="hljs-comment">// </span><br>  <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个输出是怎样的？<br>第一时间就意识到 函数调用结束后，这些变量不是都被回收了吗，那应该不存在才对  （想到的是栈的特性）</p><p>于是上机一测，发现fun1是有输出的，fun2没有， 哦？ 那这样说明  字符常量不是在栈里分配内存的？</p><p>原来 字符串常量也是存储在<strong>静态存储区</strong>，那这样就是说，char *p 指向的内存没有被回收，嗯，这样就说的通了</p><p>而  char str[] 呢？ 前几天遇到一个题目  strlen(“abcd”)  结果是？ 第一次看到这个 ，有点蒙，“abcd” 也是变量吗？<br>上机一测还真是 4 个字节，尝试下  <strong>cout &lt;&lt; &amp;”abcd” &lt;&lt; endl;</strong>  发现这也是有地址的！！！！ 所以也说的通了，</p><p> char str[] 是个字符数组，字符数组是有占用空间的，  在执行    <strong>char str[] &#x3D; “abcd”</strong>    时候，发生了一次拷贝将<br>内存”abcd”拷贝到str数组中，函数结束运行的时候，str的空间也被回收了，而对于char *p 而言，回收的知识这个<br>p的指针（指针也是变量）</p><p>还有个实验完全可以证明， 字符串常量是在 静态存储区</p><p><img src="http://imt.rui.vin/202203112350024.png" alt="image-20220311235052265"></p><p><strong>尽管fun1结束了，打印“abcd”的地址还是和fun1运行时的一样</strong></p><p>总结 ： fun1 中的 x执行的内存是 是在  静态存储区 不是堆也不是栈<br>             fun2 中的 str保存在栈中</p><hr><p>sizeof  和 strlen的用法区别 小结</p><ul><li><p>sizeof是关键字  获取某个数据类型所占用空间的字节数</p></li><li><p>strlen是函数可以看有多少个字符 以 ‘\0’ 结束</p></li><li><p>典型问题  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;abcdd&quot;</span>;     <span class="hljs-comment">//  abcdd 在一片连续内存中，并且占用了6个字节  最后一个字节是 &#x27;\0&#x27;  注意：str的指针指向这一片 内存地址</span><br> <span class="hljs-type">char</span> strp[] = <span class="hljs-string">&quot;asdfe&quot;</span>;   <span class="hljs-comment">//  上文说过是 asdfe拷贝到strp字符数里面    strp里面有 6个字节大小</span><br> cout &lt;&lt; <span class="hljs-built_in">strlen</span>(str)  &lt;&lt;  endl;  <span class="hljs-comment">//5    遇到最后一个 &#x27;\0&#x27; 就结束了</span><br> cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(str)  &lt;&lt;  endl;  <span class="hljs-comment">//4 对str这个变量的类型大小计算    str是个字符指针   所以是4个字节</span><br> cout &lt;&lt; <span class="hljs-built_in">strlen</span>(strp) &lt;&lt;  endl;  <span class="hljs-comment">//5  遇到最后一个 &#x27;\0&#x27; 就结束了</span><br> cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(strp)  &lt;&lt;  endl;  <span class="hljs-comment">//6 对strp这个变量类型大小计算   strp是个字符数组，计算整个数组的字节数大小</span><br><br><span class="hljs-comment">/*----------*/</span><br><span class="hljs-type">char</span> p[] =  &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br><span class="hljs-type">char</span> q[] =  &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;  <span class="hljs-comment">//这种情况下末尾是不带 &#x27;\0&#x27; 的</span><br>cout &lt;&lt; <span class="hljs-built_in">strlen</span>(q) &lt;&lt;  endl;   <span class="hljs-comment">//没有 &#x27;\0&#x27; 结束标志 结果为止</span><br>cout &lt;&lt; <span class="hljs-built_in">strlen</span>(p) &lt;&lt;  endl;  <span class="hljs-comment">//5 有结束标志</span><br><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(q) &lt;&lt;endl;   <span class="hljs-comment">// 5 直接找到数组的大小</span><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt;endl;   <span class="hljs-comment">// 7</span><br><br><br></code></pre></td></tr></table></figure><p>  总结： 这种就是要注意 字符后面有无带  结束标志 ‘\0’ ,  sizeof是统计 对象类型所占的空间  strlen 是遍历内存遇到 ‘\0’ 结束</p>  <img src="http://imt.rui.vin/202203161950232.png" alt="image-20220316195022149" style="zoom: 67%;" /></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>基础语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>epoll中 LT 和 ET 区别</title>
    <link href="/2022/03/11/epoll%E4%B8%AD%20LT%20%E5%92%8C%20ET%20%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/03/11/epoll%E4%B8%AD%20LT%20%E5%92%8C%20ET%20%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>上文解释过epoll 原理，现在梳理下epoll 的用法和 epoll 中两个读取数据的模式</p><p>现在用epoll 实现一个多路复用的服务器(代码在最后)</p><ul><li>LT 水平触发  有数据到来就一直读，直到没有数据可以读取了        </li><li>ET 边缘触发  有到无，读规定的字节数，没读完，下次有事件了再读取</li></ul><p>读取客户端发来的数据时候，只读五个字节，看下ET和LT会有什么不同</p><p><img src="http://imt.rui.vin/202203112222329.png" alt="image-20220311222200962"></p><ul><li>ET模式下 <strong>必须使用非阻塞fd</strong>：</li></ul><p><img src="http://imt.rui.vin/202203112229580.png" alt="image-20220311222904069"></p><p>连接后：</p><p><img src="http://imt.rui.vin/202203112223478.png" alt="image-20220311222323848"></p><p>第一次客户端发了 7 个字节，而服务器只接受五个字节就结束，第二次客户端发送一个字节，客户读取了三个字节，显然还是读取上一次未读取的完的，  所以et模式就是 自己能在缓冲区读多少就读多少，读不完下次还来读</p><ul><li>LT模式下：<br>  如果没有设置，默认的是LT模式<br>  <img src="http://imt.rui.vin/202203112228039.png" alt="image-20220311222834196"></li></ul><p>​<img src="http://imt.rui.vin/202203112232077.png" alt="image-20220311223210774"></p><p>​客户端发送了15个字节，服务器读了三次，也就是说只要缓冲区没读完，就一直有事件响应，  LT   等效于    （一个while + ET）</p><p>​实现原理还有待后续挖掘（待填坑）</p><p>服务端代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/tcp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_LENGTH 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLL_SIZE 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLL_SIZE 1024</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Paramter Error\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> port = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> addr;<br>  <span class="hljs-built_in">memset</span>(&amp;addr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in));<br><br>  addr.sin_family = AF_INET;<br>  addr.sin_port = <span class="hljs-built_in">htons</span>(port);<br>  addr.sin_addr.s_addr = INADDR_ANY;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;addr, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in)) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(sockfd, <span class="hljs-number">5</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;<br>  <span class="hljs-comment">//相当于建立一颗  红黑树</span><br>  <span class="hljs-type">int</span> epoll_fd = <span class="hljs-built_in">epoll_create</span>(EPOLL_SIZE);<br>  <span class="hljs-comment">// ev 是保存 fd的结构体</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> ev, events[EPOLL_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-comment">//初始化 ev</span><br>  ev.events = EPOLLIN;  <span class="hljs-comment">//事件类型</span><br>  ev.data.fd = sockfd;  <span class="hljs-comment">// sockfd是监听有无用户连接的io</span><br>  <span class="hljs-comment">//向红黑树中插入 节点</span><br>  <span class="hljs-built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, sockfd, &amp;ev);<br>  <span class="hljs-comment">//开始</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// nready 是意思是有几个事件产生，并且会将产生的事件放在 events数组中</span><br>    <span class="hljs-type">int</span> nready = <span class="hljs-built_in">epoll_wait</span>(epoll_fd, events, EPOLL_SIZE, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span> (nready == <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll_wait\n&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">//开始遍历</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nready; i++) &#123;<br>      <span class="hljs-comment">// sockfd有响应说明 有新的客户端来连接了</span><br>      <span class="hljs-keyword">if</span> (events[i].data.fd == sockfd) &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_addr;<br>        <span class="hljs-built_in">memset</span>(&amp;client_addr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in));<br>        <span class="hljs-type">socklen_t</span> client_len = <span class="hljs-built_in">sizeof</span>(client_addr);<br><br>        <span class="hljs-type">int</span> clientfd =<br>            <span class="hljs-built_in">accept</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_len);<br>        <span class="hljs-keyword">if</span> (clientfd &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-type">char</span> str[INET_ADDRSTRLEN] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recvived from %s at port %d, sockfd:%d, clientfd:%d\n&quot;</span>,<br>               <span class="hljs-built_in">inet_ntop</span>(AF_INET, &amp;client_addr.sin_addr, str, <span class="hljs-built_in">sizeof</span>(str)),<br>               <span class="hljs-built_in">ntohs</span>(client_addr.sin_port), sockfd, clientfd);<br><br>        ev.events = EPOLLIN;<br>        ev.data.fd = clientfd;<br>        <span class="hljs-built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, clientfd, &amp;ev);<br>      &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//这种情况是连接得用户有io响应</span><br>        <span class="hljs-type">int</span> clientfd = events[i].data.fd;<br><br>        <span class="hljs-type">char</span> buffer[BUFFER_LENGTH] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-comment">//读取数据</span><br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recv</span>(clientfd, buffer, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read all data&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>          &#125;<br>          <span class="hljs-comment">//释放  fd</span><br>          <span class="hljs-built_in">close</span>(clientfd);<br> <span class="hljs-comment">//设置为  ET模式 </span><br>          ev.events = EPOLLIN | EPOLLET;   <br>          ev.data.fd = clientfd;<br>          <span class="hljs-comment">//从红黑树删除</span><br>          <span class="hljs-built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_DEL, clientfd, &amp;ev);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; disconnect %d\n&quot;</span>, clientfd);<br>          <span class="hljs-comment">// ret == 0;  ret</span><br>          <span class="hljs-built_in">close</span>(clientfd);<br><br>          ev.events = EPOLLIN;<br>          ev.data.fd = clientfd;<br>          <span class="hljs-built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_DEL, clientfd, &amp;ev);<br><br>          <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Recv: %s, %d Bytes\n&quot;</span>, buffer, ret);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-comment">// struct sockaddr_in</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-comment">// inet_addr</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-type">int</span> x;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> <span class="hljs-comment">//信号到来，则执行这个函数，输出超时</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">close</span>(x);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> socket_desc;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> server;<br>  <span class="hljs-type">char</span> *message, server_reply[<span class="hljs-number">2000</span>];<br>  <span class="hljs-built_in">signal</span>(SIGINT, handler);<br>  <span class="hljs-comment">// 创建socket</span><br>  socket_desc = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == socket_desc) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;cannot create socket&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  x = socket_desc;<br>  <span class="hljs-comment">// 设置远程服务器的信息</span><br>  server.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>  server.sin_family = AF_INET;<br>  server.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">1234</span>);<br><br>  <span class="hljs-comment">// 连接</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(socket_desc, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;server, <span class="hljs-built_in">sizeof</span>(server)) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;cannot connect&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// 发送数据</span><br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    std::string str;<br>    std::cin &gt;&gt; str;<br>    str.<span class="hljs-built_in">c_str</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">send</span>(socket_desc, str.<span class="hljs-built_in">c_str</span>(), str.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;send data error&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect success&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>- </p>]]></content>
    
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对io多路复用的一些理解</title>
    <link href="/2022/03/10/%E5%AF%B9io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <url>/2022/03/10/%E5%AF%B9io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h4 id="1-什么是io多路复用"><a href="#1-什么是io多路复用" class="headerlink" title="1.什么是io多路复用"></a>1.什么是io多路复用</h4> <span id="more"></span><p>​    <strong>多路复用是同步的！！！！</strong></p><p>​单个进z程管理多个文件描述符<br>​总的来说就使用单个进程管理（监听）更多的io</p><h4 id="2-io多路复用模型-通俗的解释，如何用，底层原理是什么？"><a href="#2-io多路复用模型-通俗的解释，如何用，底层原理是什么？" class="headerlink" title="2.io多路复用模型 通俗的解释，如何用，底层原理是什么？"></a>2.io多路复用模型 通俗的解释，如何用，底层原理是什么？</h4><ul><li><p>通俗的理解 举个例子：</p><p>  有一家新开的饭店，开始的时候，他是这样安排服务员的：每一桌都安排一个服务员，这个服务员负责这张桌子的点菜，茶水；顾客点完菜，服务员把菜单<strong>送到后厨</strong>， 饭店刚开始只有10几张桌子，后来每天都有百余张桌子，出现了一个问题，有时候后厨一下子塞满了人，出现了拥堵，客人那边长时间没人服务….（<strong>类比多进程管理多个io</strong>）</p><p>  后来饭店老板想到了一个方法，让一个人来专门送菜单都后厨，这个服务员呢会逐个逐个问那些服务员，有没有菜单要送到后厨的，收集完了后然再统一拿到后厨，这样后厨就不会拥堵啦。（类比单进程管理多个io，这个类似select 做法）</p><p>  可还是有问题，一张一张桌去问还是太费时间了，有些顾客点了菜就不在点菜了，有的要点很久，再后来，老板又想到了一个方法，每个桌子都安装一个按钮，顾客点好菜了，嗯按钮，那个专门收集菜单的人就去那张桌子那菜单（epoll ）；</p></li></ul><p>​    以上并不是概念，只是抽象的比喻而已，对io多路复用模型有 三种  ： select ，poll，epoll</p><p>​ select：  虽然效率不高，但可以跨平台；单个进程只能保存1024个fd，轮询访问<br>​</p><p>​      poll:   和select相同，但是使用数组的形式保存fd，无上限，同样也是轮询访问</p><p><img src="http://imt.rui.vin/202203101426837.png" alt="image-20220310132555292"></p><hr><p>​ epoll： 这个比较重要，详细说下<br>​  再来做个比喻，有个小区，一开始小区里的人寄快递都是叫快递员上门取件，或者是去快递店里寄，前者有点费快递员的人力，后者可以有浪费顾客的时间，后来快递公司想到了一个方法， 在小区里建立了一个无人快递收件柜子（蜂巢），顾客把想寄的东西都放在那个柜子了，快递人员到一定的时间带个大袋子，把要寄送的东西带走，这样就省去快递员挨家挨户的收快递，提高了效率；</p><p>​    小区里的人就是 那些文件io，柜子里的装的东西就是 有事件响应的io，这样就不用挨个去遍历了，每次快递员到了时间点了（timeout）就去拿柜子里的快递。<br>​这样也挺容易理解的，但要是问如何实现的呢，前两种还可理解，遍历fd所以时间复杂度为 O(n) ，而epoll是怎么做到  O(1)呢？</p><p>​以前也被问过：epoll怎么实现的，一般都是说红黑树加双向链表实现的，然后就说不下去了….</p><p>​    epoll 使用就不在多说，现在说个话题 为什么 epoll 时间复杂度可以做到O（1） 呢？</p><p>​    我们一般都会说，底层把有事件发生的io放在一个队列里（此时io可以理解为分配给客户端的一个fd），这个对个队列是一个双向链   表，插入的时间复杂为O（1），</p><p>​没错，在用户态 我们遍历队列的时候，可以保证遍历的每个io都是有事件发生，效率肯定是上去了，那么在内核态，底层是如何把有事 件发生的io放到队列呢？ 怎么放我们已经知道了，现在问题是在那么多io里，怎么马上挑出有事件的io呢？难道也是在内核态全部  遍历一次？我一开始也百思不得其解，查阅很多资料知道，原来在更底层有那么一个机制，当一个io有事件发生会产生一个软终端，然 后我想到了 信号，信号的类型有个是  SIGIO（这里的软中断我也不是很确定是不是io中断)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">sigaction</span>(SIGIO, &amp;sigio_action, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>  当io有什么事件发生时候，会马上调用这个对应的回调函数（信号是的使用机智我们也知道），那这样，我并不需要每个io的去问有没有事件发生，内核就每个io都设置一个回调函数，那么io有事件了，马上调用回调函数，那么就准备把这个io装在队列里面里，而红黑树的作用就是管理这些io并设置其回调函数，就好像这个api</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev);<br></code></pre></td></tr></table></figure><p>把新的io加入到红黑树里面，然后注册一个对应的回调函数，我们都知道红黑树的特性是 增删改查时间复杂度稳定 为 logn，有io退出，  取消对应的回调函数，然后删除这个io</p><p>以上就是当前对epoll底层实现 的初步了解，后续看了源码再来更新</p><p>具体流程如下如下所示  （在知乎看到的）</p><p><img src="http://imt.rui.vin/202203111203054.png" alt="image-20220310135031722"></p><h4 id="3-epoll-和-select-用哪个好"><a href="#3-epoll-和-select-用哪个好" class="headerlink" title="3 .epoll 和  select 用哪个好"></a>3 .epoll 和  select 用哪个好</h4><p>​这也是要结合场景使用，如果 连接数比较少，事件响应比较多的时候用select 性能较好一些。涉及到大并发连接是，任意事件段io并不是很活跃可以使用 epoll</p><hr><h4 id="epoll-是同步还是异步？"><a href="#epoll-是同步还是异步？" class="headerlink" title="epoll 是同步还是异步？"></a>epoll 是同步还是异步？</h4><p>从内核态来看，是异步的，无需一直等待事件的发生，有事件io发生，就把这个io 塞到队列里，这好像也没毛病</p><p>从用户态说：  int nready &#x3D; epoll_wait(epoll_fd, events, EPOLL_SIZE, -1);   如果 nready 返回大于0，说明 events里面有东西，就就去遍历，没有就继续等待，所以说  用户态来说  epoll_wait是同步的</p><p>在知乎看到这样的解释， 对epoll而言 很多操作都放到 内核去做处理，也就是说让操作系统帮我们做一些事情，从 一开始 io阻塞模型 到 io多路复用，随着技术的迭代，在底层操作系统帮我们做的事越来越多了 （ 好像这样说也不是很对，后续再花点时间重新捋一下 五种io模型 ）</p><p><img src="http://imt.rui.vin/202203250002719.png" alt="知乎上截图的"> </p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-动态规划</title>
    <link href="/2022/03/09/LeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2022/03/09/LeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<ul><li><p>自己理解：</p><pre><code class="hljs"> **当前状态是由上一个状态推出来的，那么就会有个动态的过程，就会有一个公式，就是 状态转移公式，对于解题来说，主要的工作 是找到 这个公式，其实也可以说 是找规律（个人理解）**</code></pre></li></ul> <span id="more"></span><h4 id="1-乘积最大子数组"><a href="#1-乘积最大子数组" class="headerlink" title="1. 乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">1. 乘积最大子数组</a></h4><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空<strong>连续子数组</strong>（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。数组中有正负数。</p><p>思路： 有负数就很棘手，数组中若是有两个负数最大值就没那么容易推测了<br>看下dp值有多少中推测的可能性呢？  </p><ol><li>当前的值  </li><li>当前的值 乘以 上一个dp最大值  </li><li>当前的值是负数时候，乘以上一个dp最小的值（负负得正）</li></ol><p>应该还要有一个dp记录最小的值，也许这个最小的值 乘以当前的值  成为正数了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dpmax</span><span class="hljs-params">(len, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">//用来保存dp最大值</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dpmin</span><span class="hljs-params">(len, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">//用来记录dp最小值</span><br>    dpmin[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    dpmax[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> resMax = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-comment">//最大值有三种推测方法</span><br>        <br>        dpmax[i] = <span class="hljs-built_in">max</span>(nums[i],<span class="hljs-built_in">max</span>(dpmax[i<span class="hljs-number">-1</span>]*nums[i],dpmin[i<span class="hljs-number">-1</span>]*nums[i]));<br>        <span class="hljs-comment">//最小值也有三种推测方法</span><br>        dpmin[i] = <span class="hljs-built_in">min</span>(nums[i]*dpmin[i<span class="hljs-number">-1</span>],<span class="hljs-built_in">min</span>(nums[i],dpmax[i<span class="hljs-number">-1</span>]*nums[i]));<br>        <span class="hljs-comment">//都看当前dp值是哪个比较大</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">max</span>(dpmax[i],dpmin[i]);<br>        resMax = <span class="hljs-built_in">max</span>(resMax,res);<br>    &#125;<br>        <span class="hljs-keyword">return</span> resMax;<br>    &#125;<br></code></pre></td></tr></table></figure><p>总结： 当前的转态是由前面转态推出来的，但是这个退的过程有时候是由条件限制的，这个要考虑清楚一些</p><h4 id="2-最大子数组和"><a href="#2-最大子数组和" class="headerlink" title="2. 最大子数组和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">2. 最大子数组和</a></h4><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p>这题和上个题目一样 ，相对于来说更简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> res = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(nums[i],dp[i<span class="hljs-number">-1</span>]+nums[i]);  <span class="hljs-comment">//当前知道dp值可以是上一个dp加上当前nums值或者是当前的nums</span><br>            res = <span class="hljs-built_in">max</span>(dp[i],res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="3-斐波那契数"><a href="#3-斐波那契数" class="headerlink" title="3. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/">3. 斐波那契数</a></h4><p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>$$<br>F(0) &#x3D; 0，F(1) &#x3D; 1<br>F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1<br>$$<br>给定 n ，请计算 F(n) 。</p><p> 用个递归可以推出来，但这个用动态解决<br>思路：    当前状态是由上一个状态推出来的，所以要找出这个转态方程是最为关键的</p><p>当前的数是由上两个数推出来的   所以：  转态方程   dp[i] &#x3D; dp[i - 1] + dp[i - 2]</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">fib</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span>&#123;<br><span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> n;<br><span class="hljs-built_in">int</span> dp[n + <span class="hljs-number">1</span>];<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>&#123;<br>dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-爬楼梯"><a href="#3-爬楼梯" class="headerlink" title="3. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">3. 爬楼梯</a></h4><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>思路：  假如有3阶楼梯 ，如何求呢？</p><ul><li><p>有3阶楼，我从第二阶楼梯上第三节楼梯只有一种方法 – 走一步</p></li><li><p>现在问题转变了 上到第二阶楼梯需要多少步？  如果我知道上第一阶楼梯是不是也可以求出第二阶楼梯了？</p><p>  所以可以推出转态方程 ：</p><p>  dp[i] &#x3D; dp[i - 1] + dp[i - 2]   </p><p>  其实 和 斐波那契数一样</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> n;<br><span class="hljs-type">int</span> dp[n + <span class="hljs-number">1</span>];<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)<br>&#123;<br>dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br>   &#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-回溯</title>
    <link href="/2022/03/08/LeetCode-%E5%9B%9E%E6%BA%AF/"/>
    <url>/2022/03/08/LeetCode-%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<p>​回溯   -》 穷举</p><span id="more"></span><ul><li><p>回溯函数模板返回值以及参数</p></li><li><p>回溯函数终止条件</p></li><li><p>回溯搜索的遍历过程</p>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">backtracking</span>(参数) &#123;<br>    if (终止条件) &#123;<br>        存放结果;<br>        return;<br>    &#125;<br><br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-组合"><a href="#1-组合" class="headerlink" title="1. 组合"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/">1. 组合</a></h4><p>  给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>  你可以按 <strong>任何顺序</strong> 返回答案。</p><p>  思路： 数字中有多少中组合，k为2的话，两个for可以解决，k为为100 就不能这么做了</p><p>  首先 ：</p><ul><li><p>回溯函数的模版是怎样的 </p><p> ​不需要返回值，参数需要 知道哪里开始，哪里结束，截止需要的条件</p></li><li><p>终止条件</p><p>  ​回溯拿到k个数的时候即停止</p></li><li><p>就改题而言过程是要遍历每个数，即一for循环加上回溯函数</p></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;  <span class="hljs-comment">//最终结果保存的地方</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;  <span class="hljs-comment">//每一轮回溯结果保存的地方</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">back</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> index)</span></span>&#123; <span class="hljs-comment">//n 哪里结束，k 截止需要的条件，index 其实的地方</span><br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;    <span class="hljs-comment">//当path 满足 k 个时候就可以保存到 res中</span><br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt;= n ;i++)&#123;   <span class="hljs-comment">// 遍历每个数  每个数都可能做为第一个数</span><br>            path.<span class="hljs-built_in">push_back</span>(i);            <span class="hljs-comment">//保存</span><br>            <span class="hljs-built_in">back</span>(n,k,i+<span class="hljs-number">1</span>);   <span class="hljs-comment">// i+1 意思是下一轮从下一个数开始</span><br>            path.<span class="hljs-built_in">pop_back</span>();              <span class="hljs-comment">//满足条件了，就出栈，腾出空间给下个数</span><br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-built_in">back</span>(n,k,<span class="hljs-number">1</span>); <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-组合总和-III"><a href="#2-组合总和-III" class="headerlink" title="2. 组合总和 III"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/">2. 组合总和 III</a></h4><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p><p>只使用数字1到9<br>每个数字 最多使用一次<br>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><ul><li>和上题差不多，1到9的数字总，k个组合的数之和为n</li></ul><p>还是来三部曲：</p><ul><li><p>回溯函数的参数  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">back</span>(<span class="hljs-type">int</span> target,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> sum) <span class="hljs-comment">//k 为组合个数，target 组合之和，index 起始的地方，sum 记录总和</span><br></code></pre></td></tr></table></figure></li><li><p>终止条件</p><p>  组合个数位k，并且呢 组合之和为 target</p></li><li><p>搜索过程</p><p>  还是遍历，就是遍历计数时 还要记录总和sum</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;  <span class="hljs-comment">//最终结果保存的地方</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;  <span class="hljs-comment">//每一轮回溯结果保存的地方</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">back</span><span class="hljs-params">(<span class="hljs-type">int</span> target,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> sum)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;    <span class="hljs-comment">//当path 满足 k 个时，sum 等于 target</span><br>            <span class="hljs-keyword">if</span>(sum == target)<br>                res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt;= <span class="hljs-number">9</span> ;i++)&#123;   <span class="hljs-comment">// 遍历每个数  每个数都可能做为第一个数</span><br>            path.<span class="hljs-built_in">push_back</span>(i);            <span class="hljs-comment">//保存</span><br>            sum = sum + i;<span class="hljs-comment">//这里计算总和</span><br>            <span class="hljs-built_in">back</span>(target,k,i+<span class="hljs-number">1</span>,sum);  <br>            path.<span class="hljs-built_in">pop_back</span>();              <span class="hljs-comment">//出栈了，总和也要</span><br>            sum = sum -i;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">back</span>(n,k,<span class="hljs-number">1</span>,sum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-堆栈问题</title>
    <link href="/2022/03/07/LeetCode-%E5%A0%86%E6%A0%88%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/07/LeetCode-%E5%A0%86%E6%A0%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="1-有效的括号"><a href="#1-有效的括号" class="headerlink" title="1. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">1. 有效的括号</a></h4><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p> <span id="more"></span><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><p>思路： 频率比较高的，遍历字符，遇到左括号入栈对应右括号，直到 遇到右括号则出栈，出栈的字符是否和当前遍历的右括号相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>  map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">char</span>&gt; m &#123;&#123;<span class="hljs-string">&#x27;)&#x27;</span>,<span class="hljs-string">&#x27;(&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;]&#x27;</span>,<span class="hljs-string">&#x27;[&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;&#125;&#x27;</span>,<span class="hljs-string">&#x27;&#123;&#x27;</span>&#125;&#125;;<br>      stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>      <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s)<br>&#123;<br><span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">count</span>(ch)) <span class="hljs-comment">//判断插入的是不是右括号</span><br>&#123;<br><span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>() || stk.<span class="hljs-built_in">top</span>() != m[ch])  <span class="hljs-comment">//如果是空的 又插入右括号， 或者顶部的括号和插入的不匹配</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>stk.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//如果匹配 出栈</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>stk.<span class="hljs-built_in">push</span>(ch);  <span class="hljs-comment">//入栈左括号</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//如果为空返回1k</span><br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="2-栈模拟队列"><a href="#2-栈模拟队列" class="headerlink" title="2 . 栈模拟队列"></a>2 . 栈模拟队列</h4><p>思路： 可以使用两个栈模拟队列，一个栈用装进入队列的元素，另一个用于出队列</p><p><img src="http://imt.rui.vin/202203071749015.png" alt="image-20220307174940369"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stIn;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stOut;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br><br>    &#125;<br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        stIn.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br><br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）</span><br>        <span class="hljs-keyword">if</span> (stOut.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">// 从stIn导入数据直到stIn为空</span><br>            <span class="hljs-keyword">while</span>(!stIn.<span class="hljs-built_in">empty</span>()) &#123;<br>                stOut.<span class="hljs-built_in">push</span>(stIn.<span class="hljs-built_in">top</span>());<br>                stIn.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> result = stOut.<span class="hljs-built_in">top</span>();<br>        stOut.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 直接使用已有的pop函数</span><br>        stOut.<span class="hljs-built_in">push</span>(res); <span class="hljs-comment">// 因为pop函数弹出了元素res，所以再添加回去</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stIn.<span class="hljs-built_in">empty</span>() &amp;&amp; stOut.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="3-队列模拟栈"><a href="#3-队列模拟栈" class="headerlink" title="3 . 队列模拟栈"></a>3 . 队列模拟栈</h4><p>思路： 一个队列而模拟栈，入栈和入队列一样，但是出的时候是最早进来的那个数，栈则是最后进来那个，每次模拟出栈的时候都应该出去的队列中最后一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyStack</span>() &#123;<br><br>    &#125;<br>    <span class="hljs-comment">/** Push element x onto stack. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        que.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>        size--;<br>        <span class="hljs-comment">// 队列pop元素，只剩下一个的时候则是栈应出的元素，而pop的元素又重新进入队列</span><br>        <span class="hljs-keyword">while</span> (size--) &#123; <span class="hljs-comment">// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部</span><br>            que.<span class="hljs-built_in">push</span>(que.<span class="hljs-built_in">front</span>());<br>            que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> result = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 此时弹出的元素顺序就是栈的顺序了</span><br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/** Get the top element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">back</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns whether the stack is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4-最小栈"><a href="#4-最小栈" class="headerlink" title="4 . 最小栈"></a>4 . 最小栈</h4><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>思路：</p><p>​1.  用一个辅助栈，一保存入栈的数，另一个栈保存每个数（每个栈层对应的最小值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; x_stack;<br>    stack&lt;<span class="hljs-type">int</span>&gt; min_stack;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        min_stack.<span class="hljs-built_in">push</span>(INT_MAX);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        x_stack.<span class="hljs-built_in">push</span>(x);<br>        min_stack.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">min</span>(min_stack.<span class="hljs-built_in">top</span>(), x));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        x_stack.<span class="hljs-built_in">pop</span>();<br>        min_stack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x_stack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min_stack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>​2. 不用辅助栈，每次入栈的值为两个，一个是入栈的值，一个是当前的内的最小值 （思想还是和辅助栈一样）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            st.<span class="hljs-built_in">push</span>(&#123;x, x&#125;);  <span class="hljs-comment">//第一次入栈 ，最小值和本身相同</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            st.<span class="hljs-built_in">push</span>(&#123;x, <span class="hljs-built_in">min</span>(x, st.<span class="hljs-built_in">top</span>().second)&#125;);  <span class="hljs-comment">//待入栈的值， 和 当前的最下值</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        st.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>().first; <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>().second;  <span class="hljs-comment">//最小值是 当前栈顶的第二个值</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; st;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="4-滑动窗口最大值"><a href="#4-滑动窗口最大值" class="headerlink" title="4. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">4. 滑动窗口最大值</a></h4><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p><hr><blockquote><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p></blockquote><p>每次移动窗口，找到窗口中最大的数<br>可以自己设计一个队列，大的数总是在最前面，每次进入入栈的时候，如果入栈的数大于队列最后的数，则该最后的数pop出来，这样一来可以保持队列单调递增</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  deque&lt;<span class="hljs-type">int</span>&gt; que;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>   <span class="hljs-comment">//入队列原则   入列的数若是大于 队列最后一个数则先pop出最后的数在入列 保持单调递增</span><br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; val &gt; que.<span class="hljs-built_in">back</span>()) &#123;<br>      que.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    que.<span class="hljs-built_in">push_back</span>(val);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-comment">//如果队列满足了k个数，出队列的数是否等于队列最前面的数</span><br>    <span class="hljs-keyword">if</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; val == que.<span class="hljs-built_in">front</span>()) &#123;<br>      que.<span class="hljs-built_in">pop_front</span>();<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getfron</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">front</span>(); &#125;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-comment">//把k 个数先入队列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>  i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>      <span class="hljs-built_in">push</span>(nums[i]); <span class="hljs-comment">//用编写好的push入栈</span><br>    &#125;<br>    res.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">front</span>()); <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>     <span class="hljs-comment">// nums[i - k] 看下 k个数之前入队列的数是不是现在队列最起前面的</span><br>     <span class="hljs-comment">//如果是 pop出去，因为如果是的话说明队列元素已经达到</span><br>      <span class="hljs-built_in">pop</span>(nums[i - k]);<br>      <span class="hljs-built_in">push</span>(nums[i]);<br>      res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">getfron</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="5-删除字符串中的所有相邻重复项"><a href="#5-删除字符串中的所有相邻重复项" class="headerlink" title="5. 删除字符串中的所有相邻重复项"></a><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">5. 删除字符串中的所有相邻重复项</a></h4><p>难度简单345收藏分享切换为英文接收动态反馈</p><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>思路： 字符串逐个入栈， 先入一个，入下一个的时候和栈顶的比较，如果相同，说明这两个是相邻且相同的，此时将 栈顶pop出去,遍历完字符后就是最后的结果了，此时还要反转字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string S)</span> </span>&#123;<br>  stack&lt;<span class="hljs-type">char</span>&gt; st;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> s : S) &#123;<br>    <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>() || s != st.<span class="hljs-built_in">top</span>()) &#123;<br>      st.<span class="hljs-built_in">push</span>(s);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// s 与 st.top()相等的情况</span><br>    &#125;<br>  &#125;<br>  string result = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 将栈中元素放到result字符串汇总</span><br>    result += st.<span class="hljs-built_in">top</span>();<br>    st.<span class="hljs-built_in">pop</span>();<br>  &#125;<br>  <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 此时字符串需要反转一下</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-树</title>
    <link href="/2022/03/07/LeetCode-%E6%A0%91/"/>
    <url>/2022/03/07/LeetCode-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h4 id="1-恢复二叉搜索树"><a href="#1-恢复二叉搜索树" class="headerlink" title="1. 恢复二叉搜索树"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/">1. 恢复二叉搜索树</a></h4><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的 <strong>恰好</strong> 两个节点的值被错误地交换。<em>请在不改变其结构的情况下，恢复这棵树</em> 。<br><img src="http://imt.rui.vin/202203181122619.png" alt="image-20220318111605261"> </p><p>思路： 二叉搜索树 中序排序是升序的，中序遍历时 记录前一个节点， 比较当前节点和上个节点，正常的树是当前节点要大于上一节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  TreeNode *t = <span class="hljs-literal">nullptr</span>;<br>  TreeNode *a = <span class="hljs-literal">nullptr</span>;<br>  TreeNode *b = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTree</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root-&gt;left != <span class="hljs-literal">nullptr</span>)<br>      <span class="hljs-built_in">backTree</span>(root-&gt;left);<br>    <span class="hljs-comment">//当前的值要大于上一个  二叉搜索数中序遍历是递增的</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">nullptr</span> &amp;&amp; t-&gt;val &gt; root-&gt;val) &#123;<br>      <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">//保存上一个节点</span><br>        a = t;<br>      &#125;<br>      b = root;  <span class="hljs-comment">//和当前的节点</span><br>    &#125;<br>    t = root;<br>    <span class="hljs-comment">// cout &lt;&lt; root-&gt;val;</span><br>    <span class="hljs-keyword">if</span> (root-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-built_in">backTree</span>(root-&gt;right);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>     <span class="hljs-built_in">backTree</span>(root); <span class="hljs-comment">//按照正常的中序遍历来处理</span><br>     <span class="hljs-built_in">swap</span>(a-&gt;val,b-&gt;val);   <span class="hljs-comment">//两个节点交换</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-树的前中后序-遍历"><a href="#2-树的前中后序-遍历" class="headerlink" title="2 .树的前中后序 遍历"></a>2 .树的前中后序 遍历</h4><p>递归排序： 相对于递归比较简单，总体公式就是</p><ol><li>确定递归的参数，返回值</li><li>递归终止的条件</li><li>递归的逻辑  （前中还是先后）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">//以下是 中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中  </span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>&#125;<br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p> 递归可以的，用迭代一般都可以都可以:<br>    使用一个栈来辅助</p><ul><li>前序遍历：  遍历第一个数进栈，然后出栈，出栈前，先看下他有无左右子树，有的话先进右节点，后进左节点，为什么呢？因为前序是先忘左边遍历的后面才往右边遍历</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; st;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        st.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">//先进栈</span><br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">//不为空</span><br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();                          <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//出栈</span><br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">//保存结果</span><br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);           <span class="hljs-comment">// 右（空节点不入栈）</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);             <span class="hljs-comment">// 左（空节点不入栈）</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>中序遍历： 对于中序，有点特殊，遍历的结果是左右都没有节点的时候才是我们想要的节点，思路还是一样先一直往左走，走一个压栈一个，遇到没有左子节点的时候，看下有无右节点，没有则出栈（左中右），看其右边有无子节点</li></ul><p>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 指针来访问节点，访问到最底层</span><br>                st.<span class="hljs-built_in">push</span>(cur); <span class="hljs-comment">// 将访问的节点放进栈</span><br>                cur = cur-&gt;left;                <span class="hljs-comment">// 左</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);     <span class="hljs-comment">// 中</span><br>                cur = cur-&gt;right;               <span class="hljs-comment">// 右</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>后序遍历： 前序遍历时是 中左右  ，当然我们也可以中右左(改变遍历顺序)，将这个结果倒序排一遍就是后序遍历了…</p><h4 id="3-二叉树的层序遍历"><a href="#3-二叉树的层序遍历" class="headerlink" title="3 .二叉树的层序遍历"></a>3 .<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></h4><p>​给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><pre><code class="hljs"> ![image-20220321120854055](http://imt.rui.vin/202203211218012.png) </code></pre><p>​思路： 会这题可以解决很多树的问题！</p><ul><li>利用队列的性质，第一次进3，出队列，然后3的左右子树依次进队，此时 队列里有9,10，让后重复出一个节点，然后该节点的左右节点分别进入，同理，10 节点也是一样</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>   vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>queue&lt;TreeNode *&gt; que;<br><span class="hljs-keyword">if</span>(root != <span class="hljs-literal">nullptr</span>)<br>    que.<span class="hljs-built_in">push</span>(root);<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>vector&lt;<span class="hljs-type">int</span>&gt; num;<br><span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">//队列不为空则说明 还没遍历完</span><br><span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//这里 记录当前要出队列的元素个数，出的时候也有进入，要先规定好出多少个</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            TreeNode* node = que.<span class="hljs-built_in">front</span>(); <br>            que.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//出一个</span><br>            num.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-comment">//出队列的左右子树入队列</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left); <br>            <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>&#125;<br>res.<span class="hljs-built_in">push_back</span>(num);<br>num.<span class="hljs-built_in">clear</span>();<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>层次遍历可以解决    二叉树的层数也是可以解决，加一个变量记录进入for的次数，而且还可以记录出最小的高度，即节点的左右子节点都为空的时候</li></ul><h4 id="4-从前序与中序遍历序列构造二叉树"><a href="#4-从前序与中序遍历序列构造二叉树" class="headerlink" title="4. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">4. 从前序与中序遍历序列构造二叉树</a></h4><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p><img src="http://imt.rui.vin/202204112356438.png" alt="image-20220411235555155"></p><p>已知前序和中序 推后序，很基础的题，但是用代码 实现就有点困难了，应该是用递归，不知怎么递归，以及边界的 处理</p><p>前序的 每个数都将中序分为两部分，通过中序左右两部分个数 又可以将前序分为两部分 </p><p><img src="http://imt.rui.vin/202204120001854.png" alt="简单的划分">·   </p><p>通过前序的值 可以找到中序的下标索引  然后 在开始划分，<strong>左子树 递归</strong>   和  <strong>右子树 递归</strong></p><p>为了方便通过前序值马上找到中序的下标，可以先用 map来索引</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; nodemap; <span class="hljs-comment">//方便找 中序下标</span><br>    <span class="hljs-comment">//每次递归 的参数包含  前序的起始坐标， 和 中序的起始坐标</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">drawback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder,<span class="hljs-type">int</span> Pleft,<span class="hljs-type">int</span> Pright,<span class="hljs-type">int</span> Ileft,<span class="hljs-type">int</span> Iright)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Pleft &gt; Pright)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> preroot = preorder[Pleft]; <span class="hljs-comment">// 每次去前序的第一个值</span><br>        <span class="hljs-type">int</span> inroot = nodemap[preroot]; <span class="hljs-comment">//通过 map 找到 中序的索引</span><br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preroot);  <span class="hljs-comment">// 当前 前序的值就头结点 </span><br><br>        <span class="hljs-type">int</span> size_left_node = inroot - Ileft;   <span class="hljs-comment">//要划分 前序 的左右部分， 通过中序可以知道前序的左部分多少个数，即可求出前序的分界值</span><br>        <span class="hljs-comment">//左子树</span><br>        root-&gt;left = <span class="hljs-built_in">drawback</span>(preorder,inorder,Pleft+<span class="hljs-number">1</span>,Pleft+size_left_node,Ileft,inroot<span class="hljs-number">-1</span>);<br><span class="hljs-comment">//右子树</span><br>        root-&gt;right = <span class="hljs-built_in">drawback</span>(preorder,inorder,Pleft+size_left_node+<span class="hljs-number">1</span>,Pright,inroot+<span class="hljs-number">1</span>,Iright);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!preorder.<span class="hljs-built_in">size</span>() || !inorder.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.<span class="hljs-built_in">size</span>();i++ )&#123;<br>            nodemap[inorder[i]] = i;<br>        &#125;<br><br>      <span class="hljs-keyword">return</span>  <span class="hljs-built_in">drawback</span>(preorder,inorder,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="5-二叉树中的最大路径和"><a href="#5-二叉树中的最大路径和" class="headerlink" title="5. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">5. 二叉树中的最大路径和</a></h4><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><p><img src="http://imt.rui.vin/202204140058877.png" alt="image-20220414005821681"></p><p>树的问题往往都是 用递归来解决，这次递归麻烦</p><p>如上图，  路径是 15 - 20 - 7  的值最大，不需要打印出路劲节点，只需求最大值，把问题细分下去  对于每一个节点都可以看做是一个根节点</p><p><img src="http://imt.rui.vin/202204140112710.png" alt="image-20220414010238591" style="zoom:33%;" />对于一个小树，有几种可能呢，一种是 路劲都走完有最大值，还有一种是 三个节点中取一个节点作为最大值</p><p><img src="http://imt.rui.vin/202204140112161.png" alt="image-20220414010455332" style="zoom:33%;" />同理，对于根节点为10 的树（他的全部节点 抽象成左右两个节点），同理也是有两种取法</p><p>现在 问题就可以推倒  求一个子树的最大路径值，路劲都是 左中右，中序遍历</p><p>递归的参数是 每个叶子节点</p><p>递归的出口是  叶子结点为空</p><p>递归的逻辑是 左到右</p><p>做一个全局变量，用于取最大值  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> maxsum = INT_MIN;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(TreeNode *root)</span></span>&#123;<br><span class="hljs-comment">//递归出口</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//递归左边子树 ，返回最后一左节点值</span><br>        <span class="hljs-type">int</span> lval = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getMax</span>(root-&gt;left),<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//同上</span><br>        <span class="hljs-type">int</span> rval = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getMax</span>(root-&gt;right),<span class="hljs-number">0</span>);<br>   <span class="hljs-comment">//第一种路径选择  从左到右，逐个走，用全局变量记录 </span><br>        maxsum = <span class="hljs-built_in">max</span>(root-&gt;val + lval + rval,maxsum);<br>   <span class="hljs-comment">//第二种 根节点加上 左右两个节点最大哪个</span><br>        <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">max</span>(lval,rval);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">getMax</span>(root);<br>        <span class="hljs-keyword">return</span> maxsum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-双指针问题</title>
    <link href="/2022/03/06/LeetCode-%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/06/LeetCode-%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-移除元素"><a href="#1-移除元素" class="headerlink" title="1 移除元素"></a>1 移除元素</h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p> <span id="more"></span><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>思路一： </p><p>​找到一个元素删掉，把后面的往前推，复杂度太多 O(n^2)</p><p>思路二：</p><p>​双指针法   ： 也是需要找个每个元素，然后把后一个元素上去，使用快慢指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement1</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> fast;<br>    <span class="hljs-keyword">for</span> (fast = <span class="hljs-number">0</span>; fast &lt; nums.<span class="hljs-built_in">size</span>(); fast++) &#123;  <span class="hljs-comment">//fast 遍历数组</span><br>      <span class="hljs-keyword">if</span> (nums[fast] != val) &#123;    <span class="hljs-comment">//如果 这个值不等于 val  </span><br>        nums[slow++] = nums[fast];  <span class="hljs-comment">// fast 覆盖 slow  ，注意 如果没找到 slow 和 fast是相等的 </span><br>           <span class="hljs-comment">// 如果找到了， 跳过if   slow 没增加， fast+1 ，</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;  <span class="hljs-comment">//最后slow指针指向</span><br>  &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-移除元素-（升序）"><a href="#2-移除元素-（升序）" class="headerlink" title="2 移除元素 （升序）"></a>2 移除元素 （升序）</h3><p>给你一个 <strong>升序排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。</p><p>依然采用双指针的方法，快指针遍历数组全部数据，慢指针停留在下一个不同元素的位置，为快指针覆盖表明位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>   <span class="hljs-keyword">return</span>* <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> fast;<br>  <span class="hljs-keyword">for</span>(fast = <span class="hljs-number">0</span>; fast &lt; nums.<span class="hljs-built_in">size</span>(); fast++) &#123;<br>   <span class="hljs-keyword">if</span> (nums[slow] != nums[fast]) &#123;<br>    nums[++slow] = nums[fast];  <span class="hljs-comment">//如果相等</span><br>   &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> slow+<span class="hljs-number">1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="3-有序数组的平方"><a href="#3-有序数组的平方" class="headerlink" title="3.有序数组的平方"></a>3.有序数组的平方</h3><p>#给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1： 输入：nums &#x3D; [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p><p>示例 2： 输入：nums &#x3D; [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p><p>思路：<strong>很典型 的 双指针解法</strong>，两个指针分别指向首尾，平方后相比较，大的指针不动，小的移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;nums[<span class="hljs-number">0</span>] * nums[<span class="hljs-number">0</span>]&#125;;<br>  &#125;<br>  <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; <br>  <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>  vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-keyword">if</span> (nums[right] * nums[right] &gt;= nums[left] * nums[left]) &#123;  <span class="hljs-comment">//前后数值结果 比较，如果大取出来，移动指针  </span><br>      ret.<span class="hljs-built_in">push_back</span>(nums[right] * nums[right]);<br>      right--;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ret.<span class="hljs-built_in">push_back</span>(nums[left] * nums[left]); <span class="hljs-comment">//同理</span><br>      left++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-替换空格"><a href="#4-替换空格" class="headerlink" title="4.替换空格"></a>4.<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">替换空格</a></h3><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p>思路：找出有多少个空格，然后扩容， 一个指针指向原来的末端，新的指针指向新的末端，将字符移动到最后端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s) &#123;<br>      <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27; &#x27;</span>) count++;<br>    &#125;<br>    <span class="hljs-type">int</span> oldsize = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> s;<br>    s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + count * <span class="hljs-number">2</span>);<br>    <span class="hljs-type">int</span> newsize = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = newsize - <span class="hljs-number">1</span>, j = oldsize - <span class="hljs-number">1</span>; j &lt; i; i--, j--) &#123;<br>      <span class="hljs-keyword">if</span> (s[j] != <span class="hljs-string">&#x27; &#x27;</span>)<br>        <span class="hljs-built_in">swap</span>(s[j], s[i]);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[j] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>        s[i--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        s[i--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>        s[i] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="5-无重复字符的最长子串"><a href="#5-无重复字符的最长子串" class="headerlink" title="5. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">5. 无重复字符的最长子串</a></h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p>思路： 模拟一个滑动窗口，窗口右边界一直向右探索，知道探索的下一个字符，在窗口中已存在，若已存在则左边界收缩，现在问题是如何快速确定字符在窗口中已存在，可以利用 有hash特性的 unorderset ，快速查找字符是否存在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>   unordered_set&lt;<span class="hljs-type">char</span>&gt; win; <span class="hljs-comment">//建立一个集合</span><br>   <span class="hljs-type">int</span> right = <span class="hljs-number">-1</span>;         <span class="hljs-comment">//初始右边界</span><br>   <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>       <span class="hljs-comment">//第一次走到这不用剔除，接下来每一次走到这都说明遇到了相同的字符</span><br>       <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;<br>        win.<span class="hljs-built_in">erase</span>(s[i - <span class="hljs-number">1</span>]); <span class="hljs-comment">//剔除窗口 的值</span><br>    &#125;<br><span class="hljs-comment">// 不断 扩展右边界 先试探下一个是否存在，所以right 初始化为-1</span><br>   <span class="hljs-keyword">while</span> (right + <span class="hljs-number">1</span> &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; !win.<span class="hljs-built_in">count</span>(s[right + <span class="hljs-number">1</span>])) &#123;<br>     win.<span class="hljs-built_in">insert</span>(s[right + <span class="hljs-number">1</span>]);<br>     right++;  <br>   &#125;<br>   <span class="hljs-comment">//通过下标推出长度</span><br>   ans = <span class="hljs-built_in">max</span>(ans, right - i + <span class="hljs-number">1</span>);<br> &#125;<br> <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针 滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux socket 网络编程简单步骤（）</title>
    <link href="/2022/03/05/Linux%20socket%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/03/05/Linux%20socket%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>socket是什么？</p><h3 id="Linux下tcp服务器创建的步骤"><a href="#Linux下tcp服务器创建的步骤" class="headerlink" title="Linux下tcp服务器创建的步骤"></a>Linux下tcp服务器创建的步骤</h3><span id="more"></span><p>对应TCP：</p><ul><li><p>服务端</p><p>  socket()  建立套接字返回一个文件描述符  fd<br>  bind()   将fd 和 服务器信息（五元组）绑定在一起<br>  listen()  设置连接到服务端的最大连接数<br>  accep()  等待客户端 的连接，连接成功返回一个 fd （一个客户端一个fd）<br>  最后就是对这个fd 读写操作了，操作完需要 close(fd)  文件描述符是有限的</p></li><li><p>客户端</p><p>  socket()  建立套接字返回一个文件描述符 fd<br>  connect( )  连接成功返回一个 fd<br>  最后就是对这个fd 读写操作了，操作完需要 close(fd)  文件描述符是有限的</p></li></ul><p>简单的代码实现：</p><p>第一版：  服务器可以收到客户端的数据并有的回应</p><p>带填坑。。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-哈希问题</title>
    <link href="/2022/03/02/LeetCode-%E5%93%88%E5%B8%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/02/LeetCode-%E5%93%88%E5%B8%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>这里先填个坑 ： set  map 容器底层的原理 </p><h4 id="1-有效的字母异位词"><a href="#1-有效的字母异位词" class="headerlink" title="1. 有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/">1. 有效的字母异位词</a></h4><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><ul><li><code>s</code> 和 <code>t</code> 仅包含小写字母</li></ul><p>思路： 统计s中字符出现的次数，然后再统计 t 中字符出现的次数看是否匹配 ，s和 t 仅仅包含小写字母，所以一小写字母作为key值，出现次数作为 value，出现过的value肯定大于0；再次统计t的，t中出现过的字符对value减一，如果两个字符串出现次数样的话，则map中任何一个value都应为0才对；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span> &#123;<br>    <span class="hljs-type">int</span> strmap[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">//这里我用了一个数组来模拟map</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s) &#123;<br>      strmap[ch - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : t) &#123;<br>      strmap[ch - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>    &#125;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">25</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (strmap[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="2-两个数组的交集"><a href="#2-两个数组的交集" class="headerlink" title="2. 两个数组的交集"></a>2.<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/"> 两个数组的交集</a></h4><p>如题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums1, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums2)</span> </span>&#123;<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; num;<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span> (nums1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || nums2.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n:nums1)&#123;<br>      num.<span class="hljs-built_in">insert</span>(n);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n:nums2)&#123;<br>      <span class="hljs-keyword">if</span>(num.<span class="hljs-built_in">find</span>(n) != num.<span class="hljs-built_in">end</span>())&#123;<br>        res.<span class="hljs-built_in">insert</span>(n);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="3-两数之和"><a href="#3-两数之和" class="headerlink" title="3 .两数之和"></a>3 .两数之和</h4><p>  给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>思路： 遍历数组 ，查找 target-nums[i] 值有无在数组中（因为数组元素是唯一的），在数组中查找有无匹配的可以使用map</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>  unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; numsmap;   <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;  <br>    <span class="hljs-keyword">auto</span> iter = numsmap.<span class="hljs-built_in">find</span>(target-nums[i]);   <span class="hljs-comment">//要查找的目标</span><br>    <span class="hljs-keyword">if</span>(iter == numsmap.<span class="hljs-built_in">end</span>())&#123; <span class="hljs-comment">//没有在map中找到</span><br>      numsmap.<span class="hljs-built_in">insert</span>(nums[i],i);  <span class="hljs-comment">//则向map中插入元素</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">return</span> &#123;iter-&gt;second,i&#125;;   <span class="hljs-comment">//找到了 则返回坐标</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-三数之和"><a href="#3-三数之和" class="headerlink" title="3 .三数之和"></a>3 .<a href="https://leetcode-cn.com/problems/3sum/">三数之和</a></h4><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>思路： 排序 +  双指针       三数之和为 0  ，遍历每一个数，从剩下的数找到符合条件的两位数 ， 题目要求需要去重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums) &#123;<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>  <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>   <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">//排序</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">//遍历数组每个元素</span><br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">//因为排序是升序   所以当前数大于0 了，剩下的数也不符合条件了</span><br>      <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;  <span class="hljs-comment">//去重 不是第一元素的时候， 看当前的数和前一个数是相同</span><br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-comment">// 现在已经用了一个数，接下要找到剩下的两位数， 从头和尾各自开始找</span><br>    left = i + <span class="hljs-number">1</span>;   <br>    right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>       <span class="hljs-comment">//找头和尾的数 看大了还是小了，大了尾往左缩，小了往右缩</span><br>      <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//符合条件 则加入res中</span><br>          <br>        res.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);<br>        <span class="hljs-comment">//此时还去重，如果说两个指针缩短了后，下个数还是一样的，那会有重复的结果</span><br>        <span class="hljs-comment">//首尾都需要去重</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) &#123;<br>          right--;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) &#123;<br>          left++;<br>        &#125;<br>        right--;<br>        left++; <br>      &#125;<br>      <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) &#123;<br>        right--;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) &#123;<br>        left++;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-四数之和"><a href="#3-四数之和" class="headerlink" title="3 .四数之和"></a>3 .四数之和</h4>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-链表问题</title>
    <link href="/2022/02/26/LeetCode-%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/26/LeetCode-%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p> <img src="http://imt.rui.vin/202202271318039.png" alt="image-20220227131753050"></p><span id="more"></span><h2 id="1-移除链表元素"><a href="#1-移除链表元素" class="headerlink" title="1.移除链表元素"></a>1.<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">移除链表元素</a></h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><p>  这次删除的是链表，链表删除元素比较方便，但要注意元素边界</p><p>思路： 先提出剔除 链表前部分符合条件元素，找真正的起点<br>            从起点开开始遍历，查看下一个元素是否符合，符合跳过，更改指针方向</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode *<span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode *head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>   <span class="hljs-keyword">while</span> (head-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; head-&gt;val == val) &#123;  <span class="hljs-comment">//看前部分是否符合条件</span><br>     head = head-&gt;next;<br>   &#125;<br>   ListNode *cur = head;  <span class="hljs-comment">//真正的head， 用cur去操作，head是我们要的结果</span><br>   <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span> &amp;&amp; head-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>     <span class="hljs-keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;    <span class="hljs-comment">//如果符合 跳过指向下下个</span><br>       cur-&gt;next = cur-&gt;next-&gt;next;  <br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       cur = cur-&gt;next;   <span class="hljs-comment">//不符合，直接下一个i</span><br>     &#125;<br>  <span class="hljs-keyword">return</span> head;  <span class="hljs-comment">//返回的是head，cur 是用来操作链表的</span><br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="2-反转链表"><a href="#2-反转链表" class="headerlink" title="2. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">2. 反转链表</a></h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表   (经典题目了)</p><p>思路1： 建一个虚拟的头节点，然后遍历链表，改变元素指针指向（指向虚拟节点）</p><p>思路2： 用栈的特性，遍历链表入栈，出栈一个一个链接起来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>ListNode * vhead = <span class="hljs-literal">nullptr</span>;<br>ListNode *cur = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">//遍历链表</span><br>&#123;<br>cur = head;        <span class="hljs-comment">//cur 指向当前元素</span><br>head = head -&gt;next; <span class="hljs-comment">// head 指向下一个元素，为下一次遍历做准备</span><br>cur-&gt;next = vhead; <span class="hljs-comment">// 当前元素指向虚拟节点</span><br>vhead = cur;       <span class="hljs-comment">//更新虚拟节点的位置，保证下次 元素指向的还是头节点</span><br>&#125;<br><span class="hljs-keyword">return</span> vhead;    <span class="hljs-comment">// 遍历结束  最后 执行代码是  vhead = cur; 所以vhead执行最后一个也是反转后第一个</span><br> &#125;<br></code></pre></td></tr></table></figure><h2 id="3-两两交换链表中的节点"><a href="#3-两两交换链表中的节点" class="headerlink" title="3. 两两交换链表中的节点"></a><strong><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">3. 两两交换链表中的节点</a></strong></h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p> 思路： 因为两两交换，所以每次都选两个节点，开始的时候用一个虚拟的节点作为头结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    ListNode *dyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <br>    dyHead-&gt;next = head;<br>    ListNode *cur = dyHead; <span class="hljs-comment">//到了这里  cur和dyhead控制着的相同的节点，并且该节点指向链表头部</span><br>    <span class="hljs-comment">// 下个节点和 下下个节点是否存在</span><br>    <span class="hljs-keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123;  <br>      ListNode *t1 = cur-&gt;next;  <span class="hljs-comment">//下个节点   t1 对应 a </span><br>      ListNode *t2 =cur-&gt;next-&gt;next; <span class="hljs-comment">//下下个节点   t2 对应 b</span><br>      <span class="hljs-comment">//改变节点指向 如下图所示 </span><br>      t1-&gt;next = t2-&gt;next;  <span class="hljs-comment">//3   </span><br>      t2-&gt;next = t1;   <span class="hljs-comment">// 2</span><br>      cur-&gt;next= t2;   <span class="hljs-comment">// 1</span><br>      cur = cur-&gt;next-&gt;next;  <span class="hljs-comment">//为下次交换节点做为准备</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dyHead-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><img src="http://imt.rui.vin/202202281532419.png" alt="image-20220228153050186" style="zoom:67%;" /><h2 id="4-链表相交"><a href="#4-链表相交" class="headerlink" title="4.链表相交 "></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/">4.链表相交 </a></h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="http://imt.rui.vin/202203011232466.png" alt="img"></p><p>思路： A 和 B 都同时走</p><p>​若相交，链表A： a+c, 链表B : b+c<br>​a+c+b+c &#x3D; b+c+a+c 。则会在公共处c起点相遇。<br>​若不相交，a+b &#x3D; b+a 。因此相遇处是NULL      </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>ListNode *fast = headA;<br>ListNode *slow = headB;<br><span class="hljs-keyword">while</span> (fast != slow) &#123;<br>  fast = (fast != <span class="hljs-literal">nullptr</span> ? fast-&gt;next : headB);<br>  slow = (slow != <span class="hljs-literal">nullptr</span> ? slow-&gt;next : headA);<br>&#125;<br><span class="hljs-keyword">return</span> fast;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-反转链表-II"><a href="#5-反转链表-II" class="headerlink" title="5. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">5. 反转链表 II</a></h2><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p><img src="http://imt.rui.vin/202203261516515.jpeg" alt="img"> </p><p>反转链表升级版</p><p>思路： 遍历链表到到 left的位置 以left 上一个节点为头结点，接下来遍历节点，以头插法的方式插入头结点上（此时问题 又转换到而来 反转链表 I 的问题，不同的是并不是遍历到尾）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function">ListNode *<span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode *head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(head-&gt;next == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> head;<br>    ListNode *vHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>    vHead -&gt;next = head;<br>    ListNode *p  = vHead;<br>    ListNode *q  = vHead-&gt;next;<br> <span class="hljs-comment">//第一次for 循环走到 定位到 left 的位置，p和q</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left<span class="hljs-number">-1</span>; i++) &#123;<br>      p = p-&gt;next;<br>      q = q-&gt;next;<br>    &#125;<br><span class="hljs-comment">//  第二次 for 开始反转需要的节点     </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; right - left; i++) &#123;<br>      <span class="hljs-comment">//保留下一个节点</span><br>      ListNode *temp = q-&gt;next;<br>      <span class="hljs-comment">// 为下一个反转做好准备</span><br>      q-&gt;next = q-&gt;next-&gt;next;<br>     <span class="hljs-comment">//  头插法，查到  p 的后面</span><br>      temp-&gt;next = p-&gt;next;<br>      <span class="hljs-comment">// 更新 p的位置 ，为 p做好准备</span><br>      p-&gt;next = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> vHead-&gt;next;<br>  &#125;<br></code></pre></td></tr></table></figure><p><img src="http://imt.rui.vin/202203261522218.png" alt="image-20220326152225259"> </p><h2 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></h2><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p><img src="C:/Users/hrp/AppData/Roaming/Typora/typora-user-images/image-20220407144530921.png" alt="image-20220407144530921"></p><p>思路： 每k个节点反转， 可以把问题拆分到  每组 k个节点的反转，最后将每组拼接起来，对于反转 一个链表比较容易，这次反转有指定得的范围，k个几点</p><p>​利用递归可以将每组拼接起来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//反转 k个节点的链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head,ListNode* tail)</span> </span>&#123;<br>     ListNode *vhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>     ListNode *v = vhead-&gt;next;<br>     <span class="hljs-keyword">while</span>(head != tail)&#123;<br>        ListNode *t = head-&gt;next;<br>        head-&gt;next = v;<br>        v = head;<br>        head = t; <br>     &#125;<br>     <span class="hljs-keyword">return</span> v;<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        ListNode *node = head;<br>        <span class="hljs-comment">//遍历k个节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; k; i++)&#123;<br>            <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> head;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//  传入首尾节点</span><br>        ListNode *res = <span class="hljs-built_in">reverseList</span>(head,node);<br>        <span class="hljs-comment">//  递归  此时head已经是尾节点</span><br>        head-&gt;next =<span class="hljs-built_in">reverseKGroup</span>(node,k);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-滑动窗口</title>
    <link href="/2022/02/16/Leetcode-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2022/02/16/Leetcode-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="1-给定一个含有-n-个正整数的数组和一个正整数-target-。"><a href="#1-给定一个含有-n-个正整数的数组和一个正整数-target-。" class="headerlink" title="1 .给定一个含有 n 个正整数的数组和一个正整数 target 。"></a>1 .给定一个含有 n 个正整数的数组和一个正整数 target 。</h3><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>最小的 连续子数组 : eg , [1,2,3,4,4]    连续数组   [1,2]   [2,3,4];    但是  [1,4,4] ， 下标连续</p><span id="more"></span><p>还是需要双指针，构成滑动窗口，用这窗口遍历全部数据 ，窗口结合条件是可变的，窗口大小则是我们呢的答案<br>滑动窗口： 窗口起点终点，和控制窗口大小的条件（本题约束窗口大小的条件是 窗口内的值总和应大于target，如果小往右扩大窗口，大了左边缩小窗口）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ret = len;<br>    <span class="hljs-keyword">while</span> (right &lt; len) &#123;<br>      sum = sum + nums[right];<br>      <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;  <span class="hljs-comment">//窗口内的总和符合条件，则左边收缩</span><br>        ret = <span class="hljs-built_in">min</span>(ret, right - left + <span class="hljs-number">1</span>);<br>        sum = sum - nums[left];<br>        left++;<br>      &#125;<br>      right++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret==INT_MAX?<span class="hljs-number">0</span>:ret;<br>  &#125;<br></code></pre></td></tr></table></figure><p>2 . 摘水果问题 （其实套了一层皮：  窗口内只能存在两种数字，窗口最大值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;tree)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 水果编号到数量的映射</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; veg2cnt;<br>    <span class="hljs-type">int</span> n = tree.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 窗口左边界</span><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 窗口右边界</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>      ++veg2cnt[tree[i]];<br>      <span class="hljs-comment">// 一旦发现超过大小，则不断收缩窗口</span><br>      <span class="hljs-keyword">while</span> (veg2cnt.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">int</span> currTree = tree[l];<br>        --veg2cnt[currTree];<br>        <span class="hljs-keyword">if</span> (veg2cnt[currTree] == <span class="hljs-number">0</span>) &#123;<br>          veg2cnt.<span class="hljs-built_in">erase</span>(currTree);<br>        &#125;<br>        ++l;<br>      &#125;<br>      <span class="hljs-comment">// 记录最大的窗口大小</span><br>      res = <span class="hljs-built_in">max</span>(res, i - l + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-有序数组的平方</title>
    <link href="/2022/02/15/LeetCode-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
    <url>/2022/02/15/LeetCode-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="1-有序数组的平方"><a href="#1-有序数组的平方" class="headerlink" title="1.有序数组的平方"></a>1.有序数组的平方</h2><p>#给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1： 输入：nums &#x3D; [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p><p>示例 2： 输入：nums &#x3D; [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p><p>思路：<strong>很典型 的 双指针解法</strong>，两个指针分别指向首尾，平方后相比较，大的指针不动，小的移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;nums[<span class="hljs-number">0</span>] * nums[<span class="hljs-number">0</span>]&#125;;<br>  &#125;<br>  <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; <br>  <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>  vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-keyword">if</span> (nums[right] * nums[right] &gt;= nums[left] * nums[left]) &#123;  <span class="hljs-comment">//前后数值结果 比较，如果大取出来，移动指针  </span><br>      ret.<span class="hljs-built_in">push_back</span>(nums[right] * nums[right]);<br>      right--;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ret.<span class="hljs-built_in">push_back</span>(nums[left] * nums[left]); <span class="hljs-comment">//同理</span><br>      left++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 刷题</title>
    <link href="/2022/02/13/LeetCode%20%E5%88%B7%E9%A2%98/"/>
    <url>/2022/02/13/LeetCode%20%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-刷题"><a href="#LeetCode-刷题" class="headerlink" title="LeetCode 刷题"></a>LeetCode 刷题</h1><p>（以前刷的）</p> <span id="more"></span><h3 id="1-链表反转"><a href="#1-链表反转" class="headerlink" title="1.链表反转"></a>1.链表反转</h3><ul><li>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</li></ul><p>​<strong>示例:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br></code></pre></td></tr></table></figure><p><strong>限制：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">0 &lt;= 节点个数 &lt;= 5000<br></code></pre></td></tr></table></figure><p>解法一  暴力：</p><p>​遍历链表的每个节点，每遍历个节点就用头插法插入一个新的链表里</p><p>​时间复杂度为 T(n^2)   空间复杂度为O(n)</p><p>解法二：  迭代</p><p>​不生成新的链表，把链表的指向的方向反过来</p><p>假设链表为 1 -&gt;2  -&gt; 3 -&gt;∅     1→2→3→∅，我们想要把它改成  ∅←1←2←3。</p><p>在遍历链表时，将当前节点的指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p><p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1621751662409.png" alt="1621751662409"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>    ListNode* cur = head;<br>        <span class="hljs-keyword">while</span> (cur)<br>    &#123;<br>    ListNode* T = cur-&gt;next;<br>            cur-&gt;next =pre;<br>            pre =cur;<br>            cur = T;<br>    &#125;  <span class="hljs-comment">//画图解决</span><br>        <span class="hljs-keyword">return</span> pre;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="2-删除倒数第k个结点"><a href="#2-删除倒数第k个结点" class="headerlink" title="2.删除倒数第k个结点"></a>2.删除倒数第k个结点</h3><p>​ 给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><img src="http://imt.rui.vin/202202151920602.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]<br></code></pre></td></tr></table></figure><p><strong>解法一</strong> ： 遍历整个链表后，算出结点数，反推正序第几个 O(N) N 为链表的长度 ，T（N)</p><p><strong>解法二</strong> ：双指针，一个前指针一个指针，前指针先走n步，然后 后指针和前指针一起走，前指针走到尾后，后指针指向待删除节点的前一部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//设置一个虚拟的前置结点</span><br>pre-&gt;next = head;<br>ListNode* h1 = pre; <span class="hljs-comment">//前指针</span><br>ListNode* h2 = pre; <span class="hljs-comment">//后指针</span><br>        ListNode* temp = <span class="hljs-literal">nullptr</span>; <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n+<span class="hljs-number">1</span>; ++i)<br>h1 = h1-&gt;next;<br><span class="hljs-keyword">while</span> (h1)<br>&#123;<br>h1 = h1-&gt;next;<br>h2 = h2-&gt;next;<br>&#125;<br>    temp = h2-&gt;next;<br>h2-&gt;next = h2-&gt;next-&gt;next;<br>    <span class="hljs-keyword">delete</span> temp;<br>    head = pre-&gt;next;<br>    <span class="hljs-keyword">delete</span> pre;<br><span class="hljs-keyword">return</span> head;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="3-盛最多水的容器（双指针）"><a href="#3-盛最多水的容器（双指针）" class="headerlink" title="3.盛最多水的容器（双指针）"></a>3.<a href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器（双指针）</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br></code></pre></td></tr></table></figure><p><img src="http://imt.rui.vin/202202151920242.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">输入：[1,8,6,2,5,4,8,3,7]<br>输出：49 <br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br></code></pre></td></tr></table></figure><p>解法一：暴力求解</p><p>​遍历每一个容器， 时间复杂度O（n^2)</p><p>解法二：  <strong>双指针</strong> </p><ul><li><p>一个指针在头，一个指针在后，分别向中间靠拢，如何移动呢（移动的条件）？</p></li><li><p>那个指针指向的值比较小就先移动那个.</p></li><li><p>容器的大小<br />min（头，尾） * （头到尾直接的距离）<br />为啥移动小的呢？<br />容器的大小取决于最小的那个板，移动最大的那个板子，容器只会变得最小或者不变（板子可能变大，容器大小不变，板子变小若是比原来较小的那个板子还小，容器则会变得更小）移动较大的那个板子则是可能变大，会不会错过同个长度的其他搭配呢？其实我也没琢磨透…</p></li><li><p>代码</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-comment">//减一是要换成逻辑地址下标</span><br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">while</span> (l&lt;r)<br>&#123;<br><span class="hljs-type">int</span> area = <span class="hljs-built_in">min</span>(height[l], height[r]) * (r - l);<br>ans = <span class="hljs-built_in">max</span>(ans, area);<br><span class="hljs-keyword">if</span> (height[l] &lt; height[r])<br>l++;<br><span class="hljs-keyword">else</span><br>r--;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-冒泡排序"><a href="#4-冒泡排序" class="headerlink" title="4.冒泡排序"></a>4.冒泡排序</h3><p>​今天去面试，笔试要写个冒泡排序，这题应该信手拈来的，可我还推了那么久！！不行啊！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maopao</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i, y;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; x.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> ( y = <span class="hljs-number">0</span>; y &lt; x.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> - i; y++)<br>&#123;<br><span class="hljs-keyword">if</span> (x[y] &gt; x[y + <span class="hljs-number">1</span>])<br>&#123;<br><span class="hljs-built_in">swap</span>(x[y], x[y + <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>时间复杂度为O( n^2）  两遍循环</p><hr><h3 id="5数组中重复的数字"><a href="#5数组中重复的数字" class="headerlink" title="5数组中重复的数字"></a>5数组中重复的数字</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">找出数组中重复的数字。<br><br><br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">示例 1：<br><br>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 <br><br><br></code></pre></td></tr></table></figure><p>解法1 :  用set容器（该容器没有重复的数字），遍历vector ，遍历一个插入一个，插入失败则是重复的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br> <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; nums.<span class="hljs-built_in">size</span>(); x++) <br><span class="hljs-keyword">if</span> (nums[x] == nums[x + <span class="hljs-number">1</span>]) <br><span class="hljs-keyword">return</span> nums[x + <span class="hljs-number">1</span>]; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;; <br></code></pre></td></tr></table></figure><p>解法2： 原地交换，有0- n-1个数字， 每个数都对应一个下标 i，当然 下标 i 不一定等于  nums[i],</p><p>若是等于的话，则有可能一个下标对应很多个数，</p><p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1622255058092.png" alt="1622255058092"></p><p>遍历每一个数，将其数值作为下标，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">nums[nums[i]] = nums[i];<br></code></pre></td></tr></table></figure><p>这样一来就做到  数值就是其索引值</p><p>继续遍历 ，若是发现  交换时   索引值对应的数值已经存在了，则说明有重复的了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">if (nums[nums[i]]== nums[i])<br>return nums[i];<br></code></pre></td></tr></table></figure><p>看代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>      <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i&lt;nums.<span class="hljs-built_in">size</span>())  <span class="hljs-comment">//遍历</span><br>&#123;<br><span class="hljs-keyword">if</span> (nums[i] == i)  <span class="hljs-comment">//判断索引值和当前的值是否对应</span><br>&#123;<br>i++;<span class="hljs-comment">//是，则继续遍历下一个</span><br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (nums[nums[i]] == nums[i])  <span class="hljs-comment">//核心： 判断是否有重复</span><br>               <span class="hljs-comment">//判断当前的值 和以当前值为索引的所对应的值是否相等</span><br><span class="hljs-keyword">return</span> nums[i];<br><span class="hljs-built_in">swap</span>(nums[i], nums[nums[i]]);<span class="hljs-comment">//不相等，则交换</span><br>i++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="6-二叉树的三种遍历"><a href="#6-二叉树的三种遍历" class="headerlink" title="6.二叉树的三种遍历"></a>6.二叉树的三种遍历</h3><h4 id="递归-和迭代的方法"><a href="#递归-和迭代的方法" class="headerlink" title="递归 和迭代的方法"></a><strong>递归</strong> 和迭代的方法</h4><h4 id="前序-（根左右）"><a href="#前序-（根左右）" class="headerlink" title="前序  （根左右）"></a>前序  （根左右）</h4><p>递归：先往左边一直遍历，遍历一个抽一个，，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">forn_tree</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (root = <span class="hljs-literal">NULL</span>)    <span class="hljs-comment">//递归出口 该节点不存在</span><br><span class="hljs-keyword">return</span> ;  <span class="hljs-comment">//遍历每一个元素都是根节点</span><br>res.<span class="hljs-built_in">push_back</span>(root-&gt;val);  <span class="hljs-comment">//遍历每一个元素都是根节点</span><br>forn_tree(root-&gt;left, res);<br>forn_tree(root-&gt;right, res);<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br>forn_tree(root, res);  <span class="hljs-comment">//递归函数</span><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>利用栈来完成递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br>stack&lt;TreeNode*&gt; s;<br><span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() || root)<br>&#123;<br><span class="hljs-keyword">if</span> (root)<br>&#123;<br>res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>s.<span class="hljs-built_in">push</span>(root);<br>root = root-&gt;left;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>root = s.<span class="hljs-built_in">top</span>();<br>s.<span class="hljs-built_in">pop</span>();<br>    root = root-&gt;right;<br>&#125;<br>&#125;<br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="中序-（左根右）"><a href="#中序-（左根右）" class="headerlink" title="中序  （左根右）"></a>中序  （左根右）</h4><p>同上，递归遍历，问题是何时打印出来该节点  总结：跟在哪里就先打印哪里，如中序  根在左右节点中间</p><p>所以， 先遍历左边，一直往左遍历，到最左边的时候打印节点，然后往右遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br><span class="hljs-built_in">inorderTraversal_tree</span>(root, res);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorderTraversal_tree</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br><span class="hljs-keyword">return</span> ;<br><span class="hljs-built_in">inorderTraversal_tree</span>(root-&gt;left, res);<br>res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br><span class="hljs-built_in">inorderTraversal_tree</span>(root-&gt;right, res);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>使用栈来递归：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br>stack&lt;TreeNode*&gt; s;<br><span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() || root)<br>&#123;<br><span class="hljs-keyword">if</span> (root)<br>&#123;<br>s.<span class="hljs-built_in">push</span>(root);<br>root = root-&gt;left;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>root = s.<span class="hljs-built_in">top</span>();<br>s.<span class="hljs-built_in">pop</span>();<br>res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>root = root-&gt;right;<br>&#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="后续-（左右根）"><a href="#后续-（左右根）" class="headerlink" title="后续 （左右根）"></a>后续 （左右根）</h4><p>原理同上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br><span class="hljs-built_in">inorderTraversal_tree</span>(root, res);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorderTraversal_tree</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br><span class="hljs-keyword">return</span> ;<br><span class="hljs-built_in">postorderTraversal_tree</span>(root-&gt;left, res);<br><br><span class="hljs-built_in">postorderTraversal_tree</span>(root-&gt;right, res);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用栈来递归：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">vector&lt;int&gt; postorderTraversal(TreeNode* root) <br>&#123;<br>vector&lt;int&gt; res;<br>inorderTraversal_tree(root, res);<br>return res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-合并两个有序链表"><a href="#7-合并两个有序链表" class="headerlink" title="7. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">7. 合并两个有序链表</a></h3><p>将两个升序链表合并为一个新的 <strong>升序</strong>  链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p>思路：</p><p>​两个链表，建立一个新的头结点，每次比较两个链表当x较大小，那个小则头结点指向那个（尾插法），当前节点值小的链表则指向下一个节点，空间复杂度为O（1），没有用到额外的空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本"> class Solution &#123;<br><br>public:<br><br>  ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;<br><br>    ListNode* preHead = new ListNode(-1);<br>    ListNode* prev = preHead;<br>while (l1 != nullptr &amp;&amp; l2 != nullptr) &#123;<br>if (l1-&gt;val &lt; l2-&gt;val) &#123;<br> prev-&gt;next = l1;<br>     l1 = l1-&gt;next;<br>    &#125; else &#123;<br>    prev-&gt;next = l2;<br>    l2 = l2-&gt;next;<br>   &#125;<br>    prev = prev-&gt;next; //尾插法<br>  &#125;<br>   // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可<br>   prev-&gt;next = (l1 == nullptr ? l2 : l1);<br>    return preHead-&gt;next;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="8-合并K个升序链表"><a href="#8-合并K个升序链表" class="headerlink" title="8.合并K个升序链表"></a>8.合并K个升序链表</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本"> 输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br></code></pre></td></tr></table></figure><p>多个链表升序，也才用合并两个链表的思路来，用一个临时链表ans来保存两个链表合并后的结果，然后遍历每一个有序链表</p><p>没有用到额外的空间，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-function">ListNode* <span class="hljs-title">twoLists1</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>ListNode* preHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>ListNode* prev = preHead;<br><span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">nullptr</span> &amp;&amp; l2 != <span class="hljs-literal">nullptr</span>) &#123;<br><span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;<br>prev-&gt;next = l1;<br>l1 = l1-&gt;next;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>prev-&gt;next = l2;<br>l2 = l2-&gt;next;<br>&#125;<br>prev = prev-&gt;next; <span class="hljs-comment">//尾插法</span><br>&#125;<br><span class="hljs-comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span><br>prev-&gt;next = l1 == <span class="hljs-literal">nullptr</span> ? l2 : l1; <span class="hljs-comment">//三则表达式   如果l1为空了，则l2还有</span><br><span class="hljs-keyword">return</span> preHead-&gt;next;<br>&#125;<br><span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>  ListNode *ans = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">int</span> len = lists.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>ans = <span class="hljs-built_in">twoLists1</span>(ans, lists[i]); <span class="hljs-comment">//遍历每一个链表</span><br>&#125;<br><span class="hljs-keyword">return</span> ans;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-有效的括号"><a href="#9-有效的括号" class="headerlink" title="9.有效的括号"></a>9.<a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">给定一个只包括 <span class="hljs-string">&#x27;(&#x27;</span>，<span class="hljs-string">&#x27;)&#x27;</span>，<span class="hljs-string">&#x27;&#123;&#x27;</span>，<span class="hljs-string">&#x27;&#125;&#x27;</span>，<span class="hljs-string">&#x27;[&#x27;</span>，<span class="hljs-string">&#x27;]&#x27;</span> 的字符串 s ，判断字符串是否有效。<br><br>有效字符串需满足：<br><br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br><br></code></pre></td></tr></table></figure><p>思路：</p><p>​利用堆栈的特性（FIFO） ，遍历字符串每一个元素时，逐个入栈，一定是左括号的先入栈</p><p>遍历到右括号则检查栈的顶部是否匹配，匹配则出栈，为了方便建立对应 哈希表 方便判断出 左右括号是否匹配，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <br><span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, z = <span class="hljs-number">0</span>, d = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();   <br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-comment">//括号肯定为偶数</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-comment">//建立无序表 逐一做匹配</span><br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">char</span>&gt; pairs = &#123;<br>    &#123;<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>&#125;,<br>     &#123;<span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>&#125;<br>    &#125;;<br>    stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s) <span class="hljs-comment">//遍历字符串元素</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> (pairs.<span class="hljs-built_in">count</span>(ch))  <span class="hljs-comment">//判断改字符是否为右括号</span><br>      &#123;<br>       <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>() || stk.<span class="hljs-built_in">top</span>() != pairs[ch])  <span class="hljs-comment">//若果栈空了或者栈顶的右括号和刚遍历的左括号不匹配则返回false</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        stk.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//匹配成功则把出栈，把栈顶匹配完成的元素去掉</span><br>      &#125;<br>     <span class="hljs-keyword">else</span> &#123;<br>        stk.<span class="hljs-built_in">push</span>(ch);<span class="hljs-comment">//没有遍历到右括号则出栈</span><br>      &#125;<br>    &#125;  <br>   <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="10-斐波那契数列"><a href="#10-斐波那契数列" class="headerlink" title=" 10. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/"> 10. 斐波那契数列</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：<br><br>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。<br></code></pre></td></tr></table></figure><p>递归的接法：</p><p>​将大问题分解成若干个小问题</p><p>​F(5)&#x3D; F(4)+F(3);</p><p>​F(4)&#x3D;F(3)+F(2)…..</p><p>​以此类推</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>非递归的接法（从下往上，求出每个数 ,时间复杂度 O(n)）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib_1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> now = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> next = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">2</span>; i &lt;= n; ++i)<br>&#123;<br>next = pre + now;   <span class="hljs-comment">//用next 保留两个数相加的和</span><br>pre = now;<span class="hljs-comment">//pre 和 now 变量向前推进</span><br>now = next;<br>&#125; <br><span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以用以下的方法（和上面的思路一样，只是采用了数组的形式，很妙！）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>arr[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>     arr[i &amp; <span class="hljs-number">1</span>] = (arr[<span class="hljs-number">0</span>] + arr[<span class="hljs-number">1</span>]) % (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br>   &#125;<br>   <span class="hljs-keyword">return</span> arr[n &amp; <span class="hljs-number">1</span>];  <span class="hljs-comment">//n &amp;1 的用意是： 定位到数组的小标 ， n&amp;1 的值只能为 0 或 1</span><br> &#125;<br><br><br></code></pre></td></tr></table></figure><p>11.青蛙跳台阶（和斐波那契数列一样）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。<br><br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。<br><br></code></pre></td></tr></table></figure><p>青蛙可以跳一步或者两步  顶一个函数  f（n）  n表示台阶</p><p>​跳第一个台阶的时候，有一种选择 f(1)，跳第二台阶的时候 f(2) ，有两种选择，跳第三个的时候，第二台阶到第三个台阶只有一种选择–跳一个；第一个台阶到第三台阶跳两个，需要考虑的是当前阶梯数 n 和 n -2 和n与n-2之间的的数目  f（n） &#x3D; f（n-1） +f ( n -2 )</p><p>f(3) &#x3D; f(2)+f(1)  这样就是斐波那契数列啦，可以用递归，但重复计算很多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本"> int numWays(int n) &#123;<br>  if(n ==0)<br>   return 1;<br>  else if(n ==1)<br>    return 1;<br>  else if(n ==2)<br>    return 2;<br>  int pre = 1;<br>  int now = 2;<br>  int next = 0;<br>  for (int i =3; i &lt;= n; ++i)<br>  &#123;<br>      next = (pre + now)%(int(1e9+7));  //用next 保留两个数相加的和<br>   pre = now%(int(1e9+7));     //pre 和 now 变量向前推进<br>      now = next%(int(1e9+7));<br>  &#125;    <br>  return next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-二分查找"><a href="#11-二分查找" class="headerlink" title="11.二分查找"></a>11.二分查找</h3><p>二分查找是针对<strong>有序数列</strong> 的，对无序数列是无效的，在有序序列中使用二分查找能大大提高查找效率，通常能将时间按复杂度从       <strong>O(n)降至O(logn)</strong> </p><p>eg:</p><p>在一个有序数组中查找某个元素的位置</p><ul><li>递归</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_gui</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> right = r;<br><span class="hljs-type">int</span> left = l;<br><span class="hljs-type">int</span> mid  = left + (right - left) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (right &lt; left)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br><span class="hljs-built_in">se_gui</span>(nums, target,mid + <span class="hljs-number">1</span>,r);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br><span class="hljs-built_in">se_gui</span>(nums, target, l, mid- <span class="hljs-number">1</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] == target)<br><span class="hljs-keyword">return</span> mid;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>非递归</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">- <br>int search1(vector&lt;int&gt;&amp; nums, int target) &#123;<br>int len = nums.size() - 1;<br>int left = 0, right = len;<br>int mid;<br>while (left &lt; right)<br>&#123;<br>mid = left + (right - left) / 2;<br>if (nums[mid] &lt; target)<br>left = mid + 1;<br>else if (nums[mid] &gt; target)<br>right = mid - 1;<br>else<br>return mid;<br>&#125;<br>return -1;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>相关题目：</p><p>​在升序的序列中找到指定数字出现的次数</p><h3 id="12-查找两个链表的相同节点（）"><a href="#12-查找两个链表的相同节点（）" class="headerlink" title="12.查找两个链表的相同节点（）"></a>12.查找两个链表的相同节点（）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) &#123;<br>ListNode* At = headA;<br>ListNode* Bt = headB;<br>while (At!=Bt)<br>&#123;<br>if (At != nullptr)<br>At = At-&gt;next;<br>else<br>        At =headB;<br>        <br>if (Bt == nullptr)<br>Bt = Bt-&gt;next;<br>else<br>Bt = headA;<br>&#125;<br>return Bt;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-排序大总结"><a href="#13-排序大总结" class="headerlink" title="13.排序大总结"></a>13.排序大总结</h3><p>快排（被问了好几次…）</p><p>复杂度是O（nlogn）</p><p>思路是：</p><p>​    每一次的遍历把首元素放到他应该在的位置</p><p>如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">5，1 ，4，3<br></code></pre></td></tr></table></figure><p>​        5 的位置应该是  在四位的，第一轮目标就时要包5 放在第四位，其他的不用管</p><p>其它的数字 经过一轮的排序后，会以选定数字的为轴，大的右边，小的在左边；</p><p>​      以定位好的数字为轴，对左边的数字在重复一次以上的操作，对右边的也是，这就是用到递归了;</p><p>递归的层数越多是时间复杂度也越大，   平均的时间复杂度是 nO(logn)</p><p>n 代表层数，  logn带边每层遍历的次数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">vector&lt;int&gt; sortArray_1(vector&lt;int&gt;&amp; nums) &#123;<br>int high = nums.size() - 1;<br>QSort(nums, 0, high);<br>return nums;<br>&#125;<br>void QSort(vector&lt;int&gt; &amp;nums,int low,int high)<br>&#123;<br>int mid;<br>if (low &lt; high)  <br>&#123;<br>mid = Partition(nums, low, high);<br>QSort(nums, low, mid - 1); //递归左边的<br>QSort(nums, mid + 1,high); //递归右边的<br>&#125;<br>&#125;<br>int Partition(vector&lt;int&gt;&amp; nums,int low,int high)<br>&#123;<br>int r = high;<br>int l = low;<br>int std = nums[l]; //选定需要定位的目标数<br>while (l &lt; r)  //首尾各自开始向中心靠齐<br>&#123;<br>//要从后面开始，判断数字是否大于目标数，知道遇到大于的<br>while (l &lt; r &amp;&amp; nums[r] &gt;= std)  <br>&#123;<br>r--;<br>&#125;<br>//然后交换数字<br>swap(nums[l], nums[r]);<br>//然后在来左边 <br>while (l &lt; r &amp;&amp; nums[l] &lt;= std)<br>&#123;<br>l++;<br>&#125;//同理<br>swap(nums[l], nums[r]);<br>&#125;<br><br>return l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-2n-1个数字，找出一个不对的数字"><a href="#14-2n-1个数字，找出一个不对的数字" class="headerlink" title="14. 2n+1个数字，找出一个不对的数字"></a>14. 2n+1个数字，找出一个不对的数字</h3><h3 id="15-1000瓶药水有一瓶毒药，怎么快速检测出来（可用小白鼠）"><a href="#15-1000瓶药水有一瓶毒药，怎么快速检测出来（可用小白鼠）" class="headerlink" title="15.1000瓶药水有一瓶毒药，怎么快速检测出来（可用小白鼠）"></a>15.1000瓶药水有一瓶毒药，怎么快速检测出来（可用小白鼠）</h3><p>讲一千瓶药水用二进制排序，2的10次方 为1024 故需要10位</p><p>00000 00000    1</p><p>00000 00001    2</p><p>00000 00010    3</p><p>…..</p><p>1111101000    1000</p><p>有10 位，我们用10只老鼠（每个老鼠都有编号 0-9）来检测，    瓶子序号中，第n位为1（n的取值为（0~9）） ，就用给对应编号为 n 的老鼠喝 如：</p><p>00001 00001       第0 位和第5位为1 ，则用调 编号 为 0 和 5的老去和药水</p><p>最后看是那些老鼠死了，死老鼠的序号，对应二进制的第几位，如 编号 二 和 三老鼠死了，  则二进制  为 0110  ，该编号对应的药水的编号，就是有毒的了</p><h3 id="16-接雨水"><a href="#16-接雨水" class="headerlink" title="16.接雨水"></a>16.接雨水</h3><p>给定 <em>n</em>  个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>思路：</p><ul><li>暴力解法<br />判断每个柱子能否装水，得看柱子左右两边的柱子 ，水的高度取决于最短的<br />并且中间的柱子也有高度，所以也要减去当前柱子（即中间的柱子）的高度<br />每一个柱子 装水量为<br />​ s &#x3D;  min（left，right） - mid<br />总结： 遍历每一个柱子，取柱子左边最高的柱子，柱子右边最高的柱子，然后以左右两边最低的为标准来计算</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本"> class Solution &#123;<br>public:<br>  int trap(vector&lt;int&gt;&amp; height) &#123;<br>  int n = height.size();<br>  int ans = 0;<br>  //遍历每一个柱子<br>  for (int i = 1; i &lt; n - 1; i++) &#123;<br>   int l_max = 0, r_max = 0;<br>    // 找右边最高的柱子<br>   for (int j = i; j &lt; n; j++)<br>    r_max = max(r_max, height[j]);<br>    // 找左边最高的柱子<br>    for (int j = i; j &gt;= 0; j--)<br>    l_max = max(l_max, height[j]);<br>    // 如果自己就是最高的话，<br>    // l_max == r_max == height[i]<br>    ans += min(l_max, r_max) - height[i];<br>  &#125;<br>  return ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题合集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_Lab2 内存</title>
    <link href="/2022/02/08/OS_Lab%202%20%E5%86%85%E5%AD%98/"/>
    <url>/2022/02/08/OS_Lab%202%20%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p>在 jos中 BIOS程序先写好了，qemu已启动直接跳到了 0x7c00处 开始执行程序，在设模式下内存布局如图</p><p><img src="http://imt.rui.vin/202202161604341.jpeg" alt="preview"></p><span id="more"></span><p>注意：  在 lab1中 作者已经帮我们手动映射了 4 MB的内存</p><p>所以0XF0100000开始的内存映射到了0x0100000的位置上，物理地址加上0XF0000000就是虚拟地址</p><p><strong>物理地址直接通过MMU模块转换成了虚拟地址！</strong></p><p>到目前为止，内核已经写进了了内存，</p><p>​如图</p><p><img src="http://imt.rui.vin/202202171701110.png" alt="image-20220217161035639"></p><p>将一个已经映射好的页表的地址放在指定的地方，开业分页模式后，cpu会自动查找到这个并且通过MMU模块转换层虚拟地址</p><hr><h1 id="开始-lab2-！"><a href="#开始-lab2-！" class="headerlink" title="开始 lab2 ！"></a>开始 lab2 ！</h1><p>本章主要内容 是内存管理  虚拟内存  -&gt; 映射到物理内存</p><p>目前的内存布局如下 </p><p><img src="http://imt.rui.vin/202202172030021.png" alt="image-20220217203020565"></p><p>在写入完内核后，我们知道j接下来的任务建立页表，  我们要从哪里开始建立页表呢？很明显是在内核之后，而我们不知道内核的具体到小，而内核的大小是不固定的，在那个地址结束呢？在 kernel文件生成时，BSS段我们设置一个变量 end，作为内核结束的标志，所以我们可以在其他文件extend 引用这个变量，就可以知道 内核结束的位置在哪里！</p><p><img src="http://imt.rui.vin/202202171958263.png" alt="image-20220217195848698"></p><hr><h3 id="Exercise-1-完善函数"><a href="#Exercise-1-完善函数" class="headerlink" title="Exercise 1.   完善函数"></a><strong>Exercise 1.</strong>   完善函数</h3><p> In the file <code>kern/pmap.c</code>, you must implement code for the following functions (probably in the order given).</p><blockquote><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl">&gt;<span class="hljs-function"><span class="hljs-title">boot_alloc</span>()</span><br>&gt;<span class="hljs-function"><span class="hljs-title">mem_init</span>() (<span class="hljs-variable">only</span> <span class="hljs-variable">up</span> <span class="hljs-variable">to</span> <span class="hljs-variable">the</span> <span class="hljs-variable">call</span> <span class="hljs-variable">to</span> <span class="hljs-title">check_page_free_list</span>(<span class="hljs-number">1</span>)`)</span><br>&gt;<span class="hljs-function"><span class="hljs-title">page_init</span>()</span><br>&gt;<span class="hljs-function"><span class="hljs-title">page_alloc</span>()</span><br>&gt;<span class="hljs-function"><span class="hljs-title">page_free</span>()</span><br></code></pre></td></tr></table></figure><p><code>check_page_free_list()</code> and <code>check_page_alloc()</code> test your physical page allocator. You should boot JOS and see whether <code>check_page_alloc()</code> reports success. Fix your code so that it passes. You may find it helpful to add your own <code>assert()</code>s to verify that your assumptions are correct.</p></blockquote><p>第一个函数： boot_alloc()<br>最基本的分配内存方式（目前没有malloc，所以我们自己实现一个）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">boot_alloc(<span class="hljs-type">uint32_t</span> n)<br>&#123;<br>   <span class="hljs-type">static</span> <span class="hljs-type">char</span> *nextfree;<span class="hljs-comment">// virtual address of next byte of free memory</span><br>   <span class="hljs-type">char</span> *result;<br>        <span class="hljs-keyword">if</span> (!nextfree) &#123;<br>          <span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> end[];<br>          nextfree = ROUNDUP((<span class="hljs-type">char</span> *)end, PGSIZE);<br>        &#125;<br>        cprintf(<span class="hljs-string">&quot;boot_alloc memory at %x\n&quot;</span>, nextfree);<br>        cprintf(<span class="hljs-string">&quot;Next memory at %x\n&quot;</span>, ROUNDUP((<span class="hljs-type">char</span> *)(nextfree + n), PGSIZE));<br>        <span class="hljs-keyword">if</span> (n != <span class="hljs-number">0</span>) &#123;                                                                                               <br>          <span class="hljs-type">char</span> *next = nextfree;<br>          nextfree = ROUNDUP((<span class="hljs-type">char</span> *)(nextfree + n), PGSIZE);<br>          <span class="hljs-keyword">return</span> next;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>          <span class="hljs-keyword">return</span> nextfree;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了基本的内存分配方式就可以随心分配内存了</p><p>先分配<strong>页目录表</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">kern_pgdir = (<span class="hljs-type">pde_t</span> *)boot_alloc(PGSIZE);<br><span class="hljs-built_in">memset</span>(kern_pgdir, <span class="hljs-number">0</span>, PGSIZE);<br></code></pre></td></tr></table></figure><p>随后我们继续分配<strong>页表</strong></p><p>每个页表项都是个结构体，这个结构体用途是管理内存，这里的每个结构体都管理这个一个4k大小的内存！！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>pages = (<span class="hljs-keyword">struct</span> PageInfo*)boot_alloc(<span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> PageInfo)*npages);  <span class="hljs-comment">//调用boot_alloc()函数找到空闲空间起点，并且大小n= PageInfo结构大小*npages</span><br><span class="hljs-built_in">memset</span>(pages,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> PageInfo)*npages);<br></code></pre></td></tr></table></figure><p><img src="http://imt.rui.vin/202202172123327.png"></p><p><strong>第二个函数page_init()</strong></p><p>初始化页表：</p><p>pages并没有内容<br>按要求来  </p><p>第一个物理页标记为被使用，有几个区间是不可以用的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">size_t</span> i;<br><span class="hljs-type">size_t</span> io_hole_start_page = (<span class="hljs-type">size_t</span>)IOPHYSMEM / PGSIZE;<br><span class="hljs-type">size_t</span> kernel_end_page = PADDR(boot_alloc(<span class="hljs-number">0</span>)) / PGSIZE;  <span class="hljs-comment">//注意boot_alloc()返回虚拟地址</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; npages; i++) &#123;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) <span class="hljs-comment">//如上面要求1</span><br>    &#123;<br>        pages[i].pp_ref = <span class="hljs-number">1</span>;<br>pages[i].pp_link = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &gt;= io_hole_start_page &amp;&amp; i &lt;= kernel_end_page)   <span class="hljs-comment">//这区域内是已经被使用的了</span><br>    &#123;<br>        pages[i].pp_ref = <span class="hljs-number">1</span>;<br>pages[i].pp_link = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>  <span class="hljs-comment">//而这段 才是真正 我么可以操控的内存</span><br>    &#123;<br>pages[i].pp_ref = <span class="hljs-number">0</span>;<br>pages[i].pp_link = page_free_list; <span class="hljs-comment">//  头插法形成一个链表</span><br>page_free_list = &amp;pages[i];<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第三个函数 page_alloc()</strong>   </p><p>  page_init 生成了页表，但是页表项并没有管理空间，  page_alloc 函数可以申请一个空间，并用一个PageInfo来管理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> PageInfo *<br><span class="hljs-title function_">page_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in ///  page_free_list是指向页表项的结构体指针 （链表）</span><br>        <span class="hljs-keyword">if</span> (page_free_list == <span class="hljs-literal">NULL</span>) &#123;   <br>          cprintf(<span class="hljs-string">&quot;out of free memory&quot;</span>);<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">addr</span> =</span> page_free_list;<br>        page_free_list = page_free_list-&gt;pp_link;  <span class="hljs-comment">//需要使用一个页表项 ，防止丢失，指向下一个页表项</span><br>        addr-&gt;pp_link = <span class="hljs-literal">NULL</span>;  <br>        <span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_ZERO) &#123;  <span class="hljs-comment">//看 传入的参数， 如果为 1 ，则申请一个 4k的内存 </span><br>          <span class="hljs-built_in">memset</span>(page2kva(addr), <span class="hljs-number">0</span>, PGSIZE);  <span class="hljs-comment">//</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里说下 page2kva(addr)  这个函数；<br>memset扩充内存，操作的虚拟是虚拟内存 （实际物理地址加 0xf00000）<br>现在 的addr 只是这个页表项的地址，如果直接按这个地址扩展的话肯定是会覆盖其他页表项的，所以呢，我们的根据这个页表项设计出在那分配内存</p><p>page2pa ：    pages是页表项的初始地址   pp-pages 可以得出 是第几个页表项 ； 而 左移则是   乘以4096 ，那么这个结果是 物理页的偏移量，我们可以算出在哪里开始分配内存</p><p>KADDR ： 刚才得出的是物理内存，我们还得把这个转换成虚拟地址 ，这个宏就可以将物理地址转换成虚拟地址</p><p><img src="http://imt.rui.vin/202202182223638.png" alt="image-20220218222302556"></p><hr><h3 id="Exercise-4-完善函数"><a href="#Exercise-4-完善函数" class="headerlink" title="Exercise 4   完善函数"></a><strong>Exercise 4</strong>   完善函数</h3><blockquote><p><strong>Exercise 4.</strong> In the file <code>kern/pmap.c</code>, you must implement code for the following functions.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">pgdir_walk()<br>boot_map_region()<br>page_lookup()<br>page_remove()<br>page_insert()<br></code></pre></td></tr></table></figure><p><code>check_page()</code>, called from <code>mem_init()</code>, tests your page table management routines. You should make sure it reports success before proceeding.</p></blockquote><p>​pgdir_walk(pde_t *pgdir, const void *va, int create)<br>​给一个虚拟地址，页目录表入口，返回该虚拟地址所在的页表项</p><p><img src="http://imt.rui.vin/202202201548004.png" alt="image-20220220154819450"></p><p>大致看完 lab2 ，先回答几个问题</p><p>在 lab1 完成后，此时 OS的布局是怎么的？</p><p>解释下 虚拟内存 ，物理内存， 两者是如何映射的？</p><p>kernel 存放在哪个位值？ （分派内存是以防覆盖） （提示 ： bss）</p><p>内存权限问题</p><p>开启分页模式后，物理地址 默认都会转换为 虚拟地址（ cr3 寄存器 可以设置 ）</p><p><img src="http://imt.rui.vin/202202171647087.png" alt="image-20220217164716439"></p><p><img src="http://imt.rui.vin/202202171647673.png" alt="image-20220217164746773"></p><p><img src="http://imt.rui.vin/202202152318490.png" alt="img"></p><p><img src="http://imt.rui.vin/202202092233782.png" alt="image-20220209223329957"></p><p><img src="http://imt.rui.vin/202202111132647.png" alt="image-20220211105409966"></p><p><img src="http://imt.rui.vin/202202111132406.png" alt="image-20220211113225003"></p><p><img src="http://imt.rui.vin/202202152325037.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_Lab 1 Booting a PC</title>
    <link href="/2022/02/06/OS_Lab%201%20Booting%20a%20PC/"/>
    <url>/2022/02/06/OS_Lab%201%20Booting%20a%20PC/</url>
    
    <content type="html"><![CDATA[<p><img src="http://imt.rui.vin/image-20220206112414457-16441195534711.png" alt="image-20220206112414457"></p> <span id="more"></span><h3 id="step5-是课程导论，介绍该课程的安排以及Unix的使用"><a href="#step5-是课程导论，介绍该课程的安排以及Unix的使用" class="headerlink" title="step5 是课程导论，介绍该课程的安排以及Unix的使用"></a>step5 是课程导论，介绍该课程的安排以及Unix的使用</h3><p>这次作业是  介绍汇编和一些工具的使用</p><p><img src="http://imt.rui.vin/image-20220206113644102-16441195589572.png" alt="image-20220206113644102"></p><p>现在开始：</p><h3 id="Software-Setup"><a href="#Software-Setup" class="headerlink" title="Software Setup"></a>Software Setup</h3><p>先把源码 该章节的源码 clone下来  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://pdos.csail.mit.edu/6.828/2018/jos.git<br></code></pre></td></tr></table></figure><p><img src="http://imt.rui.vin/image-20220206113212423.png" alt="image-20220206113212423"></p><p>这两部分是 clone源码和该怎么用 git交作业的 不必细说</p><p><img src="http://imt.rui.vin/image-20220206113411035.png" alt="image-20220206113411035"></p><h3 id="Part-1-PC-Bootstrap"><a href="#Part-1-PC-Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h3><h4 id="1-Getting-Started-with-x86-assembly"><a href="#1-Getting-Started-with-x86-assembly" class="headerlink" title="1. Getting Started with x86 assembly"></a>1. Getting Started with x86 assembly</h4><p>​这里申明了 该os是采用 <em>AT&amp;T</em> 风格 的汇编（我接触比较多的是 Intel 风格） 这部分是 让我们熟悉汇编语言，接下来的课程 打好基础，（我会另起一章专门写汇编）</p><h4 id="2-Simulating-the-x86"><a href="#2-Simulating-the-x86" class="headerlink" title="2. Simulating the x86"></a>2. Simulating the x86</h4><p>进入目录  make </p><p><img src="http://imt.rui.vin/202202061510375.png" alt="image-20220206145945011"></p><p>可能会有这个报错！ 这是 一个整数是 64位除以 一个数位32位的时候  ，官方说安装 <strong>gcc-multilib</strong><br>但没什么用，我直接把这个函数参数成32位了…先这样再说吧（这个是打印数字的 函数）</p><p><img src="http://imt.rui.vin/202202061509929.png" alt="image-20220206145349817"></p><p>运行 qemu  （关于的qemu的安装，网上有很多）</p><p><img src="http://imt.rui.vin/202202061510571.png" alt="image-20220206150545992"></p><h4 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h4><p>下图是 内存的布局（4gb），早期的内存只有 1Mb，为了兼容以前的所以还是保留下来，这1Mb 接下来我们会使用到！</p><p><img src="http://imt.rui.vin/202202062055555.png" alt="image-20220206205505422"></p><h3 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h3><p>part2 是引导程序  BootLoader 的介绍， 这个是什么呢？</p><p>​电脑启动是时候 会有个<br>​一句话来表达就是  系统运作之前 所运行的程序，当我们按了开机键，首先是 运行这个程序，<strong>现在的大多数电脑 这个程序都 写死在主板里</strong>（GRUB？）。</p><ul><li>这个程序有什么用？</li></ul><ol><li>硬件自检，如显卡 ，声卡那些…</li><li>这个并不是真正的操作系统，所以这个程序的作用是 找到 OS，并把这个OS程序加载到内存中 （OS 也是一个程序！），随后转让控制权。</li></ol><ul><li>这个 BootLoader 程序 cpu怎么找到的呢？<br>  开机的时候，就开是扫描 硬盘，硬盘被划分为512字节的区域，称为扇区，一个硬盘有很多扇区，扫一次 就一个扇区，如果找到了（如何判定？ 如果这个扇区的最后两个字节内容是0x55和0xAA 则就是要找的 ）  将这个 512 字节扇区加载到内存地址为 0x7c00（为什么是这个，这个是有来源的 ，大家可以找下），加载完成后 ，执行 cpu 就跳到 0x7c00 处开始执行程序，</li></ul><h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a><strong>Exercise 3</strong></h4><p>看 os启动的流程 ，gdb调试 ，启动主要有两个文件  boot&#x2F;main.c  和  boot.s </p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff">Exercise 3.   Take a look at the [lab tools guide](https://pdos.csail.mit.edu/6.828/2018/labguide.html), especially the section on GDB commands. Even if you&#x27;re familiar with GDB, this includes some esoteric GDB commands that are useful for OS work.<br><br>Set a breakpoint at address 0x7c00, which is where the boot sector will be loaded. Continue execution until that breakpoint. Trace through the code in `boot/boot.S`, using the source code and the disassembly file `obj/boot/boot.asm` to keep track of where you are. Also use the `x/i` command in GDB to disassemble sequences of instructions in the boot loader, and compare the original boot loader source code with both the disassembly in `obj/boot/boot.asm` and GDB.<br><br>Trace into `bootmain()` in `boot/main.c`, and then into `readsect()`. Identify the exact assembly instructions that correspond to each of the statements in `readsect()`. Trace through the rest of `readsect()` and back out into `bootmain()`, and identify the begin and end of the `for` loop that reads the remaining sectors of the kernel from the disk. Find out what code will run when the loop is finished, set a breakpoint there, and continue to that breakpoint. Then step through the remainder of the boot loader.<br></code></pre></td></tr></table></figure><p>开始gdb调试</p><p>一个窗口运行  make qemu-gdb   （开启了个端口）<br>再开一个窗口运行  make gdb  （运行行了一个gdb脚本，远程调试）</p><p><img src="http://imt.rui.vin/202202071248330.png" alt="image-20220207124829335"></p><p>现在我们开始 打断点  教材里有说说到是 从 0x7c00 开始的，断点设到 0x7c00 ，b -》 break </p><p><img src="http://imt.rui.vin/202202071251934.png" alt="image-20220207125156235"></p><p>c 一直执行知道遇到断点<br>si 意为 执行下一步汇编<br>x&#x2F;N  ADDR   为看这个地址的汇编指令  N为查看几条指令<br>info register ： 查看 寄存器的值 </p><p><img src="http://imt.rui.vin/202202071255688.png" alt="image-20220207125543005"></p><p>按照教材意思 比对 boot反汇编的代码和  gdb调试的代码</p><p>boot返汇编的代码在这，比对了下 objdump 反汇编的出的风格还是 Intel的， 和gdb 调试也差多少 ，从 0x7c00开始一步一看吧</p><p><img src="C:/Users/hrp/AppData/Roaming/Typora/typora-user-images/image-20220207131053481.png" alt="image-20220207131053481"></p><p>boot.o 反汇编的代码  </p><p><img src="http://imt.rui.vin/202202071312659.png" alt="image-20220207131245606"></p><p>当调试到 这一步时  地址为 0x7c2d时候  ，提示现在处于 i386状态（32位下）<br><img src="http://imt.rui.vin/202202071712150.png" alt="image-20220207171214490"></p><p>在反汇编的代码中 也可以看出 7c2d 后有 伪指令 .code32  意为切换到32位模式<br><img src="http://imt.rui.vin/202202071714386.png" alt="image-20220207171406343"></p><p> 关于  elf  得新开一个章节  来描述 </p><p>这里加载从磁盘里加载内核 ，怎么加载呢？结合elf 头 的信息，看要读多少<br><img src="http://imt.rui.vin/202202072048503.png" alt="image-20220207204857874"></p><p>这里是 把内核 读到  内存里并执行<br>首先有个问题是怎么读？  （这里涉及到elf 的内容，elf  详细内容不在该章节细说）<br>elf 头 我们已经从 磁盘中读到内存了，目前只是elf 的头部读到内存了，但是 elf 所包含的程序段 没有读到内存里，所以呢，</p><p><img src="http://imt.rui.vin/202202072222329.png" alt="image-20220207222201306"></p><h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4."></a><strong>Exercise 4.</strong></h4><p>​检查下你的对指针的运用，就是指针运用基础，注意下 不同类型的<strong>指针的步长</strong></p><h4 id="Exercise-5，6"><a href="#Exercise-5，6" class="headerlink" title="Exercise 5，6"></a><strong>Exercise 5，6</strong></h4><p>debug 查看从 boot 加载 kernel 的过程，这些可以对照boot.o 反汇编的文件和  kernel的反汇编文件逐步调试对照，就可以清楚的知道了</p><h3 id="Part-3-The-Kernel"><a href="#Part-3-The-Kernel" class="headerlink" title="Part 3: The Kernel"></a>Part 3: The Kernel</h3><p>这部分开始讲 虚拟内存，开始之前再重新 把前面的内容捋一遍！</p><p>qemu启动，执行 从boot 代码段执行，<br>从内存地址  0x7c00 处开始执行代码<br>关闭中断，开启 A20线， 开起gdt<br>调用  bootmain 函数<br>加载 内核文件 到内存里<br>    首先是  加载 elf头<br>    根据elf 头提供的信息，把elf文件中的 程序段加载到对应的内存中<br>（不是很详细，后续再补充 ）</p><p>​跳到  elf 的入口函数 entry<br><img src="http://imt.rui.vin/202202081115742.png" alt="image-20220208111501673"></p><hr><p>Part3 讲的是虚拟内存 和 物理内存的映射，在这把那些细节 描述的很清楚，给了个结论，让我们去验证下， </p><h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a><strong>Exercise 7</strong></h4><p>验证     物理地址转换虚拟地址</p><p>执行 movl %eax, %cr0  后就开启了 分页  ，可以看到地址不同</p><p><img src="C:/Users/hrp/AppData/Roaming/Typora/typora-user-images/image-20220208112758744.png" alt="image-20220208112758744"></p><p><img src="http://imt.rui.vin/202202081130876.png" alt="image-20220208113037678"></p><p>执行  <code>movl %eax, %cr0</code> 前  0xf0100000 内存都是空的<br><img src="http://imt.rui.vin/202202081138946.png" alt="image-20220208113823730"></p><p>执行后   0x 100000 映射到了 0xf0100000<br><img src="http://imt.rui.vin/202202081138735.png" alt="image-20220208113835668"></p><h4 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h4><p>Read through <code>kern/printf.c</code>, <code>lib/printfmt.c</code>, and <code>kern/console.c</code>, and make sure you understand their relationship. It will become clear in later labs why <code>printfmt.c</code> is located in the separate <code>lib</code> directory.<br>看这些 源码，print 实现也大同小异，相对于  《JamesM’s kernel development tutorials 》 ，我觉的后者 print实现 比较容易理解！可以去参考下</p><p><strong>Exercise 8</strong><br>    print 有个 %o 没实现，就是  数字按照 8进制打印出来 ，下图仿照 %x 输出 写了个，就是换个参数..</p><p><img src="http://imt.rui.vin/202202081331383.png" alt="image-20220208133154527"></p><p>os 最开始的运行时，有打印一个<br><img src="http://imt.rui.vin/202202081334699.png" alt="image-20220208133403998"></p><p>没修过前是 输出 </p><p><img src="http://imt.rui.vin/202202081335987.png" alt="image-20220208133514813"></p><p>添加 %o 输出后   15254 是 8进制，转成 10 进制 6828</p><p><img src="http://imt.rui.vin/202202081336048.png" alt="image-20220208133607963"></p><p>很多细节，先放下，后续再补…</p><h3 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h3><h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a><strong>Exercise 9</strong></h4><p>看 栈的初始地址 在哪里</p><p><img src="http://imt.rui.vin/202202081530984.png" alt="image-20220208153047528"></p><p>从以上 代码可以看到  初始化了esp 和 edp，这函数调用的深入下也可以写很多东西，先挖个坑吧….<br>初始化后  看下两个寄存器的 值<br><img src="http://imt.rui.vin/202202081651635.png" alt="image-20220208165110291"></p><p>可以得出 栈的地址是冲 0xf0110000 开始的</p><p>esp 指向了栈的指针 ， bootstacktop 的定义我们可以看下 （合理  运用 ide ，我是用 vscode全局查的）</p><p><img src="C:/Users/hrp/AppData/Roaming/Typora/typora-user-images/image-20220208165822004.png" alt="image-20220208165822004">  </p><p>可以的出 栈的大小为    8 * 4096  字节  （SPACE申请一片内存空间）…..</p><p>带更新,,,</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS实现-其实</title>
    <link href="/2022/02/05/OS%E5%AE%9E%E7%8E%B0-%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <url>/2022/02/05/OS%E5%AE%9E%E7%8E%B0-%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p><img src="http://imt.rui.vin/image-20220205193221144.png" alt="image-20220205193221144"></p><p>好久前就有所了解这个 mit6.828 ，但只是走马观花 看了下，趁着毕设（无可奈何），高强度把这个拿下！</p><p>毕设选的题目是  内核设计，实现一个内核，开始 看了 很多关于os书籍，主要看的是  操作系统真相还原，开头引人入胜，后面  …举步维艰..   于是转战     《JamesM’s kernel development tutorials》 这个确实比较适合入门, 好像有点开窍，<br>可能有前面的基础，如此再回来 看mit6.868 ，又是不一样的感觉！</p><p>接下来按照 这个来课表  的顺序来 的顺序来   <a href="https://pdos.csail.mit.edu/6.828/2018/schedule.html">课程表</a>  </p><p>总之现在以 官网的教材来一步一步走（当然也要参考网上的）</p><p>教材看了后  我会我我自己的理解 重新表达一遍，当然不是纯粹的翻译，所以可能会有多偏差，也希望大家多多指正！  </p><hr>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go 引用mod后 import报错问题</title>
    <link href="/2022/01/28/import%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/28/import%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>期初 在我的分支 项目一直使用 gopath  后面 pull主分支了之后（多人协作），就无法 import了，主分支使用mod管理包的，由于对 mod不了解，也折腾了好久…</p> <span id="more"></span><h3 id="解决的方案"><a href="#解决的方案" class="headerlink" title="解决的方案 :"></a>解决的方案 :</h3><ol><li><p>清空 gopath 路径</p></li><li><p>在项目目录中  用命令  go mod tidy   （同步 模块代码），但总是获取失败，应该是 服务器在国外，于是切换镜像</p></li><li><p>export GOPROXY&#x3D;<a href="https://mirrors.aliyun.com/goproxy/">https://mirrors.aliyun.com/goproxy/</a></p></li></ol><p><img src="/import%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/image-20220128112531481.png" alt="image-20220128112531481"></p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git使用</title>
    <link href="/2022/01/16/git%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/01/16/git%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>遇到   giithub.com port 443 after 21076 ms: Timed out  无法push代码  </p><p>重置全局代理</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些面试题目（待填坑）</title>
    <link href="/2022/01/16/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/16/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一、C-基础知识面试题总结"><a href="#一、C-基础知识面试题总结" class="headerlink" title="一、C++基础知识面试题总结"></a>一、C++基础知识面试题总结</h2><h3 id="1、多态的实现"><a href="#1、多态的实现" class="headerlink" title="1、多态的实现"></a>1、多态的实现</h3><p>​我自己的理解：<br>​多态即多种状态，主要用途在于经由一个共同的接口来影响类型的封装，接口通常被定义一个抽象的基类中，共享的接口通过虚函数的机制，可以在对象执行的时候根据对象的类型解析出到底是哪个函数实例调用的<br>​动态多态是 通过虚函数实现的<br>​静态多态是 通过函数重载和 函数模板实现</p><p>2、说说C&#x2F;C++的区别<br>     c： 面向过程<br>     c++ : 面向对象  -&gt;  OOP语言  -&gt; 设计模式 </p><pre><code class="hljs"> 动态内存分配上：new malloc</code></pre><p>​扩展名</p><p>3、const关键字</p><p>​</p><p>4、说说malloc&#x2F;free 和 new&#x2F;delete区别</p><p>​new的几种方式</p><p>​ new : 普通的new操作，一旦内存分配失败，直接抛出一个异常，需要用catch来处理这种异常信息。</p><p>​new(nothrow) : 不抛出异常的new操作， 一旦内存分配失败，禁止抛出异常，而是返回一个NULL,可以通过判断指针是不是NULL来处理这种异常。</p><p>​placement new : <strong>直接复用已经分配好内存的指针的new操</strong>作，该操作只是会调用构造函数，将这部分内存重新做初始化操作。</p><p>作者：灰常出色<br>链接：<a href="https://www.jianshu.com/p/9b57e769c3cb">https://www.jianshu.com/p/9b57e769c3cb</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>5、指针和引用的区别</p><p>6、C++中堆和栈的区别</p><p>7、关键字static</p><p>8、在C++程序中调用被C语言修饰的函数，为什么要加extern “C”</p><p>9、如何防止头文件被重复包含</p><p>​用#ifdefine<br>​#end</p><p>10、什么是内存泄漏？什么是野指针？什么是内存越界？如何避免？</p><p>11、描述一下封装、继承、多态</p><p>12、堆栈缓存方式的区别</p><p>13、STL容器有哪些，常用的算法</p><p>14、什么是面向对象</p><p>15、用过的设计模式，简单举几个例子</p><p>16、如何理解智能指针,什么时候改变引用计数</p><p>17、share_ptr与weak_ptr的区别与联系</p><p>18、表述下string的Copy-On-Write技术，写时copy</p><p>19、描述下C++的浅copy，深copy，写时copy和引用计数的copy</p><p>20、C++构造函数是否可以抛出异常</p><p>21、是否在析构函数抛出异常</p><p>22、构造函数中，成员变量一定要通过初始化列表来初始化的</p><p>23、volatile的作用</p><p>24、构造函数和析构函数可以调用虚函数吗</p><p>25、内存对齐的原则</p><p>26、内联函数有什么优点？内联函数和宏定义的区别</p><p>27、数组与指针的区别与联系，函数指针，指针函数，指针数组，数组指针</p><p>28、STL set 和 map都是基于什么实现的</p><ul><li><p>set ：  只有value 没有 key  ，基于红黑树，具有<strong>自动排序的功能</strong>，因此map内部所有的数据，在任何时候，都是有序的</p></li><li><p>unordered_set ： 基于哈希表，数据插入和查找的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存，<strong>无自动排序功能</strong></p></li><li><p>unordered_map:  内部实现了一个哈希表，排列顺序是无序的</p></li><li><p>map：  key 和 value   红黑树</p></li></ul><p>​</p><p>29、常见的内存错误及其对策</p><p>30、三种内存对象的比较</p><p>​堆对象，栈对象以及静态对象</p><p>31、C++内存泄露及检测工具</p><p>32、什么时候要用虚析构函数</p><p>33、#include&lt;a.h&gt; 与#include”a.h”的区别</p><p>34、什么是RTTI (Run-time type identification)</p><p>35、引用作为函数参数有哪些特点</p><p>36、在什么时候需要使用常引用</p><p>37、将引用作为函数返回值类型的格式、好处和需要遵守的规则</p><p>38、结构体和联合体的区别</p><p>39、重载和重写的区别</p><p>40、栈内存与文字常量区</p><p>41、struct和class的区别</p><p>42、如何判断浮点数是否相等，LONG呢</p><p>43、不允许重载的5个运算符</p><p>44、拷贝构造函数在哪几种情况下会被调用</p><p>45、什么时候必须重写拷贝构造函数</p><p>46、静态成员函数存在的意义</p><p>47、流运算符为什么不能通过类的成员函数重载</p><p>48、当一个类中没有任何成员变量和成员函数，这时sizeof(A)的A值是多少，</p><p>49、如果不是零，请解释一下编译器为什么没有让他为零</p><p>50、多态的作用</p><p>51、什么函数不能声明为虚函数</p><ol><li><p>构造函数</p><p> 虚表指针的初始化时在构造函数进行的，而虚函数需要放到虚表中。在调用虚函数前，必须首先知道虚表指针，所以不行</p></li><li><p>普通函数</p><p> 虚函数需要在继承多态下使用才有意义</p></li><li><p>静态函数</p><p> 静态函数可以直接调用不需要指针</p></li><li><p>内联函数</p><p> 内联函数属于静态联编，即是编译阶段就确定调用哪个函数了，虚函数是动态联</p></li><li><p>友元函数</p><p> 有元函数不支持继承</p></li></ol><p>52、系统会自动和关闭的3个标准的文件是</p><p>53、说出字符常量和字符串常量的区别，并使用sizeof 计算有什么不同</p><p>54、Windows消息系统由哪几部分构成</p><p>55、assert()的作用</p><p>56、Windows的消息机制</p><p>57、SendMessage和PostMessage的区别</p><p>58、Dll和lib的区别</p><p>59、多线程如何实现通讯，如何进行同步</p><p>60、stl实现了那些排序算法</p><p>61、一元、二元仿函数的区别和使用背景</p><p>62、智能指针可以放到容器中么</p><p>63、请简述Windows内存管理的方式</p><p>64、strcpy和memcpy使用时的注意事项，strncpy、memncpy的区别</p><p>65、const和static能同时修饰成员函数吗</p><p>66、何时编译器会自动生成默认构造函数</p><p>67、何时编译器会自动生成拷贝构造函数</p><p>68、动态链接库和静态链接库的区别</p><p>69、描述一下函数调用的整个过程</p><p>70、C++ STL vector的实现机制</p><p>71、面向对象是一种思想，如何使用C语言来实现</p><p>72、C++有哪些数据类型，为什么long和int都是4字节</p><p>73、Java和C++的区别是什么，分别用在什么场景比较好</p><p>74、函数调用类型_cedecl,_stdcall,_fastcall</p><p>75、什么是序列化和反序列化</p><p>76、用预处理指令声美一个常数，用以表明1年终有多少秒</p><p>77、strtok函数在使用上要注意什么问题</p><p>78、char * const p ,char const * p,  char const * const p区别</p><p>79、介绍一下右值引用和移动语义和完美转发</p><p>80、说说你使用的C++11的特性</p><p>81、如何区分左值和右值</p><p>82、为什么C++访问虚函数比访问普通函数慢</p><p>83、为什么需要纯虚函数</p><p><del>84、内联函数、构造函数、静态成员函数可以是虚函数么</del></p><p>85、析构函数可以调用虚函数，构造函数为什么不可以调用虚函数</p><p>86、析构函数可以是纯虚的么</p><p>87、为什么需要虚继承，虚继承的实现原理</p><p>88、迭代器和普通自指针有什么区别</p><p>89、C++4种类型转换</p><p>90、如何定义一个只能在堆上创建的类，如何定义一个只能在栈上创建的类</p><p>91、标准库函数和系统调用的区别</p><p>92、如何区分一段代码是C++还是C代码编写的</p><p>93、什么是回调函数，回调函数的使用场景</p><p>94、临时对象在什么时候会产生</p><p>95、说一下C++的返回值优化</p><p>96、protected,public,private在继承中的可见性</p><p>97、C++中为什么用模板类</p><p>98、子类不能继承父类的函数有哪些</p><p>99、虚函数的内存结构，菱形继承的虚函数内存结构</p><p>100、谈谈stl标准库的线程安全性</p><p>101、成员函数里memset(this,0,sizeof(*this))会发生什么</p><p>102、share_ptr的线程安全性</p><p>103、vector资源释放</p><h2 id="二、线程进程面试题总结"><a href="#二、线程进程面试题总结" class="headerlink" title="二、线程进程面试题总结"></a><strong>二、线程进程面试题总结</strong></h2><p>1、程序什么时候应该使用线程，什么时候单线程效率高</p><p>2、惊群现象</p><p>3、C++函数内的静态变量初始化以及线程安全问题</p><p>4、C++线程安全的单例类</p><p>5、多线程环境带有状态的对象的讨论</p><p>6、C++多线程加volatile的错误认识</p><p>7、并行编程中多进程和多线程，什么情况下多进程能解决的多线程无法解决</p><p>8、如何证明一个数据结构是线程安全的</p><p>9、lock-free的实现方式</p><p>10、锁的实现方式</p><p>11、多线程编程的时候，使用无锁结构会不会比有锁结构更加快</p><p>12、linux线程是如何进行切换的</p><p>13、Linux 开发，使用多线程还是用 IO 复用 select&#x2F;epoll</p><p>14、异步，多线程和并行的区别</p><p>15、Linux 下多线程和多进程程序的优缺点，各自适合什么样的业务场景</p><p>16、开发多线程的程序应该注意哪些问题</p><p>17、如何测试线程池的性能</p><p>18、死锁的原因和避免</p><p>19、如何理解互斥锁，条件锁，读写锁以及自旋锁</p><p>20、互斥锁，同步锁，临界区，互斥量，信号量，自旋锁之间联系是什么</p><p>21、pthread_cond_wait 为什么需要传递 mutex 参数</p><p>22、多线程网络编程中如何合理地选择线程数</p><p>23、malloc和free是线程安全的吗，在多线程开发时用这两个函数应该注意什么</p><p>24、僵尸进程和孤儿进程有什么区别、如何处理</p><p>25、Linux系统中 进程 、线程 、时间片的关系</p><p>26、在Linux系统中，对于用户创建的进程(线程)来说，CPU分配时间片的单位是线程还是进程</p><p>27、内核级调度和用户级调度</p><p>28、Linux中进程具有父子层次结构，Windows中没有进程层次，这两种设计各有什么优劣</p><p>29、linux用户级进程跟内核线程（进程）有什么差别</p><p>30、为什么要区分用户态和内核态</p><p>31、从用户空间到内核空间有以下触发手段</p><p>32、进程的内存空间布局</p><p>33、进程间通信（IPC）方式</p><p>34、进程空间和内核空间对内存的管理不同</p><p>35、虚拟内存的作用</p><p>36、虚拟内存的实现</p><p>37、Linux的slab层</p><p>38、fork与vfork区别</p><p>39、exit()与_exit()区别</p><p>40、Linux是如何避免内存碎片的</p><p>41、共享内存的实现原理</p><p>42、银行家算法</p><p>43、linux中断响应机制</p><p>44、如何实现守护进程 </p><p>45、32位系统一个进程最多有多少堆内存</p><p>46、线程安全和不安全的讨论</p><p>47、可重入函数与线程安全的区别与联系</p><p>48、双重检查锁定模式(DCLP)的风险</p><p>49、内存屏障详解</p><p>50、原子操作原理</p><p>51、Linux有内核级线程么</p><p>52、使用线程是如何防止出现大的波峰</p><p>53、操作系统中进程调度策略有哪几种</p><p>54、线程与进程的区别和联系 线程是否具有相同的堆栈 dll是否有独立的堆栈</p><p>55、读者-写者问题</p><p>56、哲学家进餐问题</p><p>57、进程状态的切换图</p><h2 id="三、TCP-x2F-IP网络编程面试题总结"><a href="#三、TCP-x2F-IP网络编程面试题总结" class="headerlink" title="三、TCP&#x2F;IP网络编程面试题总结"></a><strong>三、TCP&#x2F;IP网络编程面试题总结</strong></h2><p>1、网络体系结构</p><p>2、TCP和UDP有什么区别</p><p>3、编写socket套接字的步骤</p><p>4、TCP三次握手和四次挥手，以及各个状态的作用</p><p>5、Http协议和TCP的区别</p><p>6、同步IO和异步IO的区别</p><p>7、什么是IOCP</p><p>8、什么是网络套接字(Socket)?流套接字(SOCK_STREAM)基于什么协议</p><p>9、IP首部、TCP首部、UDP首部、以太网首部</p><p>10、TCP和UDP的应用场景</p><p>11、如何实现可靠的UDP</p><p>12、详细说明TCP状态迁移过程</p><p>13、2MSL是什么状态？作用是什么</p><p>14、三次握手为什么不是两次或者四次</p><p>15、TCP重发机制</p><p>16、说说Nagle算法</p><p>17、TCP拥塞控制</p><p>18、TCP的滑动窗口</p><p>19、域名解析的过程</p><p>20、ARP的机制</p><p>21、RARP的实现</p><p>22、http&#x2F;https 1.0 1.1 2.0的特点和区别</p><p>23、Get&#x2F;post的区别</p><p>24、Http返回状态码</p><p>25、Http协议相关头</p><p>26、浏览器中输入一个URL发生什么，用到那些协议</p><p>27、五种IO模型</p><p>28、select,poll,epoll的区别</p><p>29、UDP中一个包的大小最大能多大</p><p>30、Time_wait,close_wait状态产生的原因，keeplive</p><p>31、列举你所知道的TCP选项</p><p>32、Connect会阻塞检测及防止，socket什么情况下可读 </p><p>33、如果select返回可读，结果只读到0字节，什么情况</p><p>34、socket什么情况下可读</p><p>35、Keepalive是什么东西，如何使用</p><p>36、UDP使用connect的好处</p><p>37、各层对应的网络设备（路由器、交换机、网关、网桥、集线器等），各层对应的协议</p><p>38、数据链路层的CSMA&#x2F;CD协议</p><p>39、IP地址的分类，子网划分</p><p>40、TCP精髓问题：停止等待协议、连续ARQ协议 </p><p>41、HTTP缓存机制（cache-control、Expires之类的一系列请求与相应的报头字段</p><p>42、session和cookied 区别，禁用cookie后怎么办</p><p>43、常用协议的端口</p><p>44、三层交换机和路由器的区别</p><p>45、什么是TCP的自连接，如何解决</p><p>46、单播、多播（组播）和广播的区别</p><p>47、当应用程序调用Send之后怎么判断对方是否成功接收</p><p>48、静态路由和动态路由各自的优缺点</p><p>49、路由器和交换机的不同之处有哪些</p><p>50、为什么有时ping服务器第一包丢失</p><p>51、tcp 阻塞socket send recv需要注意的操作</p><p>52、TCP封包和拆包</p><p>53、怎样理解阻塞非阻塞与同步异步的区别</p><p>54、epoll：EPOLLLT和EPOLLET的区别</p><p>55、epoll事件驱动框架使用注意事项</p><p>56、Linux-socket的close和shutdown区别及应用场景</p><p>57、TCP带外数据</p><p>58、网桥的作用</p><p>59、防火墙的端口防护</p><p>60、有哪些私有保留地址</p><p>61、Ping命令使用的那种报文</p><p>62、两台笔记本电脑连起来后ping不通，你觉得有哪些问题造成的</p><p>63、Vlan的特点</p><p>64、ICMP是属于什么协议，处于那一层</p><p>65、IP组播有什么好处</p><p>66、DNS欺骗的方式</p><p>67、reactor和proactor的区别</p><p>68、两台机器A-B进行TCP通讯，进程崩溃会怎么样进程死锁会怎么样进程或机器过载，反应变慢会怎么样进程死循环，拼命发消息会怎么样机器重启会怎么样机器死机会怎么样机器网卡抽风，丢包严重会怎么样交换机或路由器坏了或过载会怎么样路由器过热重启会怎么样A和B之间的带宽被别的服务占用了会怎么样如何诊断以上这些情况。如果A和B之间有防火墙，还会出哪些情况。</p><p>69、Linux 中每个 TCP 连接最少占用多少内存</p><p>70、TCP 能否发送0字节的数据包</p><p>71、tcp 协议中为什么syn会消耗一个序号</p><p>72、tcp&#x2F;ip数据包在互联网传输过程中，有哪些头会保持不变</p><p>73、linux&#x2F;unix socket编程并发时什么时候用进程（fork），什么时候用线程（池）</p><p>74、如何测量网络发送速度</p><p>75、如果将同一个listening socket加入多个epoll， 是不是一种合理的设计？</p><p>76、Tcp客户端的正确关闭方式</p><p>77、对一个已经关闭了的socket 的Server 调用write操作</p><p>78、怎样实时判断socket链接状态</p><p>79、socket套接字在多线程发送数据时要加锁吗</p><p>80、TCP中已有SO_KEEPALIVE选项，为什么还要在应用层加入心跳包机制</p><p>81、TCP 协议下 socket 有可能丢包吗</p><p>82、如何理解 TCP&#x2F;IP, SPDY, WebSocket 三者之间的关系</p><p>83、为什么每台电脑都要设置子网掩码</p><p>84、为什么以太网无法接收大于1500字节的数据包</p><p>85、OSI七层模型中，每一层的数据包都是谁生成和解包的</p><p>86、为什么网关与主机可以不在同一个网段</p><p>87、NAT和DHCP 的区别是什么</p><p>88、OSI模型中，一个协议应该属于哪一层是以什么为标准划分的</p><p>101、TCP三次握手的过程，seq的变化是一直都是加1吗</p><p>102、使用Linuxepoll模型，水平触发模式；当socket可写时，会不停的触发socket可写的事件，如何处理</p><p><strong>四、Linux操作面试题</strong></p><p>1、与CPU、内存、磁盘相关的命令（top free df fdisk）</p><p>2、与网络相关的命令netstat , tcpdump等</p><p>3、sek，awk,grep三个强大的命名，分别用与格式化修改，统计，和正则查找</p><p>4、ipcs和ipcrm命令</p><p>5、查找当前目录以及字母下以.c结尾的文件，且文件中包含”hello world”的文件的路径</p><p>6、创建定时任务</p><p>7、gdb用法</p><p>8、linux的内存管理机制</p><p>9、&#x2F;proc存在哪里</p><p>10、Linux状态分析：CPU（top）、内存（top和free，注意buffer和cache区别）、磁盘（fdisk和df）、IO（iostat）等</p><p>11、shell脚本</p><p>12、Linux目录结构</p><p>13、linux中断响应机制</p><p>14、linux文件系统结构和启动流程</p><p>15、防火墙iptables</p><p>16、轮询任务调度和抢占式任务调度的区别</p><p>17、查看进程ps ps aux</p><p>18、删除进程kill -9</p><p>19、查看进程树pstree</p><p>20、查看占用端口的进程netstat netstat -anp | grep port</p><p>21、正则表达式grep printf awk</p><p>22、管线指令 ls -al &#x2F;etc | less</p><p>23、sort 进行排序</p><p>24、双向输出重定向</p><p>25、打包压缩</p><p>26、目录的 inode 与 block</p><p>27、实体链接与符号链接</p><p>28、文件系统的组成</p><p>29、文件与目录的基本操作</p><p>30、文件属性以及权限的修改</p><p>31、分区</p><p>32、内核模块的位置在哪里</p><p>33、SMTP, DNS, FTP, DHCP, SSH 和 squid 使用的默认端口号是哪些</p><p>34、Linux中不同的网络绑定模式有哪些</p><p>35、如何检查默认路由以及路由表</p><p>36、在Linux 中什么是平均负载</p><p>37、请描述Linux系统优化的12个步骤</p><p>38、描述Linux下软链接和硬链接的区别</p><p>39、描述Linux下文件删除的原理</p><p>40、给出正确的关机和重启服务器的命令</p><p>41、请简述修改&#x2F;etc&#x2F;sudoers配置文件的注意事项</p><p>42、如果一台办公室内主机无法上网（打不开网站），请给出你的排查步骤</p><p>43、请简述Linux启动过程中几个重要配置文件的执行过程</p><p>44、请输出你知道的20 个LINUX 命令及作用</p><p>45、企业中Linux服务器系统分区标准是什么</p><p>46、某一天突然发现Linux系统文件只读，该怎么办呢？完整操作步骤</p><p>47、某一天误操作，执行了rm-rf* ，会有哪些情况发生？请举例</p><p>48、一般可以使用什么软件远程linux服务器？通过什么上传文件和下载文件</p><p>49、Linux内核引导时，从哪个文件中读取要加载的文件系统</p><p>50、Linux文件系统中每个文件用 i节点 来标识</p><p>51、简述网络文件系统NFS，并说明其作用</p><p>52、简述DNS进行域名解析的过程</p><p>53、简述Linux文件系统通过i节点把文件的逻辑结构和物理结构转换的工作过程</p><p>54、nfs 协议用于实现Unix（&#x2F;linux）主机之间的文件系统共享</p><p>55、欲发送10个分组报文测试与主机abc.tuu.edu.cn的连通性，应使用的命令和参数</p><p>56、进程的运行有两种方式，即独立运行和使用父进程运行</p><p>57、vi编辑器具有两种工作模式命令模式和输入模式</p><p>58、vi的使用</p><p>59、内核分为进程管理系统内存管理系统I&#x2F;O管理系统和文件管理系统等四个子系统</p><p>60、安装Linux系统对硬盘分区时，必须有两种分区类型：文件系统分区和交换分区</p><p><strong>五、数据结构与算法</strong></p><p>1、单链表的逆置</p><p>2、常见排序算法和稳定性，效率分析</p><p>3、静态链接和动态链表的区别</p><p>4、海量数据处理的知识点</p><p>5、AVL树和R-B树的查找，插入，删除的效率,区别  &#x2F;&#x2F;数据结构的内容</p><p>​AVL 是二叉查找查找树的升级版，自带平衡算法，左右子树高度不超过1 ，红黑树就是AVL树，但是红黑树 附带了几条规则</p><p>6、判断一个链表是否存在循环</p><p>7、寻找最大的K个数</p><p>8、统计数组中出现最多的数</p><p>9、字符串匹配</p><p>10、二分查找</p><p>11、实现Strcpy</p><p>12、实现快速排序</p><p>13、建堆，建堆的时间复杂度</p><p>14、HASH策略常见的有哪些</p><p>15、HASH表实现</p><p>16、二叉树结构，二叉查找树的实现</p><p>17、二叉树的六种遍历</p><p>18、二叉树的按层遍历</p><p>19、编写简单的String类</p><p>20、编写strcpy、strcat、strcmp、memcpy、memmove</p><p>21、求二叉树的深度</p><p>22、判断一棵二叉树是否是平衡二叉树</p><p>23、求二叉树第K层节点个数</p><p>24、求二叉树中两个节点的最大距离</p><p>25、判断一棵二叉树是否为完全二叉树</p><p>26、重建二叉树，依据前序遍历结果和中序遍历结果</p><p>27、实现简单的智能指针</p><p>28、实现stl::string的写时copy</p><p>29、什么是大小端模式，编写代码区分大小端</p><p>30、链表的插入删除、单向链表、双向链表</p><p>31、反向打印链表</p><p>32、打印倒数第K个节点</p><p>33、链表是否有环</p><p>34、冒泡、选择、插入、快速、归并、堆排序、希尔、桶</p><p>35、背包问题</p><p>36、深度优先、广度优先、单源最小路径、任意两点最小路径</p><p>37、最大堆、最小堆、堆如何调整</p><p>38、两个有序数组求中位数</p><p>39、最长上升子序列</p><p>40、海量数据排序</p><p>41、链表翻转</p><p>42、最长公共子序列</p><p>43、海量数据topk问题</p><p>44、蓄水池抽样算法</p><p>45、排序算法性能比较，时间复杂度、稳定性、比较</p><p>46、1-100之间所有素数之和</p><p>47、队列的实现</p><p>48、字符串匹配</p><p>49、数组存储超大数</p><p>50、回文字符串</p><p>51、判断两个数组是否有相同的数字</p><p>52、大数据中找中位数</p><p>53、B树、B+树、红黑树、AVL树</p><p>54、单链表排序</p><p>55、查找链表中间节点</p><p>56、删除无头非尾节点</p><p>57、约瑟夫环</p><p>58、如何从100万个数中找出最大的前100个数</p><p>59、找出数组中重复的数字</p><p>60、计算斐波那契数列</p><p>61、滑动窗口的最大值</p><p>62、0~n-1 中缺失的数字</p><p>63、连续子数组的最大和</p><p>64、删除链表中重复的节点</p><p>65、矩阵中的路径</p><p>66、调整数组顺序使奇数位于偶数前面</p><p>67、最长不重复子串</p><p>68、天平不平衡找假币问题</p><p>69、栈的逆序</p><p>70、数组的逆序对</p><p>71、二叉搜索树的第K个节点</p><p>72、树上最远距离</p><p>73、折纸问题</p><p>74、根据前序和中序遍历求后序</p><p>75、完全二叉树判断、平衡二叉树判断、二叉查找树判断</p><p>76、荷兰国旗问题</p><p>77、字符串-全排列问题</p><p>78、无环链表判断相交</p><p>79、用两个栈实现队列</p><p>80、最大连续数列和</p><p>81、矩阵取值问题</p><p>82、最大和子矩阵</p><p>83、最长公共子序列和最长递增子序列</p><p>84、最小编辑代价</p><p>85、动态规划和递归-魔术索引</p><p>86、确定字符串互异</p><p>87、基本字符压缩</p><p>88、空格替换</p><p>89、确定两个字符串乱序同构</p><p>90、A+B问题</p><p>91、尾部的零</p><p>92、第K大元素</p><p>93、有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序，来求出一共有多少种走法。</p><p>94、一个有getMin功能的栈</p><p>95、从上往下打印二叉树的每个节点，同层节点从左到右</p><p>96、最长单词（Lintcode）</p><p>97、单例（Lintcode）</p><p>98、Fizz Buzz问题（LintCode）</p><p>99、二分查找</p><p>100、N皇后问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector扩容</title>
    <link href="/2022/01/16/vector%E6%89%A9%E5%AE%B9/"/>
    <url>/2022/01/16/vector%E6%89%A9%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
