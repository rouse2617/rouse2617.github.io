<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于指针的一些问题</title>
    <link href="/2022/12/11/%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%88%E5%A4%8D%E4%B9%A0%E7%AF%87%EF%BC%89/"/>
    <url>/2022/12/11/%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%88%E5%A4%8D%E4%B9%A0%E7%AF%87%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>zuij</p><p>看到一个改错题（很常见的一道题），一个关于申请内存的函数，即传入一个指针 p，然后分配内存，首地址保存到p，然后返回，由于malloc 是分配到栈的，即使函数消亡了，内存也不会回收，逻辑上没毛病，但实际上这个传入的参数是有问题的，刚好借这个题目复习下指针的一些操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">memory</span><span class="hljs-params">(<span class="hljs-type">int</span> num,<span class="hljs-type">void</span> *p)</span></span>&#123;<br><br>p = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * num);<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">void</span> *p = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-built_in">memory</span>(<span class="hljs-number">1024</span>,p);<br>&#123;<br><span class="hljs-comment">//申请成功后，c</span><br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>osd 心跳（深入理解）</title>
    <link href="/2022/10/11/ceph/osd%20%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%EF%BC%88%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%EF%BC%89/"/>
    <url>/2022/10/11/ceph/osd%20%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%EF%BC%88%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>   在分布式系统中有很多节点，节点数量多了，各种异常就会经常发生，如：宕机、<strong>磁盘损坏</strong>、网络故障等；如果集群的某个节点出现什么故障是难以知道的；还有就是监测各个节点的健康状况，快速定位集群中的异常节点。</p><h3 id="心跳机制是什么"><a href="#心跳机制是什么" class="headerlink" title="心跳机制是什么"></a>心跳机制是什么</h3><p> 通俗解释： 客户端每隔 N秒发送心跳数据包给服务端，正常来说在M秒内，服务端会回复客户端消息，若是 服务端大于M秒内没回复，则客户端会认为是出现心跳超时的异常，客户端会进一步对超时异常做处理。<br>     以上只是一个大概的流程，在发送心跳的前后都需要做很多处理，对于收到的心跳包可能有很多种类型，需要分不同情况处理（后续会说明）；</p><h3 id="在ceph-中-能解决了什么问题"><a href="#在ceph-中-能解决了什么问题" class="headerlink" title="在ceph 中 能解决了什么问题"></a>在ceph 中 能解决了什么问题</h3><ul><li><p>osd之间互相检测健康情况，以便及时发现故障节点进入相应的故障处理流程，此外可以分担mon检测的压力</p></li><li><p>检测到  public和cluster  网络异常</p></li><li><p>发送心跳的前提是自身状态的是正常的，所以自身也会先检测：</p><ul><li><p>内部操作是否超时（内部线程的操作）</p></li><li><p>自身osdmap不与集群的一致</p></li><li><p>自身osd状态 检测</p></li></ul></li></ul><h3 id="osd-和osd-之间心跳"><a href="#osd-和osd-之间心跳" class="headerlink" title="osd 和osd 之间心跳"></a>osd 和osd 之间心跳</h3><img src="http://img.rui.vin/202210122013513.png" alt="image-20221009173539395" style="zoom: 33%;"><h3 id="mon和osd-之间"><a href="#mon和osd-之间" class="headerlink" title="mon和osd 之间"></a>mon和osd 之间</h3><ul><li>osd 会向 mon上报 超时的osd给mon，mon会根据 osd超时的上报数来决策 该超时的osd 状态</li></ul><img src="http://img.rui.vin/202210122013626.png" alt="image-20221012113736642" style="zoom: 33%;"><ul><li>osd  会每隔  osd_mon_heartbeat_interval  时间（30s）向mon获取最新的 epoch（Monitors 、 OSD 和 PG上的每一次状态变更的都会递增epoch数值） ，这个操作在一个定时器内进行</li></ul><p><img src="http://img.rui.vin/202210122013653.png" alt="image-20221012143544894"></p><hr><p><strong>以下是心跳模块实现细节</strong></p><h3 id="osd-是如何选择发送对象"><a href="#osd-是如何选择发送对象" class="headerlink" title="osd 是如何选择发送对象"></a>osd 是如何选择发送对象</h3><p>在ceph 中 ，osd并没有广播式的向集群内所有osd发送心跳，因为这样会有心跳风暴对集群造成比较大的压力；osd每次发送心跳时发送的数量为 osd_heartbeat_min_peers（默认为10），这10个发送对象（peer osd） 并不是直接随机选取，而是有选取的规则，选取的  osd会保存在  heartbeat_peers  中；   以下有三种场景下会触发 刷新  heartbeat_peers  的函数</p><p>触发更新peer osd有两种方式 (本质上是更新标志位)：</p><ul><li>osd 刚启动时</li><li>距离上一次更新peer osd时间超时限定时间</li></ul><p>可以触发的场景：</p><ul><li>定时器内定期触发</li><li>handle_pg  </li><li>handle_map</li></ul><p>选取的规则（原则上尽可能选取到指定数量的osd）：</p><ul><li>在PG副本所在OSD的集合中选取   <strong>[可选]</strong></li><li>选取相邻的osd （eg: 当前osd id为5，则会尝试获取 6或者 4 ）  <strong>[必选]</strong></li><li>基于报错处理的原则： 需要来自至少两个不同的故障域的osd；所以会在指定的故障域下随机找两个osd；**[必选]**</li><li>每次发送的对象数量都有所限定，若是大于指定数量则会从 <strong>[可选]</strong> 集合中剔除掉osd；而太少则会从相邻的osd中再次选取</li></ul><p>问题：heartbeat_peer 会自动清掉吗？什么场景会 reset？</p><ul><li>会自动清楚掉但有条件；为了保证 heartbeat_peer  里面没有 “常驻” osd； 距离上一次更新peer osd时间超过限定时间时，会尝试去清除 heartbeat_peer 中的osd，其条件是在过去的十分钟内都没有对该osd发送过心跳，则这种条件下则会清除；因为10分钟都没更新很有可能这个osd已经down掉了；还有一种情况时 osd 主动shutdown时候，会全部清除掉（释放内存）</li></ul><p>问题：选取 peer osd时为什么要通过好几种方式来选择，直接在集群内随机选osd可以吗？ 会不会出现个别osd 一直没有选到的情况？？</p><ul><li><p>不能直接的随机选；心跳发送并不是广播式的，每次发送的数量是有限定的（避免集群压力过大）；在数量一定的情况下首先需要保证检测结果即准确又要快速</p><ul><li><p>【必要】从所在节点中选osd，这样检测本身节点的一个健康状况 （至少两个，后续发现数量不够会继续获取）</p></li><li><p>【必要】方便mon快速决策，满足报错处理的原则，随机选两个不同的故障域的osd （至多两个）</p></li><li><p>【补充】在PG副本所在OSD的集合中选取 （数量过多则从这里剔除）</p></li></ul></li></ul><h3 id="osd发送心跳实现"><a href="#osd发送心跳实现" class="headerlink" title="osd发送心跳实现"></a>osd发送心跳实现</h3><p>​osd 会单独起一个线程来发送心跳，每隔6s发送一次（官方文档是这么说），但实际操作中是小于6的随机秒数，因为固定数值可能造成网络拥塞；然后遍历 一组osd，逐个发送心跳，发送的时候会先<strong>算好超时期限</strong>并保存起来，方便检测心跳超时；对于发送的内容是一个<strong>MOSDPing</strong>类的实例 ；对于集群内只有一个osd的情况每隔 osd_mon_heartbeat_interval 时间会更新osdmap。</p><img src="http://img.rui.vin/202210122013612.png" alt="image-20221012194234663" style="zoom: 50%;"><ul><li><p><strong>简要描述</strong> ：对于osd之间心跳传输，ceph使用了一个单独的线程来做处理，每隔6s向随机选取的osd发送 PING类型的心跳包；正常情况下osd 会在 <strong>osd_heartbeat_grace</strong> 时间内收到相应osd的 PING_REPLY 类型心跳回复，对于处理osd 的回复ceph 也是注册了message 回调函数专门来处理；若没在指定时间内收到，会将超时回复的osd上报给mon，交给mon来决策该超时osd的状态；</p></li><li><p>实现细节：</p><ul><li><p>发送前的准备</p><ul><li>获取 发送对象（peer osd）</li><li>根据发送对象（osd 的id）找到相应的ping记录，上次更新ping记录的时间和现在相隔超过一个钟（osd_mon_heartbeat_stat_stale 可设置），则需要清空osd的ping记录；</li><li>检测 osd 容量使用情况</li><li>计算并记录出此次心跳  回复的<strong>截止期限</strong>，以及记录发送心跳的时间点 （截止时间必须要，再检测超时的时候有用到）</li></ul></li><li><p>如何发送</p><ul><li>构造并发送PING类型 心跳包</li></ul></li><li><p>特殊处理</p><ul><li>没有发送对象（集群中可以只有一个osd）: 在自身状态正常下（active）每隔 osd_mon_heartbeat_interval时间 向mon 订阅更新osdmap</li></ul></li></ul></li><li><p>问题：  心跳线程中间隔时间发送是怎么实现的？sleep？定时器？需要考虑线程同步问题吗?</p><p>这里是使用了互斥锁和条件变量实现，间隔时间内，线程是休眠状态（此时会释放锁），达到间隔时间后会唤醒线程； 线程执行过程过程中 有heartbeat_lock 进行保护；</p></li><li><p>问题：  心跳间隔时间可以修改吗？ 时间大小对集群的影响是？</p><p>间隔时间可以 由于参数 osd heartbeat interval 设置，默认为6s，但实际上逻辑上实现是基于这个参数生成的随机值，发送的频率的高低会影响集群的性能，对于间隔时间的设置，设置的太短了，有可能会因为当前网络阻塞导致误判；设置的太长，会导致判断“迟缓”，固定的间隔时间也不是是权宜之计，索性就取一定时间内的随机值，一来可以使得发送的频率不会一直都是最高的，；二来随机的发送心跳，对检测结果正确性更有保障；</p></li><li><p>问题：  心跳线程有没有可能被内部 kill掉呢？</p><p>心跳线程的根据一个标志位来判断是否要继续执行，  从代码上看，在osd shutdown的时候会；</p></li></ul><h3 id="osd是如何检测超时的"><a href="#osd是如何检测超时的" class="headerlink" title="osd是如何检测超时的"></a>osd是如何检测超时的</h3><p>概述：  检测心跳回复超时也是在一个<strong>定时器</strong>中，具体操作是遍历 osd已经发送的心跳的对象（peer osd），根据osd 找到当时算好超时期限，并和现在时间做比较，如果小于已经是超时了，代码实现中只会挑出小于当前时间的记录做处理；对于超时的osd会添加到failure_queue里，接下来统一发给mon；</p><h3 id="osd-是何如上报给mon的"><a href="#osd-是何如上报给mon的" class="headerlink" title="osd 是何如上报给mon的"></a>osd 是何如上报给mon的</h3><ul><li><p>触发条件</p><p>上报mon也是在一个定时器里（同检测超时一个定时器），当前osd状态有变更的时候或者间隔时间大于osd_mon_report_interval 时就会触发上报mon</p></li><li><p>实现流程</p><p>遍历超时检测收集到的超时osd，然后构造 <strong>MOSDFailure</strong>类，发送给mon</p></li><li><p>问题 ：failure_queue  和 failure_pending 逻辑是怎么处理的？</p><ul><li><p>failure_queue 里保存了报错的osd，failure_pending 保存的是已经上报mon的osd（防止重复上报）；假如 failure_queue里面有osd.1的report，此时会验证failure_pending 里面有无osd.1 的记录，没有则会上报，并将osd保存到failure_pending中，若是failure_pending 有纪录，则不会上报，这样做可以避免重复上报；</p></li><li><p>failure_queue 是上报一次就清除一个（不管是否上报成功）</p></li></ul></li><li><p>问题： MOSDFailure 有几种类型，mon是怎么处理的？ </p><ul><li>FLAG_ALIVE： 当检测到异常的osd并上报后，后续又发现该异常的osd又正常了，需要重新告知mon，此时就需要FLAG_ALIVE 类型的 MOSDFailure </li><li>FLAG_FAILED： 上报  心跳超时 的异常osd时，默认使用 FLAG_FAILED</li><li>FLAG_IMMEDIATE： 并不是超时引起的异常，mon直接标记为dowm</li></ul></li></ul><h3 id="osd处理-心跳消息"><a href="#osd处理-心跳消息" class="headerlink" title="osd处理 心跳消息"></a>osd处理 心跳消息</h3><p> 其他osd发来的 心跳包</p><ul><li><p>心跳通知（PING）： 其他osd发来的 心跳检测</p><ul><li><p>回复前准备</p><ul><li>检测内部子系统健康（操作超时）</li></ul></li><li><p>构建并发送 PING_REPLY 包</p><ul><li>心跳回复的构造<ul><li>构造 MOSDPing::PING_REPLY 类型的心跳包</li><li>心跳回复包的大小限定，构造的时候可以指定包大小的最小值，没有满足会自动填充，这样做是在保证心跳包完整下，节省空间；</li></ul></li></ul></li><li><p>回复后的操作</p><ul><li><p>保存&#x2F;更新 发送方的epoch（从发来的消息中获取）</p></li><li><p>在自身osd状态为up下，验证当前osd的epoch 和发送方的epoch是否一致（原则是向新的靠拢）</p><ul><li>当前的epoch比发送方的大，会share给发送方</li><li>内部更新发送方的epoch</li></ul></li><li><p>从自身的osdmap中验证发送方的状态</p><ul><li>发送方不存在，会发送 YOU_DIED 类型的心跳包</li></ul></li></ul></li><li><p>问题：  回复心跳包前 检测内部子系统健康目的是什么？有什么设计细节？</p><ul><li><p>对于内部子系统（subsystems）健康机制都是由一个HeartbeatMap 类负责，每个子系统对应一个结构体，这些子系统初始化时将该结构体加入 HeartbeatMap 类中一个链表里以方便后续访问；每个结构体内部会定期更新  grace （容忍时间期限）；当我们需要验证内部子系统健康状态时，只需遍历HeartbeatMap中的 链表用以访问每个子系统，以现在的时间去逐个比较子系统 的grace，若是大于grace 则说明是超时了，此外这个步骤也会顺便验证 子系统的自杀时间，若超时也会杀掉子系统。</p><p>结合代码看，这些结构体 多数是由线程work注册的，work一些操作可能会超时…..</p></li></ul></li><li><p>问题：  心跳回复包的构造有个参数是指定 心跳回复包的最小大小，为什么要设计最小大小呢？</p><ul><li><p>默认值是2000，在处理解包信息时候，不足会自动填充，</p></li><li><p>至于设计的大小….</p></li></ul></li><li><p>问题：  回复才来来验证epoch，以及验证对方状态，这两者先后有什么区别呢？</p><ul><li><p>不管对方状况如何，都应该回复（总之收到了包就应该回复，不管对方是否收到），验证和回复先后顺序无所谓；也不会因为从当前map中发现对方异常而不回复（有可能是自身问题导致map有误？，而实际上对方是正常的）；后续验证主要对epoch 进行简单的同步，自身的epoch 比较大则会发送给对方</p></li><li><p>从自身的osdmap验证对方的存在，不存在则会发送YOU_DIED 类型的心跳包，告知对方已经died（多重验证）</p></li></ul></li><li><p>问题：  有无复现回复丢包的手段（比如发送不成功），以及内部子系统 出现问题无法回复的现象？</p><ul><li><p>模拟丢包率：osd_debug_drop_ping_probability 可以是设定丢包概率，也就是在检测内部子系统健康之前，做一个判断，实际就是跳过回复心跳流程从而实现丢包的场景</p></li><li><p>模拟内部子系统不健康场景： heartbeat_inject_failure 该参数设定是接下来时间内都是不健康的，实际就是验证健康之前会对这数值做比较</p></li></ul></li></ul></li><li><p>心跳回复（<strong>PING_REPLY</strong>）</p><ul><li><p>回复心跳包中带有该心跳发起的时间戳，在本地（osd内存）可以通过该时间戳来找到对应的心跳记录（每一次的心跳收发时间都会在本机有记录）从而更新收到心跳回复的时间（这是判断超时的关键），心跳回复的来源可能来自前端或者后端，更新接收时间前有对来源做区分；正常情况下，前后端的回复都收到后，会统计这次心跳收发的时长，并且也会记录到本地（方面后续统计收发的平均时长）；</p></li><li><p>在做完心跳接收时间的更新，会对当前收到心跳回复做一次超时检验（收到回复的时间和超时期限时间比较），这里只对非超时(正常)的回复做处理： 在检测超时回复的逻辑中，都会将超时的report 保存到一个 map中，我们这里暂且将这个map 称为failure_queue；如果回复是正常的，则会尝试在failure_queue找到以往的超时report（通过回复方的osd id找）并清楚掉；</p><p>为什么这样处理呢？ 给mon上报消息是有时间间隔的，假如osd.1的回复超时了被加入到report中，而在<strong>最新</strong>的心跳中osd.1的回复是正常的，如果此时还没有上报，会从failure_queue清楚掉osd.1的超时记录，这样可以使report更为准确（省资源）；</p></li></ul></li></ul><p>​     </p><ul><li><p>问题： 本地记录的心跳记录会不会重置的？</p><ul><li><p>会，在一个完整的心跳流程(即心跳发送了有回复)结束后，起始到现在的记录都会清除掉，在这个期间的心跳记录不管是否有完成了，都会清楚掉，因为最新的已经完成了，所以不用考虑以往的</p></li><li><p>osd 心跳的之间通信有专门的模块 message 来负责连接通信，当连接出问题时候，会重置message模块，此时会将心跳记录重新清楚掉</p></li></ul></li><li><p>问题： 对于心跳往返平均时间从哪里可以看到？取样的频率可以设定吗？</p><ul><li>amidn socke 提供了相应接口可以查看（ dump_osd_network），对于取样频率通过参数 debug_heartbeat_testing_span 可以调整（这值是采样得间隔时间，默认为0）</li></ul></li><li><p>问题： 为什么需要最后做超时验证呢？  </p><p> 使 failure_queue的存放的failure report更加准确</p></li><li><p>问题： failure_queue  和 failure_pending 区别</p><ul><li><p>failure_queue 里保存了报错的osd，failure_pending 保存的是已经上报mon的osd（防止重复上报）；假如 failure_queue里面有osd.1的report，此时会验证failure_pending 里面有无osd.1 的记录，没有则会上报，并将osd保存到failure_pending中，若是failure_pending 有纪录，则不会上报，这样做可以避免重复上报；</p></li><li><p>failure_queue 是上报一次就清除一个（不管是否上报成功）</p></li></ul></li><li><p>收到消息是 YOU_DIED</p><p>​对方在osdmap 中找不到我，当收到这种类型的信息是需要主动从mon中获取最近osdmap</p></li></ul><h3 id="mon处理-failed-report"><a href="#mon处理-failed-report" class="headerlink" title="mon处理  failed report"></a>mon处理  failed report</h3><ul><li><p>处理 report 分为两步</p><ul><li><p>预处理</p><ul><li>验证report 来源（是谁上报的）</li><li>从 osdmap 中验证目标osd是否已经 dowm</li><li>从 osdmap 中校对 目标osd的IP地址（report 中有包含）</li><li>从 集群osd  up状态来判定，默认up状态的osd 所占集群总osd的比例为 0.3</li></ul></li><li><p>预更新</p><ul><li><p>验证 目标osd状态（期望是 up） 和  地址（通过osdmap中的记录的地址做匹配）</p></li><li><p>通过report 中osd 超时时间，反推出 osd异常的时间点（读去这个 report 的时间减去 osd超时时间，虽然不能很精确的定位到osd异常时间点，但可以保证是在这个时间段），根据这个时间点最终计算出 <strong>超时时间</strong></p><img src="/C:/Users/h00165/AppData/Roaming/Typora/typora-user-images/image-20221024142827258.png" alt="image-20221024142827258" style="zoom: 50%;"></li><li><p>mon 需要两个以上来自不同故障域osd上报，才能判定；如果osd处于同一个故障域，假如说是 rack级，若机柜出问题了则可能导致处于统一给故障域的osd与外界隔离（比如网络问题），此时上报可能会有误，为了校对这种情况，mon决策时会遍历每一条<strong>failure report</strong> ，将来自同一个故障域的当作一个report failure处理，这里故障域粒度可以由 mon_osd_reporter_subtree_level 指定；这种情况也不是百分百准确，还需要校对超时时间</p></li><li><p>对于超时时间也需要进行校对；每个osd down的时间都有记录，遍历 <strong>failure report</strong>时， 根据发送report的osd上一次down和现在的时间差来校对（我认为这样做是 弥补 故障域的误判）</p></li><li><p>问题：  为什么时间超时时间进行 “校对”？</p><p>有一种情况： 当mon通过 failure report 将有问题的osd 置为down之后，过了一会 该osd又正常了（反复这样就不乐观了），可能这个osd并不是真的有问题，可能这个osd就是慢半拍，如果可以稍微缩放一下容忍时间，可能就不会出现这种现象；但又不能单独为这个osd调节整体的容忍时间；为了“缓解”这个问题，通过每一次  osd down 到恢复正常的时间间隔推算出  “laggy” 的概率，通过这个系数来缩放 容忍时间；</p></li></ul></li></ul></li></ul><p>&#x2F;&#x2F; mon -&gt; 方敏</p><hr><h3 id="其他问题汇总："><a href="#其他问题汇总：" class="headerlink" title="其他问题汇总："></a>其他问题汇总：</h3><p>问题： 其他辅助检测方式</p><ul><li><p>osd 周期性的（300s）发送信息给mon保活，需要构建 MOSDBeacon 类并发送给mon，mon会对这类信息做验证（通过osdmap验证），如果发现该osd是异常的，也会尝试 通知改osd自身处于异常状态</p></li><li><p>osd 主动关闭时，会构造  MOSDMarkMeDown  类信息发给mon，mon那边收到后 会验证消息来源后，将改osd置为down</p></li><li><p>osd 周期性检测 osd使用容量状态（FULL，BACKFILLFULL，NEARFULL），并将这个状态发送给mon</p></li><li></li></ul><p>问题： 心跳包中为什么要携带 epoch  </p><p>问</p>]]></content>
    
    
    
    <tags>
      
      <tag>ceph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>osd 心跳</title>
    <link href="/2022/10/01/ceph/osd%20%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/10/01/ceph/osd%20%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="osd-心跳是什么，有什么功能作用"><a href="#osd-心跳是什么，有什么功能作用" class="headerlink" title="osd 心跳是什么，有什么功能作用"></a>osd 心跳是什么，有什么功能作用</h2><h3 id="心跳是什么？"><a href="#心跳是什么？" class="headerlink" title="心跳是什么？"></a>心跳是什么？</h3><p>​  心跳是一种用于故障检测的手段（简单的说就是发个数据包给你，通过有没有回复来判断你的状态）。在分布式系统中有很多节点，节点数量多了，各种异常就会经常发生，如：宕机、<strong>磁盘损坏</strong>、网络故障等，通过心跳这种机制可以快速有效的<strong>定位集群</strong>中的错误节点，并做及时的处理保证集群正常服务。</p><h3 id="osd-心跳"><a href="#osd-心跳" class="headerlink" title="osd 心跳"></a>osd 心跳</h3><ul><li><p><strong>osd是什么？</strong><br>  通俗理解为 主要负责管理ceph集群中磁盘的守护进程</p></li><li><p><strong>osd心跳是什么？有啥功能</strong></p><p>   osd心跳是检测osd故障的一种机制(集群健康工作的基石)， 如果集群中的其中一个osd 突然故障了（假如说是网络隔绝），此时他也没办法发信息给mon，那么此时只有通过其他 osd来上报这个信息，<strong>说我有个邻居挂掉了</strong>，那么osd是怎么确定他邻居osd已经出故障了呢？</p></li></ul><h3 id="osd之间检测"><a href="#osd之间检测" class="headerlink" title="osd之间检测"></a>osd之间检测</h3><ol><li><p>每个 Ceph OSD 守护进程以小于每 6 秒的随机间隔时间检查其他 Ceph OSD 守护进程的心跳<strong>（可以理解为：定期去敲邻居的门）</strong></p><p><img src="http://img.rui.vin/202209190006673.png" alt="image-20220919000635555" style="zoom: 50%;">·</p></li><li><p>如果一个相邻的Ceph OSD Daemon在20秒的宽限期内没有显示心跳，Ceph OSD Daemon可能会认为相邻的Ceph OSD Daemon是 dowm状态的，并将其报告给Ceph Monitor<strong>（可以理解为：敲了那么长时间的门都没来开门,就报警了）</strong></p><img src="http://img.rui.vin/202209190007902.png" alt="image-20220919000758792" style="zoom:50%;"></li><li><p>一个osd 无法和配置文件中的osd  达成 peer 关系，则这个osd 每 30 秒 ping 一次mon 以获取集群的osdmap<br><img src="http://img.rui.vin/202209151612621.png" alt="image-20220915161221587"></p></li><li><p>如果集群只有一个osd，则 osd每隔 一个 <strong>osd_mon_heartbeat_interval</strong>   的时间向  mon 获取新的 osdmap</p></li></ol><h3 id="osd和mon之间"><a href="#osd和mon之间" class="headerlink" title="osd和mon之间"></a>osd和mon之间</h3><p>此外 osd除了有检测osd故障的职责，还需要向mon汇报自身的状况</p><p>触发汇报的情况有以下几种：</p><ul><li><p>OSD有事件发生时（比如故障、PG变更）。</p></li><li><p>osd启动时5秒内</p></li><li><p>OSD周期性的上报 mon （无论是否发现变化 ，默认周期120s）</p></li><li><p>OSD检查failure_queue中的伙伴OSD失败信息。</p></li></ul><h2 id="那些场景需要用到"><a href="#那些场景需要用到" class="headerlink" title="那些场景需要用到"></a>那些场景需要用到</h2><p>查看 mon的日志，看丢失的心跳包：<br>    osd心跳是一直伴随着集群存在的，也是检验集群健康的标志之一，</p><p>调整osd心跳 的参数：<br>    检查其它 osd 心跳的时间间隔，心跳响应宽限期，这些都会影响业务；故障的发现时间和心跳带来的负载之间做权衡，比如大规模的集群中， 心跳频率太高则过多的心跳报文会影响系统性能，如果心跳频率过低则会延长发现故障节点的时间，从而影响系统的可用性。</p><h2 id="基本使用（参数配置）"><a href="#基本使用（参数配置）" class="headerlink" title="基本使用（参数配置）"></a>基本使用（参数配置）</h2><p>osd心跳是集群正常工作的基石，osd的心跳的使用一般都是通过调节参数来到性能上的平衡，以下是 osd心跳机制的 参数，可以用 ceph daemon 命令设置</p><p>这里补充比较重要的参数（修改可以在 使用adminsocket 在线修改参数，当然也可以在 ceph.conf 中修改添加参数后重启 ）</p><p><strong>osd_mon_heartbeat_interval</strong><br>如果 Ceph OSD 守护进程没有 Ceph OSD 守护进程对等点，Ceph OSD 守护进程对 Ceph 监视器执行 ping 操作的频率。</p><p><strong>osd_heartbeat_interval</strong><br>Ceph OSD 守护进程 ping 其对等节点的频率（默认为6s）。</p><p><strong>osd_heartbeat_grace</strong><br>当Ceph OSD Daemon没有显示心跳时，Ceph 认为它已经停机的时间 (默认为20s)</p><p><strong>mon_osd_min_down_reporters</strong> (一般为2 )<br>报告故障的OSD 所需的最小数量 </p><p><strong>mon_osd_reporter_subtree_level</strong><br>设置报告故障的OSD 来自那个故障域的，默认为 host；默认情况下只需要两个来自不同故障域的报告就可以报告另一个OSD为停机</p><p><strong>osd_heartbeat_min_peers</strong><br>每次要发送心跳包对象的个数，默认 10个 </p><p><strong>osd_mon_report_interval</strong> 默认 5s<br>OSD 启动或其它可报告事件的报告间隔时间</p><p><strong>osd_beacon_report_interval</strong><br>osd周期性向 monitor发送 beacon消息进行保活 默认100s </p><p><strong>mon_osd_report_timeout</strong><br>mon标记一个osd为down的最长等待时间   默认值 900  </p><p>osd_mon_heartbeat_stat_stale<br>如果发送它将每 30 秒 ping 一次 Ceph 监视器以获取集群映射的最新副本…..</p><h2 id="模块组成以及实现架构"><a href="#模块组成以及实现架构" class="headerlink" title="模块组成以及实现架构"></a>模块组成以及实现架构</h2><h3 id="关键的数据结构"><a href="#关键的数据结构" class="headerlink" title="关键的数据结构"></a>关键的数据结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// information about a heartbeat peer </span><br><span class="hljs-comment">//这个类 用来记录 peer osd 信息以及 关于heartbeat 的操作函数都在这</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HeartbeatInfo</span> &#123;<br> <span class="hljs-type">int</span> peer;           <span class="hljs-comment">///&lt; peer</span><br>    ConnectionRef con_front;   <span class="hljs-comment">///&lt; peer connection (front)</span><br>    ConnectionRef con_back;    <span class="hljs-comment">///&lt; peer connection (back)</span><br>    <span class="hljs-type">utime_t</span> first_tx;   <span class="hljs-comment">///&lt; time we sent our first ping request</span><br>    <span class="hljs-type">utime_t</span> last_tx;    <span class="hljs-comment">///&lt; last time we sent a ping request</span><br>    <span class="hljs-type">utime_t</span> last_rx_front;  <span class="hljs-comment">///&lt; last time we got a ping reply on the front side</span><br>    <span class="hljs-type">utime_t</span> last_rx_back;   <span class="hljs-comment">///&lt; last time we got a ping reply on the back side</span><br>    <span class="hljs-type">epoch_t</span> epoch;      <span class="hljs-comment">///&lt; most recent epoch we wanted this peer</span><br>    <span class="hljs-comment">/// number of connections we send and receive heartbeat pings/replies</span><br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> HEARTBEAT_MAX_CONN = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">/// history of inflight pings, arranging by timestamp we sent</span><br>    <span class="hljs-comment">/// send time -&gt; deadline -&gt; remaining replies</span><br>    map&lt;<span class="hljs-type">utime_t</span>, pair&lt;<span class="hljs-type">utime_t</span>, <span class="hljs-type">int</span>&gt;&gt; ping_history;<br>    <br>    <span class="hljs-comment">//这个map保存了 peer osd的heartbeat_peers，key是 osd的 id</span><br>    map&lt;<span class="hljs-type">int</span>,HeartbeatInfo&gt; heartbeat_peers;  <span class="hljs-comment">///&lt; map of osd id to HeartbeatInfo</span><br><span class="hljs-comment">//  ....</span><br> &#125;  <br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// osd 接受心跳消息的handle 函数</span><br><span class="hljs-comment">// 在 class OSD 里面</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">HeartbeatDispatcher</span> : <span class="hljs-keyword">public</span> Dispatcher &#123;<br>    OSD *osd;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">HeartbeatDispatcher</span><span class="hljs-params">(OSD *o)</span> : Dispatcher(o-&gt;cct), osd(o) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ms_fast_dispatch</span><span class="hljs-params">(Message *m)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>      osd-&gt;<span class="hljs-built_in">heartbeat_dispatch</span>(m);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ms_dispatch</span><span class="hljs-params">(Message *m)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> osd-&gt;<span class="hljs-built_in">heartbeat_dispatch</span>(m);<br>    &#125;<br><span class="hljs-comment">//........................</span><br>    <span class="hljs-function">KeyStore *<span class="hljs-title">ms_get_auth1_authorizer_keystore</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> osd-&gt;<span class="hljs-built_in">ms_get_auth1_authorizer_keystore</span>();<br>    &#125;<br>  &#125; heartbeat_dispatcher;<br></code></pre></td></tr></table></figure><h2 id="整体设计-流程"><a href="#整体设计-流程" class="headerlink" title="整体设计 流程"></a>整体设计 流程</h2><h3 id="osd-如何发送和接受心跳的"><a href="#osd-如何发送和接受心跳的" class="headerlink" title="osd 如何发送和接受心跳的"></a>osd 如何发送和接受心跳的</h3><h4 id="public-network-和-cluster-network"><a href="#public-network-和-cluster-network" class="headerlink" title="public network  和 cluster network"></a>public network  和 cluster network</h4><p>​osd 直接的通信数据需要通过 <strong>ceph网络层传输</strong>；  一般来说 ceph集群是 内外网分离的，集群内部通信用单独cluster network，客户端外部和集群通信也是单独用 <strong>public network</strong>（可以理解为用两张网卡）<br>​ceph将osd间的副本数据、迁移数据的传输交由cluster network，将client和ceph后端的数据传输交由public network<img src="http://img.rui.vin/202209141758757.png" alt="image-20220914175829713"></p><p>​osd之间心跳通信使用了 四个message对象 （ceph中 用于通信的类在 osd 初始化时会创建，可以理解为一个专门负责派送某一种类型的快递员）用于osd心跳通信，分别是</p><ul><li><p><strong>ms_hb_front_client</strong> ： 用于向其他 osd 发送心跳</p></li><li><p><strong>ms_hb_back_client</strong>： 用于向其他 osd 发送心跳</p></li><li><p><strong>ms_hb_back_server</strong>： 用于接受他 osd 发送心跳</p></li><li><p><strong>ms_hb_front_server</strong>： 用于接收他 osd 发送心跳</p></li><li><p><strong>front</strong> 用的是public network，用于检测客户端网络连接问题，<strong>back</strong> 用的是 cluster network。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"># ceph_osd.cc<br><span class="hljs-comment">// 创建四个关于心跳的 message   </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>  Messenger *ms_hb_back_client = Messenger::<span class="hljs-built_in">create</span>(g_ceph_context, cluster_msg_type,<br>     <span class="hljs-type">entity_name_t</span>::<span class="hljs-built_in">OSD</span>(whoami), <span class="hljs-string">&quot;hb_back_client&quot;</span>,<br>     <span class="hljs-built_in">getpid</span>(), Messenger::HEARTBEAT);<br>  Messenger *ms_hb_front_client = Messenger::<span class="hljs-built_in">create</span>(g_ceph_context, public_msg_type,<br>     <span class="hljs-type">entity_name_t</span>::<span class="hljs-built_in">OSD</span>(whoami), <span class="hljs-string">&quot;hb_front_client&quot;</span>,<br>     <span class="hljs-built_in">getpid</span>(), Messenger::HEARTBEAT);<br>  Messenger *ms_hb_back_server = Messenger::<span class="hljs-built_in">create</span>(g_ceph_context, cluster_msg_type,<br>   <span class="hljs-type">entity_name_t</span>::<span class="hljs-built_in">OSD</span>(whoami), <span class="hljs-string">&quot;hb_back_server&quot;</span>,<br>   <span class="hljs-built_in">getpid</span>(), Messenger::HEARTBEAT);<br>  Messenger *ms_hb_front_server = Messenger::<span class="hljs-built_in">create</span>(g_ceph_context, public_msg_type,<br>    <span class="hljs-type">entity_name_t</span>::<span class="hljs-built_in">OSD</span>(whoami), <span class="hljs-string">&quot;hb_front_server&quot;</span>,<br>    <span class="hljs-built_in">getpid</span>(), Messenger::HEARTBEAT)；<br> <span class="hljs-comment">//osd 初始化的类其参数就需要 关于 心跳的 Message　实例</span><br> osd = <span class="hljs-keyword">new</span> <span class="hljs-built_in">OSD</span>(g_ceph_context,<br>                store,<br>                whoami,<br>                ms_cluster,<br>                ms_public,<br>                ms_hb_front_client,<br>                ms_hb_back_client,<br>                ms_hb_front_server,<br>                ms_hb_back_server,<br>                ms_objecter,<br>                &amp;mc,<br>                data_path,<br>                journal_path);<br>    <br> <span class="hljs-comment">// 启动 message   </span><br>  ms_hb_front_client-&gt;<span class="hljs-built_in">start</span>();<br>  ms_hb_back_client-&gt;<span class="hljs-built_in">start</span>();<br>  ms_hb_front_server-&gt;<span class="hljs-built_in">start</span>();<br>  ms_hb_back_server-&gt;<span class="hljs-built_in">start</span>();          <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><img src="http://img.rui.vin/202209161158998.png" alt="image-20220914175706661"><code>ms_hbclient &lt;-&gt; ms_hb_back_server</code> <code>ms_hbclient &lt;-&gt; ms_hb_front_server</code>。</p><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><p><img src="http://img.rui.vin/202209191051040.png" alt="image-20220919105101754"></p><p>osd 专门开了一个线程用来 发送心跳，遍历 heartbeat_peers ，逐个发送心跳包</p><p><img src="http://imt.rui.vin/202209251511916.png" alt="image-20220925151116385"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//解</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">T_Heartbeat</span> : <span class="hljs-keyword">public</span> Thread &#123;<br>    OSD *osd;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">T_Heartbeat</span><span class="hljs-params">(OSD *o)</span> : osd(o) &#123;</span>&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">entry</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        osd-&gt;<span class="hljs-built_in">heartbeat_entry</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125; heartbeat_thread;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">OSD::init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// start the heartbeat thread</span><br><span class="hljs-comment">//传入的参数 是线程的名字</span><br>  heartbeat_thread.<span class="hljs-built_in">create</span>(<span class="hljs-string">&quot;osd_srv_heartbt&quot;</span>);<br><span class="hljs-comment">//....                                                              </span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSD::heartbeat_entry</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-function">std::lock_guard <span class="hljs-title">l</span><span class="hljs-params">(heartbeat_lock)</span></span>;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_stopping</span>())<br>    <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">while</span> (!heartbeat_stop) &#123;<br>    <span class="hljs-built_in">heartbeat</span>();<br><br>    <span class="hljs-type">double</span> wait;<br>    <span class="hljs-comment">//等待的时间分为两种，一种是固定的 osd_heartbeat_interval，另外一种是 基于osd_heartbeat_interval生成的随机时间</span><br>    <span class="hljs-keyword">if</span> (cct-&gt;_conf.<span class="hljs-built_in">get_val</span>&lt;<span class="hljs-type">bool</span>&gt;(<span class="hljs-string">&quot;debug_disable_randomized_ping&quot;</span>)) &#123;<br>      wait = (<span class="hljs-type">float</span>)cct-&gt;_conf-&gt;osd_heartbeat_interval;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      wait = <span class="hljs-number">.5</span> + ((<span class="hljs-type">float</span>)(<span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>)/<span class="hljs-number">10.0</span>) * (<span class="hljs-type">float</span>)cct-&gt;_conf-&gt;osd_heartbeat_interval;<br>    &#125;<br>    <span class="hljs-type">utime_t</span> w;<br>    <span class="hljs-comment">//转换成 utime_t</span><br>    w.<span class="hljs-built_in">set_from_double</span>(wait);<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">30</span>) &lt;&lt; <span class="hljs-string">&quot;heartbeat_entry sleeping for &quot;</span> &lt;&lt; wait &lt;&lt; dendl;<br><br>    <span class="hljs-comment">// 这里用条件变量来等待时间，并没有释放锁 </span><br>    heartbeat_cond.<span class="hljs-built_in">WaitInterval</span>(heartbeat_lock, w);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_stopping</span>())<br>      <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">30</span>) &lt;&lt; <span class="hljs-string">&quot;heartbeat_entry woke up&quot;</span> &lt;&lt; dendl;<br><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>发送 heartbeat 过程都在    heartbeat(); 中 ，这里分析下</strong><br>heartbeat 函数主要为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSD::heartbeat</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ceph_assert</span>(heartbeat_lock.<span class="hljs-built_in">is_locked_by_me</span>());<br>  <span class="hljs-built_in">dout</span>(<span class="hljs-number">30</span>) &lt;&lt; <span class="hljs-string">&quot;heartbeat&quot;</span> &lt;&lt; dendl;<br><br>  <span class="hljs-comment">// get CPU load avg</span><br>  <span class="hljs-type">double</span> loadavgs[<span class="hljs-number">1</span>];<br>  <span class="hljs-type">int</span> hb_interval = cct-&gt;_conf-&gt;osd_heartbeat_interval;<br>  <span class="hljs-type">int</span> n_samples = <span class="hljs-number">86400</span>;<br>  <span class="hljs-keyword">if</span> (hb_interval &gt; <span class="hljs-number">1</span>) &#123;<br>    n_samples /= hb_interval;<br>    <span class="hljs-keyword">if</span> (n_samples &lt; <span class="hljs-number">1</span>)<br>      n_samples = <span class="hljs-number">1</span>;<br>  &#125;<br>  cout &lt;&lt; <span class="hljs-string">&quot;send times :  &quot;</span> &lt;&lt; n_samples &lt;&lt; std::endl;<br>  <span class="hljs-comment">// 估计下每次发送osd 负载值？？？？</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">getloadavg</span>(loadavgs, <span class="hljs-number">1</span>) == <span class="hljs-number">1</span>) &#123;<br>    cout &lt;&lt;loadavgs[<span class="hljs-number">0</span>] &lt;&lt; std::endl;<br>    logger-&gt;<span class="hljs-built_in">set</span>(l_osd_loadavg, <span class="hljs-number">100</span> * loadavgs[<span class="hljs-number">0</span>]);<br>    daily_loadavg = (daily_loadavg * (n_samples - <span class="hljs-number">1</span>) + loadavgs[<span class="hljs-number">0</span>]) / n_samples;<br><br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot;heartbeat: daily_loadavg &quot;</span> &lt;&lt; daily_loadavg &lt;&lt; dendl;<br>  &#125;<br><br>  <span class="hljs-built_in">dout</span>(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot;heartbeat checking stats&quot;</span> &lt;&lt; dendl;<br><br>  <span class="hljs-comment">// refresh peer list and osd stats</span><br>  <span class="hljs-comment">// hb_peers保存 id（这里是 osd 的id）</span><br>  vector&lt;<span class="hljs-type">int</span>&gt; hb_peers;<br><br>  <span class="hljs-comment">//遍历 peer osd, peer osd 如何更新在下面会说到</span><br>  <span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>,HeartbeatInfo&gt;::iterator p = heartbeat_peers.<span class="hljs-built_in">begin</span>();<br>       p != heartbeat_peers.<span class="hljs-built_in">end</span>();<br>       ++p)<br>    hb_peers.<span class="hljs-built_in">push_back</span>(p-&gt;first);<br><br>  <span class="hljs-comment">// 更新状态 osd 状态 </span><br>  <span class="hljs-keyword">auto</span> new_stat = service.<span class="hljs-built_in">set_osd_stat</span>(hb_peers, <span class="hljs-built_in">get_num_pgs</span>());<br>  <span class="hljs-built_in">dout</span>(<span class="hljs-number">5</span>) &lt;&lt; __func__ &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; new_stat &lt;&lt; dendl;<br>  <span class="hljs-built_in">ceph_assert</span>(new_stat.statfs.total);<br><br><span class="hljs-comment">// 这比例指 osd 使用空间变更比例</span><br>  <span class="hljs-type">float</span> pratio;<br>  <span class="hljs-type">float</span> ratio = service.<span class="hljs-built_in">compute_adjusted_ratio</span>(new_stat, &amp;pratio);<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;ratio :  &quot;</span> &lt;&lt; ratio &lt;&lt; std::endl; <br>  service.<span class="hljs-built_in">check_full_status</span>(ratio, pratio);<br><br><span class="hljs-comment">//获取当前实际  精确到纳秒</span><br>  <span class="hljs-type">utime_t</span> now = <span class="hljs-built_in">ceph_clock_now</span>();<br>  <span class="hljs-type">utime_t</span> deadline = now;<br><br><span class="hljs-comment">//deadline  最大等待回应的时间</span><br>  deadline += cct-&gt;_conf-&gt;osd_heartbeat_grace;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;now &quot;</span> &lt;&lt; now &lt;&lt; std::endl;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;deadline &quot;</span> &lt;&lt; deadline &lt;&lt; std::endl;<br><br>  <span class="hljs-comment">// send heartbeats</span><br>  <span class="hljs-comment">// 遍历 对等 peer，逐个发送</span><br>  <span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>,HeartbeatInfo&gt;::iterator i = heartbeat_peers.<span class="hljs-built_in">begin</span>();<br>       i != heartbeat_peers.<span class="hljs-built_in">end</span>();<br>       ++i) &#123;<br>    <span class="hljs-type">int</span> peer = i-&gt;first;<br>    i-&gt;second.last_tx = now;<br>    <span class="hljs-keyword">if</span> (i-&gt;second.first_tx == <span class="hljs-built_in">utime_t</span>())<br>      i-&gt;second.first_tx = now;<br>    <span class="hljs-comment">// 保存发送 heartbeat 记录，HEARTBEAT_MAX_CONN 为发送heartbeat 数量</span><br>    <span class="hljs-comment">//key 发送的时间和， value 为 心跳回复的期限 </span><br>    i-&gt;second.ping_history[now] = <span class="hljs-built_in">make_pair</span>(deadline,<br>      HeartbeatInfo::HEARTBEAT_MAX_CONN);<br>      <br>    <span class="hljs-keyword">if</span> (i-&gt;second.hb_interval_start == <span class="hljs-built_in">utime_t</span>())<br>      i-&gt;second.hb_interval_start = now;<br>      <br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot;heartbeat sending ping to osd.&quot;</span> &lt;&lt; peer &lt;&lt; dendl;<br>    <span class="hljs-comment">//  集群内发送</span><br>    i-&gt;second.con_back-&gt;<span class="hljs-built_in">send_message</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MOSDPing</span>(monc-&gt;<span class="hljs-built_in">get_fsid</span>(),<br>  service.<span class="hljs-built_in">get_osdmap_epoch</span>(),<br>  MOSDPing::PING, now,<br>  cct-&gt;_conf-&gt;osd_heartbeat_min_size)); <br><br>   <span class="hljs-comment">// 如果有 设置 public network</span><br>    <span class="hljs-keyword">if</span> (i-&gt;second.con_front)<br>      i-&gt;second.con_front-&gt;<span class="hljs-built_in">send_message</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">MOSDPing</span>(monc-&gt;<span class="hljs-built_in">get_fsid</span>(),<br>     service.<span class="hljs-built_in">get_osdmap_epoch</span>(),<br>     MOSDPing::PING, now,<br>  cct-&gt;_conf-&gt;osd_heartbeat_min_size));<br>  &#125;<br><span class="hljs-comment">//  MOSDPing::PING 心跳信息的类型，还有</span><br>  logger-&gt;<span class="hljs-built_in">set</span>(l_osd_hb_to, heartbeat_peers.<span class="hljs-built_in">size</span>());<br><span class="hljs-comment">// 如果集群只有一个 osd，他会在 osd_mon_heartbeat_interval 时间内，向mon获取新的 osdmap</span><br>  <span class="hljs-comment">// hmm.. am i all alone?</span><br>  <span class="hljs-built_in">dout</span>(<span class="hljs-number">30</span>) &lt;&lt; <span class="hljs-string">&quot;heartbeat lonely?&quot;</span> &lt;&lt; dendl;<br>  <span class="hljs-keyword">if</span> (heartbeat_peers.<span class="hljs-built_in">empty</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (now - last_mon_heartbeat &gt; cct-&gt;_conf-&gt;osd_mon_heartbeat_interval &amp;&amp; <span class="hljs-built_in">is_active</span>()) &#123;<br>      last_mon_heartbeat = now;<br>      <span class="hljs-built_in">dout</span>(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot;i have no heartbeat peers; checking mon for new map&quot;</span> &lt;&lt; dendl;<br>      <span class="hljs-built_in">osdmap_subscribe</span>(<span class="hljs-built_in">get_osdmap_epoch</span>() + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-built_in">dout</span>(<span class="hljs-number">30</span>) &lt;&lt; <span class="hljs-string">&quot;heartbeat done&quot;</span> &lt;&lt; dendl;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="更新-heartbeat-peers"><a href="#更新-heartbeat-peers" class="headerlink" title="更新 heartbeat_peers"></a>更新 heartbeat_peers</h4><p>osd 发送心跳包给peer osd，peer OSD的选择并不是集群中的全部osd，peer OSD如果选择其他所有结点，则会增加集群负载影响系统性能。peer OSD的选择是通过maybe_update_heartbeat_peers函数经行更新 heartbeat_peers；有以下三种情况会更新 heartbeat_peers：</p><ul><li>pg创建的时候，参见handle_pg_create；</li><li>osdmap变更时，参见handle_osd_map；</li><li>tick定时器会周期性的检测.</li></ul><p>osd 每次发送心跳的时候都需要遍历  heartbeat_peers， heartbeat_peers的 是个map，其 key 为osd的id，value是 HeartbeatInfo 结构体</p><p><code>map&lt;int,HeartbeatInfo&gt; heartbeat_peers;  ///&lt; map of osd id to HeartbeatInfo</code></p><h5 id="tick定时器会周期性的检测"><a href="#tick定时器会周期性的检测" class="headerlink" title="tick定时器会周期性的检测."></a>tick定时器会周期性的检测.</h5><p>ceph  使用了一个定时器来更新   <strong>heartbeat_peers</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// tick</span><br><span class="hljs-comment">//get_tick_interval生成随机时间 在1s上下，不想让他太频繁</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">OSD::get_tick_interval</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// vary +/- 5% to avoid scrub scheduling livelocks</span><br>  <span class="hljs-keyword">constexpr</span> <span class="hljs-keyword">auto</span> delta = <span class="hljs-number">0.05</span>;<br>  <span class="hljs-keyword">return</span> (OSD_TICK_INTERVAL *<br>  ceph::util::<span class="hljs-built_in">generate_random_number</span>(<span class="hljs-number">1.0</span> - delta, <span class="hljs-number">1.0</span> + delta));<br>&#125;<br><span class="hljs-comment">// 在 int OSD::init()中有一个  tick_timer.add_event_after</span><br><span class="hljs-comment">// 从函数名 可看出 添加一个时间，在 get_tick_interval() 后执行事件</span><br>  tick_timer.<span class="hljs-built_in">add_event_after</span>(<span class="hljs-built_in">get_tick_interval</span>(),<br>     <span class="hljs-keyword">new</span> <span class="hljs-built_in">C_Tick</span>(<span class="hljs-keyword">this</span>));<br><span class="hljs-comment">// 从 OSD::C_Tick 可以看出， 执行的是 osd-&gt;tick() 函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OSD</span>::C_Tick : <span class="hljs-keyword">public</span> Context &#123;<br>  OSD *osd;<br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">C_Tick</span><span class="hljs-params">(OSD *o)</span> : osd(o) &#123;</span>&#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">finish</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    osd-&gt;<span class="hljs-built_in">tick</span>();<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>osd-&gt;tick()</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//对几种情况</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSD::tick</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ceph_assert</span>(osd_lock.<span class="hljs-built_in">is_locked</span>());<br>  <span class="hljs-built_in">dout</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;tick&quot;</span> &lt;&lt; dendl;<br><span class="hljs-comment">//等待 osd心跳健康，</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_active</span>() || <span class="hljs-built_in">is_waiting_for_healthy</span>()) &#123;<br> <span class="hljs-comment">//更新 heartbeat_peers</span><br>    <span class="hljs-built_in">maybe_update_heartbeat_peers</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_waiting_for_healthy</span>()) &#123;<br>    <span class="hljs-built_in">start_boot</span>();<br>  &#125;<br><span class="hljs-comment">//更新 osdmap epoch</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_waiting_for_healthy</span>() || <span class="hljs-built_in">is_booting</span>()) &#123;<br>    <span class="hljs-function">std::lock_guard <span class="hljs-title">l</span><span class="hljs-params">(heartbeat_lock)</span></span>;<br>    <span class="hljs-type">utime_t</span> now = <span class="hljs-built_in">ceph_clock_now</span>();<br>    <span class="hljs-keyword">if</span> (now - last_mon_heartbeat &gt; cct-&gt;_conf-&gt;osd_mon_heartbeat_interval) &#123;<br>      last_mon_heartbeat = now;<br>      <span class="hljs-built_in">dout</span>(<span class="hljs-number">1</span>) &lt;&lt; __func__ &lt;&lt; <span class="hljs-string">&quot; checking mon for new map&quot;</span> &lt;&lt; dendl;<br>      <span class="hljs-built_in">osdmap_subscribe</span>(<span class="hljs-built_in">get_osdmap_epoch</span>() + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-built_in">do_waiters</span>();<br><span class="hljs-comment">//继续添加 事件，循环调用  OSD::tick()</span><br>  tick_timer.<span class="hljs-built_in">add_event_after</span>(<span class="hljs-built_in">get_tick_interval</span>(), <span class="hljs-keyword">new</span> <span class="hljs-built_in">C_Tick</span>(<span class="hljs-keyword">this</span>));<br>&#125;<br><br></code></pre></td></tr></table></figure><p>OSD::tick 中 更新 heartbeat_peers 的关键函数是  maybe_update_heartbeat_peers()  这里简要分析下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSD::maybe_update_heartbeat_peers</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ceph_assert</span>(osd_lock.<span class="hljs-built_in">is_locked</span>());<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_waiting_for_healthy</span>() || <span class="hljs-built_in">is_active</span>()) &#123;<br>    <span class="hljs-type">utime_t</span> now = <span class="hljs-built_in">ceph_clock_now</span>();<br>    <span class="hljs-comment">//第一次启动时候</span><br>    <span class="hljs-keyword">if</span> (last_heartbeat_resample == <span class="hljs-built_in">utime_t</span>()) &#123;<br>      last_heartbeat_resample = now;<br>      <span class="hljs-built_in">heartbeat_set_peers_need_update</span>();<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">heartbeat_peers_need_update</span>()) &#123;<br>      <span class="hljs-type">utime_t</span> dur = now - last_heartbeat_resample;<br>      <span class="hljs-comment">//仅仅在超出grace时间后才更新</span><br>      <span class="hljs-keyword">if</span> (dur &gt; cct-&gt;_conf-&gt;osd_heartbeat_grace) &#123;<br><span class="hljs-built_in">dout</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;maybe_update_heartbeat_peers forcing update after &quot;</span> &lt;&lt; dur &lt;&lt; <span class="hljs-string">&quot; seconds&quot;</span> &lt;&lt; dendl;<br>        <span class="hljs-comment">// 更新 peer的标志位</span><br><span class="hljs-built_in">heartbeat_set_peers_need_update</span>();<br>        <span class="hljs-comment">//// </span><br>last_heartbeat_resample = now;<br><span class="hljs-comment">// automatically clean up any stale heartbeat peers</span><br><span class="hljs-comment">// if we are unhealthy, then clean all</span><br>        <span class="hljs-comment">//清空 peers</span><br><span class="hljs-built_in">reset_heartbeat_peers</span>(<span class="hljs-built_in">is_waiting_for_healthy</span>());<br>      &#125;<br>    &#125;<br>  &#125;<br><br><span class="hljs-comment">// ............</span><br>  <span class="hljs-comment">// build heartbeat from set</span><br>  <span class="hljs-comment">// 从同一个 pg下的osd中 获取 peer</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_active</span>()) &#123;<br>    vector&lt;PGRef&gt; pgs;<br>    _get_pgs(&amp;pgs);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; pg : pgs) &#123;<br>      pg-&gt;<span class="hljs-built_in">with_heartbeat_peers</span>([&amp;](<span class="hljs-type">int</span> peer) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get_osdmap</span>()-&gt;<span class="hljs-built_in">is_up</span>(peer)) &#123;<br>    _add_heartbeat_peer(peer);<br>  &#125;<br>&#125;);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// include next and previous up osds to ensure we have a fully-connected set</span><br>  <span class="hljs-comment">//want: 保存 osd的相邻osd id，以防止 peer数量不够</span><br>  set&lt;<span class="hljs-type">int</span>&gt; want, extras;<br>  <span class="hljs-type">const</span> <span class="hljs-type">int</span> next = <span class="hljs-built_in">get_osdmap</span>()-&gt;<span class="hljs-built_in">get_next_up_osd_after</span>(whoami);<br>  <span class="hljs-keyword">if</span> (next &gt;= <span class="hljs-number">0</span>)<br>    want.<span class="hljs-built_in">insert</span>(next);<br>  <span class="hljs-type">int</span> prev = <span class="hljs-built_in">get_osdmap</span>()-&gt;<span class="hljs-built_in">get_previous_up_osd_before</span>(whoami);<br>  <span class="hljs-keyword">if</span> (prev &gt;= <span class="hljs-number">0</span> &amp;&amp; prev != next)<br>    want.<span class="hljs-built_in">insert</span>(prev);<br><br>  <span class="hljs-comment">// make sure we have at least **min_down** osds coming from different</span><br>  <span class="hljs-comment">// subtree level (e.g., hosts) for fast failure detection.</span><br>  <span class="hljs-comment">// 确保至少有 min_down 个osd peer（理论上）， 从 level 故障域 和  min_down 从整个集群 随机抽取两个osd </span><br>  <span class="hljs-keyword">auto</span> min_down = cct-&gt;_conf.<span class="hljs-built_in">get_val</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(<span class="hljs-string">&quot;mon_osd_min_down_reporters&quot;</span>);<br>  <span class="hljs-keyword">auto</span> subtree = cct-&gt;_conf.<span class="hljs-built_in">get_val</span>&lt;string&gt;(<span class="hljs-string">&quot;mon_osd_reporter_subtree_level&quot;</span>);<br><br>  <span class="hljs-built_in">get_osdmap</span>()-&gt;<span class="hljs-built_in">get_random_up_osds_by_subtree</span>(<br>    whoami, subtree, min_down, want, &amp;want);<br><br>  <span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator p = want.<span class="hljs-built_in">begin</span>(); p != want.<span class="hljs-built_in">end</span>(); ++p) &#123;<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot; adding neighbor peer osd.&quot;</span> &lt;&lt; *p &lt;&lt; dendl;<br>    extras.<span class="hljs-built_in">insert</span>(*p);<br>    _add_heartbeat_peer(*p);<br>  &#125;<br>  <span class="hljs-comment">//删除已经down的osd</span><br>  <span class="hljs-comment">// remove down peers; enumerate extras</span><br>  map&lt;<span class="hljs-type">int</span>,HeartbeatInfo&gt;::iterator p = heartbeat_peers.<span class="hljs-built_in">begin</span>();<br>  <span class="hljs-keyword">while</span> (p != heartbeat_peers.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">get_osdmap</span>()-&gt;<span class="hljs-built_in">is_up</span>(p-&gt;first)) &#123;<br>      <span class="hljs-type">int</span> o = p-&gt;first;<br>      ++p;<br>      _remove_heartbeat_peer(o);<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (p-&gt;second.epoch &lt; <span class="hljs-built_in">get_osdmap_epoch</span>()) &#123;<br>      extras.<span class="hljs-built_in">insert</span>(p-&gt;first);<br>    &#125;<br>    ++p;<br>  &#125;<br><br>  <span class="hljs-comment">// too few?</span><br>  <span class="hljs-comment">//peer数量过少，默认 10个，从 want 里面添加</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> n = next; n &gt;= <span class="hljs-number">0</span>; ) &#123;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-type">int</span>)heartbeat_peers.<span class="hljs-built_in">size</span>() &gt;= cct-&gt;_conf-&gt;osd_heartbeat_min_peers)<br>      <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">if</span> (!extras.<span class="hljs-built_in">count</span>(n) &amp;&amp; !want.<span class="hljs-built_in">count</span>(n) &amp;&amp; n != whoami) &#123;<br>      <span class="hljs-built_in">dout</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot; adding random peer osd.&quot;</span> &lt;&lt; n &lt;&lt; dendl;<br>      extras.<span class="hljs-built_in">insert</span>(n);<br>      _add_heartbeat_peer(n);<br>    &#125;<br>    n = <span class="hljs-built_in">get_osdmap</span>()-&gt;<span class="hljs-built_in">get_next_up_osd_after</span>(n);<br>    <span class="hljs-keyword">if</span> (n == next)<br>      <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// came full circle; stop</span><br>  &#125;<br><br>  <span class="hljs-comment">// too many?</span><br>  <span class="hljs-keyword">for</span> (set&lt;<span class="hljs-type">int</span>&gt;::iterator p = extras.<span class="hljs-built_in">begin</span>();<br>       (<span class="hljs-type">int</span>)heartbeat_peers.<span class="hljs-built_in">size</span>() &gt; cct-&gt;_conf-&gt;osd_heartbeat_min_peers &amp;&amp; p != extras.<span class="hljs-built_in">end</span>();<br>       ++p) &#123;<br>    <span class="hljs-keyword">if</span> (want.<span class="hljs-built_in">count</span>(*p))<br>      <span class="hljs-keyword">continue</span>;<br>    _remove_heartbeat_peer(*p);<br>  &#125;<br><br>  <span class="hljs-built_in">dout</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;maybe_update_heartbeat_peers &quot;</span> &lt;&lt; heartbeat_peers.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; peers, extras &quot;</span> &lt;&lt; extras &lt;&lt; dendl;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="pg创建的时候"><a href="#pg创建的时候" class="headerlink" title="pg创建的时候"></a>pg创建的时候</h5><p>在 函数 handle_pg_create 里最后也调用了 maybe_update_heartbeat_peers();</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSD::handle_pg_create</span><span class="hljs-params">(OpRequestRef op)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">const</span> MOSDPGCreate *m = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> MOSDPGCreate*&gt;(op-&gt;<span class="hljs-built_in">get_req</span>());<br>  <span class="hljs-built_in">ceph_assert</span>(m-&gt;<span class="hljs-built_in">get_type</span>() == MSG_OSD_PG_CREATE);<br><br>  <span class="hljs-built_in">dout</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;handle_pg_create &quot;</span> &lt;&lt; *m &lt;&lt; dendl;<br> <span class="hljs-comment">//........................</span><br><br>  <span class="hljs-built_in">maybe_update_heartbeat_peers</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="osdmap-变更时候"><a href="#osdmap-变更时候" class="headerlink" title="osdmap 变更时候"></a>osdmap 变更时候</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSD::handle_osd_map</span><span class="hljs-params">(MOSDMap *m)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//..................</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_active</span>() || <span class="hljs-built_in">is_waiting_for_healthy</span>())<br>    <span class="hljs-built_in">maybe_update_heartbeat_peers</span>();<br>  <span class="hljs-comment">//..................</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><p>在 osd初始化时，创建四个关于心跳的 message,(上文有提到)， Message 类中 处理消息的方法 handle 会注册到分发中心</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//heartbeat_dispatcher 是一个结构体，里面有处理心跳信息的函数</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">OSD::init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>...<br><span class="hljs-comment">//注册dispatcher， heartbeat_dispatcher 处理心跳信息的函数</span><br>hb_front_client_messenger-&gt;<span class="hljs-built_in">add_dispatcher_head</span>(&amp;heartbeat_dispatcher);<br>hb_back_client_messenger-&gt;<span class="hljs-built_in">add_dispatcher_head</span>(&amp;heartbeat_dispatcher);<br>hb_front_server_messenger-&gt;<span class="hljs-built_in">add_dispatcher_head</span>(&amp;heartbeat_dispatcher);<br>hb_back_server_messenger-&gt;<span class="hljs-built_in">add_dispatcher_head</span>(&amp;heartbeat_dispatcher);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// heartbeat_dispatch</span><br><span class="hljs-comment">// osd 收到心跳消息 的类型是 MSG_OSD_PING ，执行 handle_osd_ping</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">OSD::heartbeat_dispatch</span><span class="hljs-params">(Message *m)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">dout</span>(<span class="hljs-number">30</span>) &lt;&lt; <span class="hljs-string">&quot;heartbeat_dispatch &quot;</span> &lt;&lt; m &lt;&lt; dendl;<br>  <span class="hljs-keyword">switch</span> (m-&gt;<span class="hljs-built_in">get_type</span>()) &#123;<br><br>  <span class="hljs-keyword">case</span> CEPH_MSG_PING:<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;ping from &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_source_inst</span>() &lt;&lt; dendl;<br>    m-&gt;<span class="hljs-built_in">put</span>();<br>    <span class="hljs-keyword">break</span>;<br><br>  <span class="hljs-keyword">case</span> MSG_OSD_PING:<br>    <span class="hljs-built_in">handle_osd_ping</span>(<span class="hljs-built_in">static_cast</span>&lt;MOSDPing*&gt;(m));<br>    <span class="hljs-keyword">break</span>;<br><br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">0</span>) &lt;&lt; <span class="hljs-string">&quot;dropping unexpected message &quot;</span> &lt;&lt; *m &lt;&lt; <span class="hljs-string">&quot; from &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_source_inst</span>() &lt;&lt; dendl;<br>    m-&gt;<span class="hljs-built_in">put</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里分析下  当 osd 收到心跳包后 handle_osd_ping是怎么处理的<br>处理的代码很长，主要可以分为三部分： 心跳通知、心跳回复、osd dowm，从这三个case 分析下</p><p><img src="http://img.rui.vin/202209201047067.png" alt="image-20220920104648238"></p><h5 id="处理心跳通知"><a href="#处理心跳通知" class="headerlink" title="处理心跳通知"></a>处理心跳通知</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//收到的是心跳通知 </span><br>  <span class="hljs-keyword">case</span> MOSDPing::PING:<br>    &#123;<br>      <span class="hljs-comment">//debug 模式</span><br>     <span class="hljs-comment">//这里判断是否超时</span><br>      <span class="hljs-keyword">if</span> (!cct-&gt;<span class="hljs-built_in">get_heartbeat_map</span>()-&gt;<span class="hljs-built_in">is_healthy</span>()) &#123;<br><span class="hljs-built_in">dout</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;internal heartbeat not healthy, dropping ping request&quot;</span> &lt;&lt; dendl;<br><span class="hljs-keyword">break</span>;<br>      &#125;<br>      <span class="hljs-comment">//回复 心跳通知     </span><br>      Message *r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MOSDPing</span>(monc-&gt;<span class="hljs-built_in">get_fsid</span>(),<br>curmap-&gt;<span class="hljs-built_in">get_epoch</span>(),<br>MOSDPing::PING_REPLY, m-&gt;stamp,<br>cct-&gt;_conf-&gt;osd_heartbeat_min_size);<br>      m-&gt;<span class="hljs-built_in">get_connection</span>()-&gt;<span class="hljs-built_in">send_message</span>(r);<br>      <span class="hljs-comment">//验证 发送方的osd是否 为 up       </span><br>      <span class="hljs-keyword">if</span> (curmap-&gt;<span class="hljs-built_in">is_up</span>(from)) &#123;<br>      <span class="hljs-comment">//  从收到消息中 更新osd peer的epoch</span><br>service.<span class="hljs-built_in">note_peer_epoch</span>(from, m-&gt;map_epoch);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_active</span>()) &#123;<br>  ConnectionRef con = service.<span class="hljs-built_in">get_con_osd_cluster</span>(from, curmap-&gt;<span class="hljs-built_in">get_epoch</span>());<br>  <span class="hljs-keyword">if</span> (con) &#123;<br>    service.<span class="hljs-built_in">share_map_peer</span>(from, con.<span class="hljs-built_in">get</span>());<br>  &#125;<br>&#125;<br>      <span class="hljs-comment">//没有在 osdmap中发现你</span><br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!curmap-&gt;<span class="hljs-built_in">exists</span>(from) ||<br> curmap-&gt;<span class="hljs-built_in">get_down_at</span>(from) &gt; m-&gt;map_epoch) &#123;<br><span class="hljs-comment">// tell them they have died</span><br>Message *r = <span class="hljs-keyword">new</span> <span class="hljs-built_in">MOSDPing</span>(monc-&gt;<span class="hljs-built_in">get_fsid</span>(),<br>  curmap-&gt;<span class="hljs-built_in">get_epoch</span>(),<br>  MOSDPing::YOU_DIED,<br>  m-&gt;stamp,<br>  cct-&gt;_conf-&gt;osd_heartbeat_min_size);<br>m-&gt;<span class="hljs-built_in">get_connection</span>()-&gt;<span class="hljs-built_in">send_message</span>(r);<br>      &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="处理心跳回复"><a href="#处理心跳回复" class="headerlink" title="处理心跳回复"></a>处理心跳回复</h5><p>处理函数太长了，大概看了下，主要功能是 根据时间戳更新 ping_history，更新peer对应的 HeartbeatInfo，以及 osd状态，这里没有心跳超时的检测，有一个定时任务专门负责</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h4 id="心跳超时检测-和上报消息"><a href="#心跳超时检测-和上报消息" class="headerlink" title="心跳超时检测 和上报消息"></a>心跳超时检测 和上报消息</h4><p>心跳超时检测 在 OSD::init() </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">OSD::init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//.......</span><br>  tick_timer.<span class="hljs-built_in">add_event_after</span>(<span class="hljs-built_in">get_tick_interval</span>(),<br>     <span class="hljs-keyword">new</span> <span class="hljs-built_in">C_Tick</span>(<span class="hljs-keyword">this</span>));<br>  &#123;<br>    <span class="hljs-function">std::lock_guard <span class="hljs-title">l</span><span class="hljs-params">(tick_timer_lock)</span></span>;<br>   <span class="hljs-comment">//每隔 get_tick_interval()时间  调C_Tick_WithoutOSDLock类里的 osd-&gt;tick_without_osd_lock() 函数</span><br>    tick_timer_without_osd_lock.<span class="hljs-built_in">add_event_after</span>(<span class="hljs-built_in">get_tick_interval</span>(),<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">C_Tick_WithoutOSDLock</span>(<span class="hljs-keyword">this</span>));<br>  &#125;<br>    <span class="hljs-comment">//.......</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OSD</span>::C_Tick_WithoutOSDLock : <span class="hljs-keyword">public</span> Context &#123;<br>  OSD *osd;<br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">C_Tick_WithoutOSDLock</span><span class="hljs-params">(OSD *o)</span> : osd(o) &#123;</span>&#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">finish</span><span class="hljs-params">(<span class="hljs-type">int</span> r)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>    osd-&gt;<span class="hljs-built_in">tick_without_osd_lock</span>();<br>  &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>这里详细介绍下 <strong>tick_without_osd_lock</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSD::tick_without_osd_lock</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">//......</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_active</span>() || <span class="hljs-built_in">is_waiting_for_healthy</span>()) &#123;<br>    heartbeat_lock.<span class="hljs-built_in">Lock</span>();<br>    <span class="hljs-comment">//关键函数 heartbeat_check</span><br>    <span class="hljs-comment">//heartbeat_check 会将 有错误的peer都会记录到 failure_queue</span><br>    <span class="hljs-built_in">heartbeat_check</span>();<br>    heartbeat_lock.<span class="hljs-built_in">Unlock</span>();<br><br>    map_lock.<span class="hljs-built_in">get_read</span>();<br>    <span class="hljs-function">std::lock_guard <span class="hljs-title">l</span><span class="hljs-params">(mon_report_lock)</span></span>;<br><br>    <span class="hljs-comment">// mon report?</span><br>    <span class="hljs-type">utime_t</span> now = <span class="hljs-built_in">ceph_clock_now</span>();<br>    <span class="hljs-keyword">if</span> (service.<span class="hljs-built_in">need_fullness_update</span>() ||<br>now - last_mon_report &gt; cct-&gt;_conf-&gt;osd_mon_report_interval) &#123;<br>      last_mon_report = now;<br>      <span class="hljs-built_in">send_full_update</span>();<br>      <span class="hljs-comment">//send_failures 会遍历 failure_queue，然后将错误的消息发送给 mon</span><br>      <span class="hljs-built_in">send_failures</span>();<br>    &#125;<br>    map_lock.<span class="hljs-built_in">put_read</span>();<br><br>    <span class="hljs-type">epoch_t</span> max_waiting_epoch = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> s : shards) &#123;<br>      max_waiting_epoch = std::<span class="hljs-built_in">max</span>(max_waiting_epoch,<br>   s-&gt;<span class="hljs-built_in">get_max_waiting_epoch</span>());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (max_waiting_epoch &gt; <span class="hljs-built_in">get_osdmap</span>()-&gt;<span class="hljs-built_in">get_epoch</span>()) &#123;<br>      <span class="hljs-built_in">dout</span>(<span class="hljs-number">20</span>) &lt;&lt; __func__ &lt;&lt; <span class="hljs-string">&quot; max_waiting_epoch &quot;</span> &lt;&lt; max_waiting_epoch<br>       &lt;&lt; <span class="hljs-string">&quot;, requesting new map&quot;</span> &lt;&lt; dendl;<br>      <span class="hljs-built_in">osdmap_subscribe</span>(superblock.newest_map + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_active</span>()) &#123;<br> .....<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> now = ceph::coarse_mono_clock::<span class="hljs-built_in">now</span>();<br>    &#123;<br><span class="hljs-comment">//    周期性的向 mon报告</span><br>        std::lock_guard l&#123;min_last_epoch_clean_lock&#125;;<br>      <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> elapsed = now - last_sent_beacon;<br>      <span class="hljs-keyword">if</span> (chrono::<span class="hljs-built_in">duration_cast</span>&lt;chrono::seconds&gt;(elapsed).<span class="hljs-built_in">count</span>() &gt;<br>        cct-&gt;_conf-&gt;osd_beacon_report_interval) &#123;<br>        need_send_beacon = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (need_send_beacon) &#123;<br><span class="hljs-comment">//将自己当前的 eponch 发送给mon</span><br>      <span class="hljs-built_in">send_beacon</span>(now);<br>    &#125;<br>  &#125;<br>....<br><span class="hljs-comment">//更新 定时器任务</span><br>  tick_timer_without_osd_lock.<span class="hljs-built_in">add_event_after</span>(<span class="hljs-built_in">get_tick_interval</span>(),<br>      <span class="hljs-keyword">new</span> <span class="hljs-built_in">C_Tick_WithoutOSDLock</span>(<span class="hljs-keyword">this</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="heartbeat-check"><a href="#heartbeat-check" class="headerlink" title="heartbeat_check"></a><strong>heartbeat_check</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OSD::heartbeat_check</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">ceph_assert</span>(heartbeat_lock.<span class="hljs-built_in">is_locked</span>());<br>  <span class="hljs-type">utime_t</span> now = <span class="hljs-built_in">ceph_clock_now</span>();<br><br>  <span class="hljs-comment">// check for incoming heartbeats (move me elsewhere?)</span><br>  <span class="hljs-comment">// 遍历 heartbeat_peers </span><br>  <span class="hljs-keyword">for</span> (map&lt;<span class="hljs-type">int</span>,HeartbeatInfo&gt;::iterator p = heartbeat_peers.<span class="hljs-built_in">begin</span>();<br>       p != heartbeat_peers.<span class="hljs-built_in">end</span>();<br>       ++p) &#123;<br><br>    <span class="hljs-keyword">if</span> (p-&gt;second.first_tx == <span class="hljs-built_in">utime_t</span>()) &#123;<br>      <span class="hljs-built_in">dout</span>(<span class="hljs-number">30</span>) &lt;&lt; <span class="hljs-string">&quot;heartbeat_check we haven&#x27;t sent ping to osd.&quot;</span> &lt;&lt; p-&gt;first<br>               &lt;&lt; <span class="hljs-string">&quot; yet, skipping&quot;</span> &lt;&lt; dendl;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>.....<br>    <span class="hljs-comment">// 收到回复后，都会根据接收时间 记录 ping_history里</span><br>    <span class="hljs-keyword">if</span> (p-&gt;second.<span class="hljs-built_in">is_unhealthy</span>(now)) &#123;<br>      <span class="hljs-type">utime_t</span> oldest_deadline = p-&gt;second.ping_history.<span class="hljs-built_in">begin</span>()-&gt;second.first;<br>      <span class="hljs-comment">//</span><br>      <span class="hljs-keyword">if</span> (p-&gt;second.last_rx_back == <span class="hljs-built_in">utime_t</span>() ||<br>  p-&gt;second.last_rx_front == <span class="hljs-built_in">utime_t</span>()) &#123;<br><span class="hljs-comment">// fail</span><br>        <span class="hljs-comment">//有错误的peer都会记录到 failure_queue，会统一发送给mon</span><br>failure_queue[p-&gt;first] = p-&gt;second.first_tx;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>.....<br><span class="hljs-comment">// fail</span><br>failure_queue[p-&gt;first] = std::<span class="hljs-built_in">min</span>(p-&gt;second.last_rx_back, p-&gt;second.last_rx_front);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mon-如何处理上报信息的"><a href="#mon-如何处理上报信息的" class="headerlink" title="mon 如何处理上报信息的"></a>mon 如何处理上报信息的</h3><p><img src="http://img.rui.vin/202209261104487.png" alt="image-20220922164958665"></p><p><img src="/C:/Users/h00165/AppData/Roaming/Typora/typora-user-images/image-20220922170235620.png" alt="image-20220922170235620"></p><p>和osd接受心跳消息一样，在mon中 也是有一个dispatch 来处理信息，并且也是根据消息类型来处理<br><img src="/C:/Users/h00165/AppData/Roaming/Typora/typora-user-images/image-20220926110653634.png" alt="image-20220926110653634"></p><p>最终会调用   <strong>paxos_service[PAXOS_OSDMAP]-&gt;dispatch(op);</strong>   paxos_service 在 mon初始化时候就已经构造好了，可以看到处理reset重新指向了OSDMonitor的类，所以说处理报错消息是由OSDMonitor类的函数处理的；<br><img src="/C:/Users/h00165/AppData/Roaming/Typora/typora-user-images/image-20220926145352556.png" alt="image-20220926145352556"></p><p>看看  <strong>paxos_service[PAXOS_OSDMAP]-&gt;dispatch(op)</strong> 是怎么处理的<br>对于上报消息并不是直接处理，而是分为两个步骤</p><ul><li>预处理  preprocess_query</li><li>更行状态 prepare_update</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">PaxosService::dispatch</span><span class="hljs-params">(MonOpRequestRef op)</span></span><br><span class="hljs-function"></span>&#123;<br>........<br>  <span class="hljs-comment">// 预处理 操作</span><br>  <span class="hljs-comment">// preprocess</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">preprocess_query</span>(op)) <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// easy!</span><br>...........<br>.......<br>  <span class="hljs-comment">// update</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">prepare_update</span>(op)) &#123;<br>    <span class="hljs-comment">// no changes made.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (need_immediate_propose) &#123;<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">10</span>) &lt;&lt; __func__ &lt;&lt; <span class="hljs-string">&quot; forced immediate propose&quot;</span> &lt;&lt; dendl;<br>    need_immediate_propose = <span class="hljs-literal">false</span>;<br>    <span class="hljs-built_in">propose_pending</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>先说下  <strong>preprocess_query</strong> </p><p>preprocess_query 函数中处理了很多种类型消息，其中  MSG_OSD_FAILURE 对应的处理函数是 <strong>preprocess_failure</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">OSDMonitor::preprocess_query</span><span class="hljs-params">(MonOpRequestRef op)</span></span><br><span class="hljs-function"></span>&#123;<br>  op-&gt;<span class="hljs-built_in">mark_osdmon_event</span>(__func__);<br>  Message *m = op-&gt;<span class="hljs-built_in">get_req</span>();<br>  <span class="hljs-keyword">switch</span> (m-&gt;<span class="hljs-built_in">get_type</span>()) &#123;<br>    <span class="hljs-comment">// READs</span><br>.....<br>    <span class="hljs-comment">// damp updates</span><br>  <span class="hljs-keyword">case</span> MSG_OSD_MARK_ME_DOWN:<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">preprocess_mark_me_down</span>(op);<br>  <span class="hljs-keyword">case</span> MSG_OSD_FULL:<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">preprocess_full</span>(op);<br>  <span class="hljs-keyword">case</span> MSG_OSD_FAILURE:<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">preprocess_failure</span>(op);<br>......<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-built_in">ceph_abort</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终 调用 <strong>preprocess_failure</strong> ，这里多次验证这个消息是否准确的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">OSDMonitor::preprocess_failure</span><span class="hljs-params">(MonOpRequestRef op)</span></span><br><span class="hljs-function"></span>&#123;<br>  op-&gt;<span class="hljs-built_in">mark_osdmon_event</span>(__func__);<br>  MOSDFailure *m = <span class="hljs-built_in">static_cast</span>&lt;MOSDFailure*&gt;(op-&gt;<span class="hljs-built_in">get_req</span>());<br>  <span class="hljs-comment">// who is target_osd</span><br>  <span class="hljs-comment">//获取osd id</span><br>  <span class="hljs-type">int</span> badboy = m-&gt;<span class="hljs-built_in">get_target_osd</span>();<br>  <span class="hljs-comment">// check permissions</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check_source</span>(op, m-&gt;fsid))<br>    <span class="hljs-keyword">goto</span> didit;<br>  <span class="hljs-built_in">dout</span>(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">&quot;osd test &quot;</span>&lt;&lt; badboy &lt;&lt; dendl;<br>  <span class="hljs-comment">// first, verify the reporting host is valid</span><br>  <span class="hljs-comment">//先从 osdmap中验证有无这个osd</span><br>  <span class="hljs-keyword">if</span> (m-&gt;<span class="hljs-built_in">get_orig_source</span>().<span class="hljs-built_in">is_osd</span>()) &#123;<br>    <span class="hljs-type">int</span> from = m-&gt;<span class="hljs-built_in">get_orig_source</span>().<span class="hljs-built_in">num</span>();<br>    <span class="hljs-keyword">if</span> (!osdmap.<span class="hljs-built_in">exists</span>(from) ||<br>!osdmap.<span class="hljs-built_in">get_addrs</span>(from).<span class="hljs-built_in">legacy_equals</span>(m-&gt;<span class="hljs-built_in">get_orig_source_addrs</span>()) ||<br>(osdmap.<span class="hljs-built_in">is_down</span>(from) &amp;&amp; m-&gt;if_osd_failed())) &#123;<br>      <span class="hljs-built_in">dout</span>(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">&quot;preprocess_failure from dead osd.&quot;</span> &lt;&lt; from<br>      &lt;&lt; <span class="hljs-string">&quot;, ignoring&quot;</span> &lt;&lt; dendl;<br>      <span class="hljs-built_in">send_incremental</span>(op, m-&gt;<span class="hljs-built_in">get_epoch</span>()+<span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">goto</span> didit;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// weird?</span><br>  <span class="hljs-comment">//看osd状态 </span><br>  <span class="hljs-keyword">if</span> (osdmap.<span class="hljs-built_in">is_down</span>(badboy)) &#123;<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">&quot;preprocess_failure dne(/dup?): osd.&quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_osd</span>()<br>    &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_addrs</span>()<br>    &lt;&lt; <span class="hljs-string">&quot;, from &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_orig_source</span>() &lt;&lt; dendl;<br>    <span class="hljs-keyword">if</span> (m-&gt;<span class="hljs-built_in">get_epoch</span>() &lt; osdmap.<span class="hljs-built_in">get_epoch</span>())<br>      <span class="hljs-built_in">send_incremental</span>(op, m-&gt;<span class="hljs-built_in">get_epoch</span>()+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">goto</span> didit;<br>  &#125;<br>  <span class="hljs-comment">//核查上报错误osd 的地址</span><br>  <span class="hljs-keyword">if</span> (osdmap.<span class="hljs-built_in">get_addrs</span>(badboy) != m-&gt;<span class="hljs-built_in">get_target_addrs</span>()) &#123;<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">&quot;preprocess_failure wrong osd: report osd.&quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_osd</span>()<br>    &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_addrs</span>()<br>    &lt;&lt; <span class="hljs-string">&quot; != map&#x27;s &quot;</span> &lt;&lt; osdmap.<span class="hljs-built_in">get_addrs</span>(badboy)<br>    &lt;&lt; <span class="hljs-string">&quot;, from &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_orig_source</span>() &lt;&lt; dendl;<br>    <span class="hljs-keyword">if</span> (m-&gt;<span class="hljs-built_in">get_epoch</span>() &lt; osdmap.<span class="hljs-built_in">get_epoch</span>())<br>      <span class="hljs-built_in">send_incremental</span>(op, m-&gt;<span class="hljs-built_in">get_epoch</span>()+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">goto</span> didit;<br>  &#125;<br><br>  <span class="hljs-comment">// already reported?</span><br>  <span class="hljs-comment">//再次验证 验证epoch</span><br>  <span class="hljs-keyword">if</span> (osdmap.<span class="hljs-built_in">is_down</span>(badboy) ||<br>      osdmap.<span class="hljs-built_in">get_up_from</span>(badboy) &gt; m-&gt;<span class="hljs-built_in">get_epoch</span>()) &#123;<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">&quot;preprocess_failure dup/old: osd.&quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_osd</span>()<br>    &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_addrs</span>()<br>    &lt;&lt; <span class="hljs-string">&quot;, from &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_orig_source</span>() &lt;&lt; dendl;<br>    <span class="hljs-keyword">if</span> (m-&gt;<span class="hljs-built_in">get_epoch</span>() &lt; osdmap.<span class="hljs-built_in">get_epoch</span>())<br>      <span class="hljs-built_in">send_incremental</span>(op, m-&gt;<span class="hljs-built_in">get_epoch</span>()+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">goto</span> didit;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">can_mark_down</span>(badboy)) &#123;<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">&quot;preprocess_failure ignoring report of osd.&quot;</span><br>    &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_osd</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_addrs</span>()<br>    &lt;&lt; <span class="hljs-string">&quot; from &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_orig_source</span>() &lt;&lt; dendl;<br>    <span class="hljs-keyword">goto</span> didit;<br> &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> didit:<br>  mon-&gt;<span class="hljs-built_in">no_reply</span>(op);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>验证之后执行 prepare_update，和preprocess_query  一样也是通过消息类型来执行对应的处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">OSDMonitor::prepare_update</span><span class="hljs-params">(MonOpRequestRef op)</span><br>&#123;<br>  op-&gt;mark_osdmon_event(__func__);<br>  Message *m = op-&gt;get_req();<br>  dout(<span class="hljs-number">7</span>) &lt;&lt; <span class="hljs-string">&quot;prepare_update &quot;</span> &lt;&lt; *m &lt;&lt; <span class="hljs-string">&quot; from &quot;</span> &lt;&lt; m-&gt;get_orig_source_inst() &lt;&lt; dendl;<br><br>  <span class="hljs-keyword">switch</span> (m-&gt;get_type()) &#123;<br>    <span class="hljs-comment">// damp updates</span><br> .....<br>  <span class="hljs-keyword">case</span> MSG_OSD_FAILURE:<br>    <span class="hljs-keyword">return</span> prepare_failure(op);<br> .....<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> <strong>prepare_failure</strong>  函数将报告添加到 failure_info中，最后再 check_failure 执行标记osd down的错误</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">OSDMonitor::prepare_failure</span><span class="hljs-params">(MonOpRequestRef op)</span></span><br><span class="hljs-function"></span>&#123;<br>  op-&gt;<span class="hljs-built_in">mark_osdmon_event</span>(__func__);<br>  <span class="hljs-comment">//转换消息类型</span><br>  MOSDFailure *m = <span class="hljs-built_in">static_cast</span>&lt;MOSDFailure*&gt;(op-&gt;<span class="hljs-built_in">get_req</span>());<br>  <span class="hljs-built_in">dout</span>(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot;prepare_failure osd.&quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_osd</span>()<br>  &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_addrs</span>()<br>  &lt;&lt; <span class="hljs-string">&quot; from &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_orig_source</span>()<br>          &lt;&lt; <span class="hljs-string">&quot; is reporting failure:&quot;</span> &lt;&lt; m-&gt;if_osd_failed() &lt;&lt; dendl;<br> <span class="hljs-comment">//获取上报的osd</span><br>  <span class="hljs-type">int</span> target_osd = m-&gt;<span class="hljs-built_in">get_target_osd</span>();<br> <span class="hljs-comment">// </span><br>  <span class="hljs-type">int</span> reporter = m-&gt;<span class="hljs-built_in">get_orig_source</span>().<span class="hljs-built_in">num</span>();<br>  <span class="hljs-built_in">ceph_assert</span>(osdmap.<span class="hljs-built_in">is_up</span>(target_osd));<br>  <span class="hljs-built_in">ceph_assert</span>(osdmap.<span class="hljs-built_in">get_addrs</span>(target_osd) == m-&gt;<span class="hljs-built_in">get_target_addrs</span>());<br><br>  mon-&gt;<span class="hljs-built_in">no_reply</span>(op);<br><br>  <span class="hljs-keyword">if</span> (m-&gt;if_osd_failed()) &#123;<br>    <span class="hljs-comment">// calculate failure time</span><br>    <span class="hljs-type">utime_t</span> now = <span class="hljs-built_in">ceph_clock_now</span>();<br>    <span class="hljs-type">utime_t</span> failed_since =<br>      m-&gt;<span class="hljs-built_in">get_recv_stamp</span>() - <span class="hljs-built_in">utime_t</span>(m-&gt;failed_for, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// add a report</span><br>    <span class="hljs-keyword">if</span> (m-&gt;<span class="hljs-built_in">is_immediate</span>()) &#123;<br>      mon-&gt;clog-&gt;<span class="hljs-built_in">debug</span>() &lt;&lt; <span class="hljs-string">&quot;osd.&quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_osd</span>()<br> &lt;&lt; <span class="hljs-string">&quot; reported immediately failed by &quot;</span><br> &lt;&lt; m-&gt;<span class="hljs-built_in">get_orig_source</span>();<br>      force_failure(target_osd, reporter);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    mon-&gt;clog-&gt;<span class="hljs-built_in">debug</span>() &lt;&lt; <span class="hljs-string">&quot;osd.&quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_osd</span>() &lt;&lt; <span class="hljs-string">&quot; reported failed by &quot;</span><br>      &lt;&lt; m-&gt;<span class="hljs-built_in">get_orig_source</span>();<br><br>    <span class="hljs-type">failure_info_t</span>&amp; fi = failure_info[target_osd];<br><br>     <span class="hljs-comment">// 在这个添加失败的报告</span><br>    MonOpRequestRef old_op = fi.<span class="hljs-built_in">add_report</span>(reporter, failed_since, op);<br>    <span class="hljs-keyword">if</span> (old_op) &#123;<br>      mon-&gt;<span class="hljs-built_in">no_reply</span>(old_op);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">check_failure</span>(now, target_osd, fi);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// remove the report</span><br>    mon-&gt;clog-&gt;<span class="hljs-built_in">debug</span>() &lt;&lt; <span class="hljs-string">&quot;osd.&quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_osd</span>()<br>       &lt;&lt; <span class="hljs-string">&quot; failure report canceled by &quot;</span><br>       &lt;&lt; m-&gt;<span class="hljs-built_in">get_orig_source</span>();<br>    <span class="hljs-keyword">if</span> (failure_info.<span class="hljs-built_in">count</span>(target_osd)) &#123;<br>      <span class="hljs-type">failure_info_t</span>&amp; fi = failure_info[target_osd];<br>      MonOpRequestRef report_op = fi.<span class="hljs-built_in">cancel_report</span>(reporter);<br>      <span class="hljs-keyword">if</span> (report_op) &#123;<br>        mon-&gt;<span class="hljs-built_in">no_reply</span>(report_op);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (fi.reporters.<span class="hljs-built_in">empty</span>()) &#123;<br><span class="hljs-built_in">dout</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot; removing last failure_info for osd.&quot;</span> &lt;&lt; target_osd<br> &lt;&lt; dendl;<br>failure_info.<span class="hljs-built_in">erase</span>(target_osd);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">dout</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot; failure_info for osd.&quot;</span> &lt;&lt; target_osd &lt;&lt; <span class="hljs-string">&quot; now &quot;</span><br> &lt;&lt; fi.reporters.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; reporters&quot;</span> &lt;&lt; dendl;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">dout</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot; no failure_info for osd.&quot;</span> &lt;&lt; target_osd &lt;&lt; dendl;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>check_failure</strong>  函数并没有直接标记osd 为down，而是通过各种条件来调节  osd 失败的时间，然后再和 实际的osd_heartbeat_grace 做比较，以及上报数量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">OSDMonitor::check_failure</span><span class="hljs-params">(<span class="hljs-type">utime_t</span> now, <span class="hljs-type">int</span> target_osd, <span class="hljs-type">failure_info_t</span>&amp; fi)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// already pending failure?</span><br>  <span class="hljs-keyword">if</span> (pending_inc.new_state.<span class="hljs-built_in">count</span>(target_osd) &amp;&amp;<br>      pending_inc.new_state[target_osd] &amp; CEPH_OSD_UP) &#123;<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot; already pending failure&quot;</span> &lt;&lt; dendl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  set&lt;string&gt; reporters_by_subtree;<br>  <span class="hljs-comment">//故障域</span><br>  <span class="hljs-keyword">auto</span> reporter_subtree_level = <span class="hljs-built_in">g_conf</span>().<span class="hljs-built_in">get_val</span>&lt;string&gt;(<span class="hljs-string">&quot;mon_osd_reporter_subtree_level&quot;</span>);<br>  <span class="hljs-comment">//</span><br>  <span class="hljs-function"><span class="hljs-type">utime_t</span> <span class="hljs-title">orig_grace</span><span class="hljs-params">(g_conf()-&gt;osd_heartbeat_grace, <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-type">utime_t</span> max_failed_since = fi.<span class="hljs-built_in">get_failed_since</span>();<br>  <span class="hljs-type">utime_t</span> failed_for = now - max_failed_since;<br><br>  <span class="hljs-type">utime_t</span> grace = orig_grace;<br>  <span class="hljs-type">double</span> my_grace = <span class="hljs-number">0</span>, peer_grace = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">double</span> decay_k = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">//根据以往 osd的错误报告来 调整下  osd_heartbeat_grace 时间</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">g_conf</span>()-&gt;mon_osd_adjust_heartbeat_grace) &#123;<br> <span class="hljs-comment">// decay_k 为 -0.000192541     ？？？</span><br> <span class="hljs-comment">//::log(.5)  -0.693147</span><br>    <span class="hljs-type">double</span> halflife = (<span class="hljs-type">double</span>)<span class="hljs-built_in">g_conf</span>()-&gt;mon_osd_laggy_halflife;<br>    decay_k = ::<span class="hljs-built_in">log</span>(<span class="hljs-number">.5</span>) / halflife;<br><br>    <span class="hljs-comment">// scale grace period based on historical probability of &#x27;lagginess&#x27;</span><br>    <span class="hljs-comment">//根据历史上的 &quot;滞后性 &quot;概率确定宽限期的规模</span><br>    <span class="hljs-comment">// (false positive failures due to slowness).</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-type">osd_xinfo_t</span>&amp; xi = osdmap.<span class="hljs-built_in">get_xinfo</span>(target_osd);<br>    <span class="hljs-comment">//计算 log ？</span><br>    <span class="hljs-type">double</span> decay = <span class="hljs-built_in">exp</span>((<span class="hljs-type">double</span>)failed_for * decay_k);<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot; halflife &quot;</span> &lt;&lt; halflife &lt;&lt; <span class="hljs-string">&quot; decay_k &quot;</span> &lt;&lt; decay_k<br>     &lt;&lt; <span class="hljs-string">&quot; failed_for &quot;</span> &lt;&lt; failed_for &lt;&lt; <span class="hljs-string">&quot; decay &quot;</span> &lt;&lt; decay &lt;&lt; dendl;<br><br>    my_grace = decay * (<span class="hljs-type">double</span>)xi.laggy_interval * xi.laggy_probability;<br>    grace += my_grace;<br>  &#125;<br><br>  <span class="hljs-comment">// consider the peers reporting a failure a proxy for a potential</span><br>  <span class="hljs-comment">// &#x27;subcluster&#x27; over the overall cluster that is similarly</span><br>  <span class="hljs-comment">// laggy.  this is clearly not true in all cases, but will sometimes</span><br>  <span class="hljs-comment">// help us localize the grace correction to a subset of the system</span><br>  <span class="hljs-comment">// (say, a rack with a bad switch) that is unhappy.</span><br>  <span class="hljs-built_in">ceph_assert</span>(fi.reporters.<span class="hljs-built_in">size</span>());<br>  <span class="hljs-comment">//遍历上报错误</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = fi.reporters.<span class="hljs-built_in">begin</span>(); p != fi.reporters.<span class="hljs-built_in">end</span>();) &#123;<br>    <span class="hljs-comment">// get the parent bucket whose type matches with &quot;reporter_subtree_level&quot;.</span><br>    <span class="hljs-comment">// fall back to OSD if the level doesn&#x27;t exist.</span><br>    <span class="hljs-keyword">if</span> (osdmap.<span class="hljs-built_in">exists</span>(p-&gt;first)) &#123;<br>      <span class="hljs-comment">//通过osdmap 获取完整的osd位置</span><br>      <span class="hljs-keyword">auto</span> reporter_loc = osdmap.crush-&gt;<span class="hljs-built_in">get_full_location</span>(p-&gt;first);<br>      <span class="hljs-comment">//不在 指定的故障域</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> iter = reporter_loc.<span class="hljs-built_in">find</span>(reporter_subtree_level);<br>          iter == reporter_loc.<span class="hljs-built_in">end</span>()) &#123;<br>        reporters_by_subtree.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;osd.&quot;</span> + <span class="hljs-built_in">to_string</span>(p-&gt;first));<br><br>        <span class="hljs-built_in">dout</span>(<span class="hljs-number">1</span>) &lt;&lt;<span class="hljs-string">&quot;reporters_by_subtree, reporter_subtree_level:&quot;</span> &lt;&lt;reporter_subtree_level <br>                       &lt;&lt; <span class="hljs-string">&quot; vname:&quot;</span> &lt;&lt; <span class="hljs-string">&quot;osd.&quot;</span> + <span class="hljs-built_in">to_string</span>(p-&gt;first) &lt;&lt; dendl;<br>                         <br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        string name = <span class="hljs-built_in">get_phy_name</span>(iter-&gt;second);<br>        <span class="hljs-built_in">dout</span>(<span class="hljs-number">1</span>) &lt;&lt;<span class="hljs-string">&quot;reporters_by_subtree, reporter_subtree_level:&quot;</span> &lt;&lt;reporter_subtree_level <br>                       &lt;&lt; <span class="hljs-string">&quot; vname:&quot;</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="hljs-string">&quot; pname:&quot;</span> &lt;&lt; name &lt;&lt; dendl;<br>         reporters_by_subtree.<span class="hljs-built_in">insert</span>(name);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">g_conf</span>()-&gt;mon_osd_adjust_heartbeat_grace) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">osd_xinfo_t</span>&amp; xi = osdmap.<span class="hljs-built_in">get_xinfo</span>(p-&gt;first);<br>        <span class="hljs-comment">//距离上次标记down的时间</span><br>        <span class="hljs-type">utime_t</span> elapsed = now - xi.down_stamp;<br>        <span class="hljs-type">double</span> decay = <span class="hljs-built_in">exp</span>((<span class="hljs-type">double</span>)elapsed * decay_k);<br>        <span class="hljs-comment">//被标记为滞后和恢复的平均时间间隔</span><br>        peer_grace += decay * (<span class="hljs-type">double</span>)xi.laggy_interval * xi.laggy_probability;<br>      &#125;<br>      ++p;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      fi.<span class="hljs-built_in">cancel_report</span>(p-&gt;first);;<br>      p = fi.reporters.<span class="hljs-built_in">erase</span>(p);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">g_conf</span>()-&gt;mon_osd_adjust_heartbeat_grace) &#123;<br>    peer_grace /= (<span class="hljs-type">double</span>)fi.reporters.<span class="hljs-built_in">size</span>();<br>    grace += peer_grace;<br>  &#125;<br><br>  <span class="hljs-built_in">dout</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot; osd.&quot;</span> &lt;&lt; target_osd &lt;&lt; <span class="hljs-string">&quot; has &quot;</span><br>   &lt;&lt; fi.reporters.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&quot; reporters, &quot;</span><br>   &lt;&lt; grace &lt;&lt; <span class="hljs-string">&quot; grace (&quot;</span> &lt;&lt; orig_grace &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; my_grace<br>   &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; peer_grace &lt;&lt; <span class="hljs-string">&quot;), max_failed_since &quot;</span> &lt;&lt; max_failed_since<br>   &lt;&lt; dendl;<br><br><span class="hljs-comment">// 以上都是在调整 grace的时间 </span><br><br><span class="hljs-comment">// 实际 osd报错的时间 和 调整过的grace 时间做比较</span><br><span class="hljs-comment">// 以及报错的上报数量</span><br>  <span class="hljs-keyword">if</span> (failed_for &gt;= grace &amp;&amp;<br>      reporters_by_subtree.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-built_in">g_conf</span>().<span class="hljs-built_in">get_val</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(<span class="hljs-string">&quot;mon_osd_min_down_reporters&quot;</span>)) &#123;<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot; we have enough reporters to mark osd.&quot;</span> &lt;&lt; target_osd<br>    &lt;&lt; <span class="hljs-string">&quot; down&quot;</span> &lt;&lt; dendl;<br>    <span class="hljs-comment">// 将目标状态标记为 CEPH_OSD_UP，看注释是说 XORed onto previous state，异或？</span><br>    pending_inc.new_state[target_osd] = CEPH_OSD_UP;<br><br>    mon-&gt;clog-&gt;<span class="hljs-built_in">info</span>() &lt;&lt; <span class="hljs-string">&quot;osd.&quot;</span> &lt;&lt; target_osd &lt;&lt; <span class="hljs-string">&quot; failed (&quot;</span><br>      &lt;&lt; osdmap.crush-&gt;<span class="hljs-built_in">get_full_location_ordered_string</span>(<br>target_osd)<br>      &lt;&lt; <span class="hljs-string">&quot;) (&quot;</span><br>      &lt;&lt; (<span class="hljs-type">int</span>)reporters_by_subtree.<span class="hljs-built_in">size</span>()<br>      &lt;&lt; <span class="hljs-string">&quot; reporters from different &quot;</span><br>      &lt;&lt; reporter_subtree_level &lt;&lt; <span class="hljs-string">&quot; after &quot;</span><br>      &lt;&lt; failed_for &lt;&lt; <span class="hljs-string">&quot; &gt;= grace &quot;</span> &lt;&lt; grace &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>让后执行<br><strong>bool PaxosService::dispatch(MonOpRequestRef op)</strong></p><p><img src="http://img.rui.vin/202209271607817.png" alt="image-20220926140755087"></p><p><img src="/C:/Users/h00165/AppData/Roaming/Typora/typora-user-images/image-20220926140802665.png" alt="image-20220926140802665"></p><p><img src="/C:/Users/h00165/AppData/Roaming/Typora/typora-user-images/image-20220926140809506.png" alt="image-20220926140809506"></p><p>OSDMonitor::preprocess_query(MonOpRequestRef op)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">OSDMonitor::preprocess_query</span><span class="hljs-params">(MonOpRequestRef op)</span></span><br><span class="hljs-function"></span>&#123;<br>  op-&gt;<span class="hljs-built_in">mark_osdmon_event</span>(__func__);<br>  <span class="hljs-comment">//取得 message</span><br>  Message *m = op-&gt;<span class="hljs-built_in">get_req</span>();<br>  <span class="hljs-built_in">dout</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;preprocess_query &quot;</span> &lt;&lt; *m &lt;&lt; <span class="hljs-string">&quot; from &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_orig_source_inst</span>() &lt;&lt; dendl;<br>  <span class="hljs-comment">//判断 message类性</span><br>  <span class="hljs-keyword">switch</span> (m-&gt;<span class="hljs-built_in">get_type</span>()) &#123;<br>.....<br>  <span class="hljs-comment">//osd上报错误的处理函数</span><br>  <span class="hljs-keyword">case</span> MSG_OSD_FAILURE:<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">preprocess_failure</span>(op);<br>.......<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-built_in">ceph_abort</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">OSDMonitor::preprocess_failure</span><span class="hljs-params">(MonOpRequestRef op)</span></span><br><span class="hljs-function"></span>&#123;<br>  op-&gt;<span class="hljs-built_in">mark_osdmon_event</span>(__func__);<br>  MOSDFailure *m = <span class="hljs-built_in">static_cast</span>&lt;MOSDFailure*&gt;(op-&gt;<span class="hljs-built_in">get_req</span>());<br>  <span class="hljs-comment">// who is target_osd</span><br>  <span class="hljs-type">int</span> badboy = m-&gt;<span class="hljs-built_in">get_target_osd</span>();<br><br>  <span class="hljs-comment">// check permissions</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check_source</span>(op, m-&gt;fsid))<br>    <span class="hljs-keyword">goto</span> didit;<br><br>  <span class="hljs-comment">// first, verify the reporting host is valid</span><br>  <span class="hljs-keyword">if</span> (m-&gt;<span class="hljs-built_in">get_orig_source</span>().<span class="hljs-built_in">is_osd</span>()) &#123;<br>    <span class="hljs-type">int</span> from = m-&gt;<span class="hljs-built_in">get_orig_source</span>().<span class="hljs-built_in">num</span>();<br>    <span class="hljs-keyword">if</span> (!osdmap.<span class="hljs-built_in">exists</span>(from) ||<br>!osdmap.<span class="hljs-built_in">get_addrs</span>(from).<span class="hljs-built_in">legacy_equals</span>(m-&gt;<span class="hljs-built_in">get_orig_source_addrs</span>()) ||<br>(osdmap.<span class="hljs-built_in">is_down</span>(from) &amp;&amp; m-&gt;if_osd_failed())) &#123;<br>      <span class="hljs-built_in">dout</span>(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">&quot;preprocess_failure from dead osd.&quot;</span> &lt;&lt; from<br>      &lt;&lt; <span class="hljs-string">&quot;, ignoring&quot;</span> &lt;&lt; dendl;<br>      <span class="hljs-built_in">send_incremental</span>(op, m-&gt;<span class="hljs-built_in">get_epoch</span>()+<span class="hljs-number">1</span>);<br>      <span class="hljs-keyword">goto</span> didit;<br>    &#125;<br>  &#125;<br><br><br>  <span class="hljs-comment">// weird?</span><br>  <span class="hljs-keyword">if</span> (osdmap.<span class="hljs-built_in">is_down</span>(badboy)) &#123;<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">&quot;preprocess_failure dne(/dup?): osd.&quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_osd</span>()<br>    &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_addrs</span>()<br>    &lt;&lt; <span class="hljs-string">&quot;, from &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_orig_source</span>() &lt;&lt; dendl;<br>    <span class="hljs-keyword">if</span> (m-&gt;<span class="hljs-built_in">get_epoch</span>() &lt; osdmap.<span class="hljs-built_in">get_epoch</span>())<br>      <span class="hljs-built_in">send_incremental</span>(op, m-&gt;<span class="hljs-built_in">get_epoch</span>()+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">goto</span> didit;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (osdmap.<span class="hljs-built_in">get_addrs</span>(badboy) != m-&gt;<span class="hljs-built_in">get_target_addrs</span>()) &#123;<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">&quot;preprocess_failure wrong osd: report osd.&quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_osd</span>()<br>    &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_addrs</span>()<br>    &lt;&lt; <span class="hljs-string">&quot; != map&#x27;s &quot;</span> &lt;&lt; osdmap.<span class="hljs-built_in">get_addrs</span>(badboy)<br>    &lt;&lt; <span class="hljs-string">&quot;, from &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_orig_source</span>() &lt;&lt; dendl;<br>    <span class="hljs-keyword">if</span> (m-&gt;<span class="hljs-built_in">get_epoch</span>() &lt; osdmap.<span class="hljs-built_in">get_epoch</span>())<br>      <span class="hljs-built_in">send_incremental</span>(op, m-&gt;<span class="hljs-built_in">get_epoch</span>()+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">goto</span> didit;<br>  &#125;<br><br>  <span class="hljs-comment">// already reported?</span><br>  <span class="hljs-keyword">if</span> (osdmap.<span class="hljs-built_in">is_down</span>(badboy) ||<br>      osdmap.<span class="hljs-built_in">get_up_from</span>(badboy) &gt; m-&gt;<span class="hljs-built_in">get_epoch</span>()) &#123;<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">&quot;preprocess_failure dup/old: osd.&quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_osd</span>()<br>    &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_addrs</span>()<br>    &lt;&lt; <span class="hljs-string">&quot;, from &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_orig_source</span>() &lt;&lt; dendl;<br>    <span class="hljs-keyword">if</span> (m-&gt;<span class="hljs-built_in">get_epoch</span>() &lt; osdmap.<span class="hljs-built_in">get_epoch</span>())<br>      <span class="hljs-built_in">send_incremental</span>(op, m-&gt;<span class="hljs-built_in">get_epoch</span>()+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">goto</span> didit;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">can_mark_down</span>(badboy)) &#123;<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">&quot;preprocess_failure ignoring report of osd.&quot;</span><br>    &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_osd</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_addrs</span>()<br>    &lt;&lt; <span class="hljs-string">&quot; from &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_orig_source</span>() &lt;&lt; dendl;<br>    <span class="hljs-keyword">goto</span> didit;<br>  &#125;<br><br>  <span class="hljs-built_in">dout</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;preprocess_failure new: osd.&quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_osd</span>()<br>   &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_target_addrs</span>()<br>   &lt;&lt; <span class="hljs-string">&quot;, from &quot;</span> &lt;&lt; m-&gt;<span class="hljs-built_in">get_orig_source</span>() &lt;&lt; dendl;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br> didit:<br>  mon-&gt;<span class="hljs-built_in">no_reply</span>(op);<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">OSDMonitor::check_failure</span><span class="hljs-params">(<span class="hljs-type">utime_t</span> now, <span class="hljs-type">int</span> target_osd, <span class="hljs-type">failure_info_t</span>&amp; fi)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">// already pending failure?</span><br>  <span class="hljs-keyword">if</span> (pending_inc.new_state.<span class="hljs-built_in">count</span>(target_osd) &amp;&amp;<br>      pending_inc.new_state[target_osd] &amp; CEPH_OSD_UP) &#123;<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot; already pending failure&quot;</span> &lt;&lt; dendl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br><br>  set&lt;string&gt; reporters_by_subtree;<br>  <span class="hljs-comment">//故障域</span><br>  <span class="hljs-keyword">auto</span> reporter_subtree_level = <span class="hljs-built_in">g_conf</span>().<span class="hljs-built_in">get_val</span>&lt;string&gt;(<span class="hljs-string">&quot;mon_osd_reporter_subtree_level&quot;</span>);<br>  <span class="hljs-comment">//</span><br>  <span class="hljs-function"><span class="hljs-type">utime_t</span> <span class="hljs-title">orig_grace</span><span class="hljs-params">(g_conf()-&gt;osd_heartbeat_grace, <span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-type">utime_t</span> max_failed_since = fi.<span class="hljs-built_in">get_failed_since</span>();<br>  <span class="hljs-type">utime_t</span> failed_for = now - max_failed_since;<br><br>  <span class="hljs-type">utime_t</span> grace = orig_grace;<br>  <span class="hljs-type">double</span> my_grace = <span class="hljs-number">0</span>, peer_grace = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">double</span> decay_k = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">//根据以往 osd的错误报告来 调整下  osd_heartbeat_grace 时间</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">g_conf</span>()-&gt;mon_osd_adjust_heartbeat_grace) &#123;<br> <span class="hljs-comment">// decay_k 为 -0.000192541     ？？？</span><br> <span class="hljs-comment">//::log(.5)  -0.693147</span><br>    <span class="hljs-type">double</span> halflife = (<span class="hljs-type">double</span>)<span class="hljs-built_in">g_conf</span>()-&gt;mon_osd_laggy_halflife;<br>    decay_k = ::<span class="hljs-built_in">log</span>(<span class="hljs-number">.5</span>) / halflife;<br><br>    <span class="hljs-comment">// scale grace period based on historical probability of &#x27;lagginess&#x27;</span><br>    <span class="hljs-comment">//根据历史上的 &quot;滞后性 &quot;概率确定宽限期的规模</span><br>    <span class="hljs-comment">// (false positive failures due to slowness).</span><br><br>    <span class="hljs-type">const</span> <span class="hljs-type">osd_xinfo_t</span>&amp; xi = osdmap.<span class="hljs-built_in">get_xinfo</span>(target_osd);<br>    <span class="hljs-comment">//计算 log ？</span><br>    <span class="hljs-type">double</span> decay = <span class="hljs-built_in">exp</span>((<span class="hljs-type">double</span>)failed_for * decay_k);<br>    <span class="hljs-built_in">dout</span>(<span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&quot; halflife &quot;</span> &lt;&lt; halflife &lt;&lt; <span class="hljs-string">&quot; decay_k &quot;</span> &lt;&lt; decay_k<br>     &lt;&lt; <span class="hljs-string">&quot; failed_for &quot;</span> &lt;&lt; failed_for &lt;&lt; <span class="hljs-string">&quot; decay &quot;</span> &lt;&lt; decay &lt;&lt; dendl;<br><br>    my_grace = decay * (<span class="hljs-type">double</span>)xi.laggy_interval * xi.laggy_probability;<br>    grace += my_grace;<br>  &#125;<br>  <span class="hljs-comment">//遍历上报错误</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p = fi.reporters.<span class="hljs-built_in">begin</span>(); p != fi.reporters.<span class="hljs-built_in">end</span>();) &#123;<br>    <span class="hljs-comment">// get the parent bucket whose type matches with &quot;reporter_subtree_level&quot;.</span><br>    <span class="hljs-comment">// fall back to OSD if the level doesn&#x27;t exist.</span><br>    <span class="hljs-keyword">if</span> (osdmap.<span class="hljs-built_in">exists</span>(p-&gt;first)) &#123;<br>      <span class="hljs-comment">//通过osdmap 获取完整的osd位置</span><br>      <span class="hljs-keyword">auto</span> reporter_loc = osdmap.crush-&gt;<span class="hljs-built_in">get_full_location</span>(p-&gt;first);<br>      <span class="hljs-comment">//不在 指定的故障域</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> iter = reporter_loc.<span class="hljs-built_in">find</span>(reporter_subtree_level);<br>          iter == reporter_loc.<span class="hljs-built_in">end</span>()) &#123;<br>        reporters_by_subtree.<span class="hljs-built_in">insert</span>(<span class="hljs-string">&quot;osd.&quot;</span> + <span class="hljs-built_in">to_string</span>(p-&gt;first));<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        string name = <span class="hljs-built_in">get_phy_name</span>(iter-&gt;second);<br>           reporters_by_subtree.<span class="hljs-built_in">insert</span>(name);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">g_conf</span>()-&gt;mon_osd_adjust_heartbeat_grace) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">osd_xinfo_t</span>&amp; xi = osdmap.<span class="hljs-built_in">get_xinfo</span>(p-&gt;first);<br>        <span class="hljs-comment">//距离上次标记down的时间</span><br>        <span class="hljs-type">utime_t</span> elapsed = now - xi.down_stamp;<br>        <span class="hljs-type">double</span> decay = <span class="hljs-built_in">exp</span>((<span class="hljs-type">double</span>)elapsed * decay_k);<br>        <span class="hljs-comment">//被标记为滞后和恢复的平均时间间隔</span><br>        peer_grace += decay * (<span class="hljs-type">double</span>)xi.laggy_interval * xi.laggy_probability;<br>      &#125;<br>      ++p;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      fi.<span class="hljs-built_in">cancel_report</span>(p-&gt;first);;<br>      p = fi.reporters.<span class="hljs-built_in">erase</span>(p);<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">g_conf</span>()-&gt;mon_osd_adjust_heartbeat_grace) &#123;<br>    peer_grace /= (<span class="hljs-type">double</span>)fi.reporters.<span class="hljs-built_in">size</span>();<br>    grace += peer_grace;<br>  &#125;<br><span class="hljs-comment">// 以上都是在调整 grace的时间 </span><br><br><span class="hljs-comment">// 实际 osd报错的时间 和 调整过的grace 时间做比较</span><br><span class="hljs-comment">// 以及报错的上报数量</span><br>  <span class="hljs-keyword">if</span> (failed_for &gt;= grace &amp;&amp;<br>      reporters_by_subtree.<span class="hljs-built_in">size</span>() &gt;= <span class="hljs-built_in">g_conf</span>().<span class="hljs-built_in">get_val</span>&lt;<span class="hljs-type">uint64_t</span>&gt;(<span class="hljs-string">&quot;mon_osd_min_down_reporters&quot;</span>)) &#123;<br>   <br>    <span class="hljs-comment">// 将目标状态标记为 CEPH_OSD_UP，看注释是说 XORed onto previous state，异或？</span><br>    pending_inc.new_state[target_osd] = CEPH_OSD_UP;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一类是同个PG下的OSD节点之间</p><p>另一类是OSD的左右两个相邻的节点，</p><p>可以用于节点间检测对方是否故障，以便及时发现故障节点后进入相应的故障处理流程。</p><p>每个OSD节点（守护进程）会监听public、cluster、front和back四个端口</p><ul><li>public端口：监听来自Monitor和Client的连接。</li><li>cluster端口：监听来自OSD Peer的连接（同一个集群内的osd）。</li><li>front端口：供客户端连接集群使用的网卡, 这里临时给集群内部之间进行心跳。</li><li>back端口：供客集群内部使用的网卡。集群内部之间进行心跳。</li></ul><p>每个 Ceph OSD 守护进程每 6 秒检查其他 Ceph OSD 守护进程的心跳。要更改心跳间隔，请在 Ceph 配置文件的 <code>[osd]</code> 部分下添加 <code>osd heartbeat interval</code> 设置，或者在运行时更改其值。</p><p>如果邻居 Ceph OSD 守护进程未在 20 秒宽限期内发送 heartbeat 数据包，Ceph OSD 守护进程可能会考虑相邻的 Ceph OSD 守护进程 <code>停机</code>。它将报告回 Ceph 监控器，后者将更新 Ceph 群集映射。若要更改此宽限期，可在 Ceph 配置文件的 <code>[osd]</code> 部分下添加 <code>osd heartbeat 宽限期</code>，或者在运行时设置其值。</p><p><img src="http://img.rui.vin/202209141140073.png" alt="image-20220914114020984"></p><p>osd 之间心跳机制：osd之间会互相通信，通信间隔时间在随机 6s以内；如果在20s后没有收到osd没有收到相邻的osd心跳，会认为相邻的osd已经 dowm，并报告给 mon；</p><img src="http://imt.rui.vin/202209121823055.png" alt="image-20220912181919117" style="zoom:80%;"><p>osd和mon之间的心跳机制：  </p><ul><li>向mon 上报 osd down信息，mon判断机制是收到两个以上某个osd dowm的信息</li></ul><p><img src="http://imt.rui.vin/202209121823048.png" alt="image-20220912182244414"></p><ul><li>上报 osd 状态，变更信息，不管osd 有没有变更信息，每个120s都要上报一次</li></ul><p><img src="/C:/Users/hrp/AppData/Roaming/Typora/typora-user-images/image-20220912182611844.png" alt="image-20220912182611844"></p><ul><li>当 获取不到 邻居osd信息时，上报给mon获取新的 osdmap</li></ul><p><img src="/C:/Users/hrp/AppData/Roaming/Typora/typora-user-images/image-20220912182528403.png" alt="image-20220912182528403"></p><p><img src="http://img.rui.vin/202209131747251.png" alt="image-20220913174728093"></p><p><img src="http://img.rui.vin/202209071600481.png" alt="image-20220907160040430"></p><p><img src="http://img.rui.vin/202209071650942.png" alt="image-20220907165035868"></p><p>  \</p>]]></content>
    
    
    
    <tags>
      
      <tag>ceph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ceph-模块初始化中 prefork源码解析</title>
    <link href="/2022/08/25/ceph/%5Bceph%5D%20%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%AD%E7%9A%84prefork/"/>
    <url>/2022/08/25/ceph/%5Bceph%5D%20%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%AD%E7%9A%84prefork/</url>
    
    <content type="html"><![CDATA[<p>   在 osd启动流程的代码中有一个  global_init_prefork() 的 函数，发现在很多 模块启动流程都有 这个函数，这和模块对应的进程有关系，所以对这个函数剖析下</p><p><img src="http://imt.rui.vin/202209020024848.png" alt="image-20220901151643117"></p><p>  具体实现函数都在 Preforker 类中 <img src="http://imt.rui.vin/202209020024793.png" alt="image-20220901154138047"></p><p>在先执行是 <strong>global_init_prefork(g_ceph_context)</strong> 函数</p><h3 id="global-init-prefork-g-ceph-context"><a href="#global-init-prefork-g-ceph-context" class="headerlink" title="global_init_prefork(g_ceph_context)"></a>global_init_prefork(g_ceph_context)</h3><p>prefork 的预初始化</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xl">int global_init_prefork(CephContext *cct)<br>&#123;<br>   <span class="hljs-comment">// 这里 判断是不是 判断着进程是不是 以守护进程方式启动</span><br>  <span class="hljs-keyword">if</span> (g_code_env != CODE_ENVIRONMENT_DAEMON)<br>    return -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">const</span> auto&amp; conf = cct-&gt;</span>_conf;<br>  <span class="hljs-function"><span class="hljs-title">if</span> (!conf-&gt;</span>daemonize) &#123;<br>        <span class="hljs-comment">//这里进程的pid 写入文件中</span><br>    <span class="hljs-keyword">if</span> (pidfile_write(conf) &lt; <span class="hljs-number">0</span>)<br>      exit(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//生产了 pid文件后，更改文件权限</span><br>    <span class="hljs-function"><span class="hljs-title">if</span> ((cct-&gt;</span>get_init_flags() &amp; CINIT_FLAG_DEFER_DROP_PRIVILEGES) &amp;&amp;<br>    (<span class="hljs-function"><span class="hljs-title">cct</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">get_set_uid</span>() || cct-&gt;</span>get_set_gid())) &#123;<br>      <span class="hljs-function"><span class="hljs-title">chown_path</span>(conf-&gt;</span><span class="hljs-function"><span class="hljs-title">pid_file</span>, cct-&gt;</span><span class="hljs-function"><span class="hljs-title">get_set_uid</span>(), cct-&gt;</span>get_set_gid(),<br>         <span class="hljs-function"><span class="hljs-title">cct</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">get_set_uid_string</span>(), cct-&gt;</span>get_set_gid_string());<br>    &#125;<br><br>    return -<span class="hljs-number">1</span>;<br>  &#125;<br> <span class="hljs-comment">//这里  告知大家要 pre_fork??????</span><br>  <span class="hljs-function"><span class="hljs-title">cct</span>-&gt;</span>notify_pre_fork();<br>  <span class="hljs-comment">// stop log thread</span><br>  <span class="hljs-function"><span class="hljs-title">cct</span>-&gt;</span>_<span class="hljs-function"><span class="hljs-title">log</span>-&gt;</span>flush();<br>  <span class="hljs-function"><span class="hljs-title">cct</span>-&gt;</span>_<span class="hljs-function"><span class="hljs-title">log</span>-&gt;</span>stop();<br>  return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>pidfile_write(conf) 函数i就是把进程的 pid 写进 一个文件里，为什么这么做后面再说</p><p><img src="http://imt.rui.vin/202209020024807.png" alt="image-20220901162701621"></p><h3 id="forker-prefork"><a href="#forker-prefork" class="headerlink" title="forker.prefork"></a>forker.prefork</h3><p>关键部分，这里主要做的是 fork一个子进程，接下来执行的操作都是由 子进程执行，父进程处于 wait状态，并且这里也对标准输入输出做了些处理</p><p><img src="http://imt.rui.vin/202209020024851.png" alt="image-20220901163924371"></p><p>父进程处于等待状态，再执行 <strong>setsid</strong> 建立新会话</p><p><img src="http://imt.rui.vin/202209020024836.png" alt="image-20220901164030039"></p><h3 id="global-init-postfork-start"><a href="#global-init-postfork-start" class="headerlink" title="global_init_postfork_start();"></a>global_init_postfork_start();</h3><p>该函数重新再把当前进程的pid重新写入到pid文件 </p><p>为什么创建一个经常需要 建立一个pid文件？ 可这里先从 pid 文件创建开始讲</p><p><img src="http://imt.rui.vin/202209020024777.png" alt="image-20220901173051970"></p><p>在刚才的  <strong>pidfile_write</strong>  函数中，有调用了一个 函数   <strong>pidfh::open</strong>  <img src="http://imt.rui.vin/202209020024141.png" alt="image-20220901171416846"></p><p><strong>pidfh::open</strong> 中调用了 open，创建 文件 <img src="http://imt.rui.vin/202209020024179.png" alt="image-20220901171924980"></p><p>随后 获取创建文件的信息保存  Preforker 类中 <img src="http://imt.rui.vin/202209020024296.png" alt="image-20220901172326150"></p><p>最后一步比较关键，用 flock 给文件上锁 </p><p><img src="http://imt.rui.vin/202209020024329.png" alt="image-20220901172606066"></p><p>  这里确保 只有获取锁的进程才能读取文件，没有锁的话直接退出，而且只有一把锁，可以防止进程启动多个副本，只有获得pid文件(固定路径固定文件名)写入权限(F_WRLCK)的进程才能正常启动并把自身的PID写入该文件中。其它同一个程序的多余进程则自动退出。</p><blockquote><p>  假如说我开了两个终端，都同时创建 osd，而且编号都相同，为了确保一个osd对应一个守护进程，跟据程序的设定，必须要读取pid文件才能继续执行，那谁先获得了 pid文件的读写锁，谁就可以继续执行；而且pid文件保存的是 进程的pid，所以可以通过文件来判断进程是否存在</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>ceph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raft leader选举</title>
    <link href="/2022/08/19/raft/"/>
    <url>/2022/08/19/raft/</url>
    
    <content type="html"><![CDATA[<p>​</p><p>raft介绍</p><blockquote><p>  是一种<strong>强一致性</strong>、<strong>去中心化</strong>、<strong>高可用</strong>的分布式协议，是一种leader-based的共识算法；由于 一致性算法中最为出名 Paxos比较难理解，于是有两位学者研究出了raft算法，号称是最容易理解的共识算法（读了论文，确实比较容易理解）</p></blockquote><p>这篇文章主要对 结合raft论文和网上的文章做一个输出，从三个部分介绍 raft</p><ul><li>raft 协议能做什么</li><li>raft 中的 leader 选举</li><li>raft 中的 日志同步和安全性（待更新，会在另外一篇文章）</li></ul><p>谈到分布式就离不开一致性的问题，这里的一致性就是 CAP理论的Consistnecy ，在raft中 强一致性的，什么是强一致性呢？假如有三台服务器A，B，C，A收客户端发来的数据后，将数据拷贝到B，C作为副本保存，只有拷贝数据全部完成了，A才可以告知客户端接收数据成功，这是为了确保每个时刻外部从服务器读数据都是一致的；而Raft 使用了一种共识算法来实现前面所说的强一致性。</p><h3 id="先说几个概念："><a href="#先说几个概念：" class="headerlink" title="先说几个概念："></a>先说几个概念：</h3><p><strong>Raft中的角色</strong>： 在 Raft 系统中的有三种角色： 领导者（Leader）、跟从者（Follower）和候选人（Candidate）</p><ul><li>leader： leader 责任去管理副本日志</li><li>follower： 负责投票，只回复leader和candidate请求</li><li>candidate： follower 转换成leader的中间转态</li></ul><p><strong>Term</strong>： 在Raft中的时间会别划分为一个一个Term，而Term就是一个leader的在任的时间（可以理解为leader 当了多久），这个Term时间包含了 <strong>leader选举的时间</strong>和 <strong>leader “在职”的时间</strong>，没一个Term都编号，这里可以理解为是第几届的任期</p><p>Raft中的通信方式：在Raft服务器之间 使用RPC通信方式 ，其中只有类型的RPC：</p><ul><li>RequestVote RPCs： 请求投票RPC</li><li>AppendEntries RPCs： 添加日志RPC</li></ul><p><strong>为什么要选举</strong>：集群中一般有三台及以上的服务器，而且为奇数，一般那有一个主节点实现了协同和管理，如果主节点宕机了，其他服务器来顶替，而选哪个服务器呢？在raft中使用了 日常生活中的民主投票机制类似，核心思想是“少数服从多数”，从而推选出新的 <strong>leader</strong>。</p><h3 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h3><p>​    当服务器开始启动时候，一开始的状态为follower；这里有一个机制是 如果有leader 存在，会定期发送给心跳包给 全部follower（可以理解为给员工发工资），用来确保 leader的地位（让员工干活有激情），但是如果一个 follower没有接收到心跳包，他就准备造反了（自己想当老板），在没有收到心跳包后的超时时间内自己发起一场选举，此时follower状态转换为candidate，并发送一个 RequestVote 类型 RPCs给全部follower，让他们来投票（他自己也可以投票，投给自己，以先到先得的基础上，最多投票给一个候选人），如果票数超过一半，candidate会成为新的leader。注意每一个term中只会<strong>产生</strong>一个 leader！</p><p>   此时candidate面临三种情况：</p><ol><li><p>我赢了，成为 leader </p></li><li><p>刚好 其他follower也发起了选举，另一个服务器赢了</p></li><li><p>平局，这个任期谁也没赢</p></li></ol><p>第一种情况，candidate获得了 一半以上的投票，成为了leader。它向其他服务器发送心跳消息，相当于说告诉其他成员你们有leader了，以建立其权威，并防止新的选举。</p><p>第二种情况是，此时这个Term里面不止有一个 candidate, 可能另外一个candidate比较快发起投票，先到先得。</p><p>第三种情况，没有产生leader，原因可能是 有很多 follower都同时成为了candidate（都想造反），导致没有一个candidate过得过半的票数，此时再来一次，新建一个Term；但问题是，重来一次还是有可能发生的！这里引用了一个随机选举超时的机制，即在成为candidate 前都需要等待一段随机时间，加入 A 等待100ms，B 等150ms，C等200ms，A肯定是最小转变candidate的，此时只有一个candidate，其他都为 follower，这样可以尽可能的避免 投票分裂的情况。</p><p>当 candidate在等待 投票结果时，收到了 ”前 leader “ AppendEntries RPC，此时怎么办呢？ 此时 candidate 会比较谁的 Term比较早，比如说 leader 是 13届的任期，而candidate是14届了，那说明已经不是同个时代的事直接忽略；而如果说 leader 是14届或者说更大，则说明candidate已经落伍了，是 <strong>“旧时代的 余党”</strong> ,而且此时有leader 了，没必要继续下去，此时 candidate 会转换成 follower。</p><p>这里建议看下动画加深理解  <a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a> </p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ceph admin socket 源码分析 </title>
    <link href="/2022/08/19/ceph/%5Bceph%5D%20adminsocke%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2022/08/19/ceph/%5Bceph%5D%20adminsocke%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>test</p><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h4 id="Unix-domain-socket-和-网络-socket的区别"><a href="#Unix-domain-socket-和-网络-socket的区别" class="headerlink" title="Unix domain socket   和  网络 socket的区别"></a><strong>Unix domain socket</strong>   和  网络 socket的区别</h4><p>​对于网络socket，大家应该比较熟悉，两个不同主机上的进程通信，就可以网络 socket来通信；对于同一台主机上的两个进程通信也可以使用socket，地址使用 127.0.0.1就可以实现，但是对于同一主机的两个进程通信而言，其数据还是需要通过网络协议栈（数据需要打包又要拆包…），这样效率并不高，后来引用 Unix domain socket（网络socket 的框架上发展出一种 IPC 机制） ，<strong>专门用于实现同一主机上的进程间通信</strong>  ，Unix domain socket 不需要经过网络协议栈，可以直接将数据从一个进程拷贝到另一个进程；</p><p>​网络socket 使用ip地址加端口号确定 socket 地址，而  Unix domain socket 的地址是一个 socket 类型的文件路径， 这也是两者最大的区别！ 其余使用基本相同。</p><h3 id="admin-socket-是什么？"><a href="#admin-socket-是什么？" class="headerlink" title="admin socket 是什么？"></a>admin socket 是什么？</h3><p>​Ceph 集群  中有很多守护进程，如每个osd都有一个守护进程，如果我们想获取进程运行时的配置参数我们可以使用 admin socket 查看，还可以获取进程运行的状态，以及集群修改配置，获取log等。</p><p>​admin socket 获取进程信息的方式通过 <strong>Unix domain socket</strong> ，即我们上文提到的 IPC机制（<strong>inter-process communication</strong> 进程间通信），admin socket 初始化时候会生成一个  socket 类型的文件（调用 bind函数的时候），其文件路径 固定在了    <strong>&#x2F;var&#x2F;run&#x2F;ceph&#x2F;</strong>   中，（这个文件可以理解为通信地址）；每次使用 adminsocket 获取进程状态的时候，都需要附带这个文件路径（下面使用会提到）。</p><p><img src="http://imt.rui.vin/202209112236790.png" alt="image-20220911175540114" style="zoom:60%;"><strong>admin socket 实现流程图</strong></p><h3 id="admin-socket-怎么用？"><a href="#admin-socket-怎么用？" class="headerlink" title="admin socket 怎么用？"></a>admin socket 怎么用？</h3><h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>ceph daemon [socket 类型的文件路径] [command] </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#通过 ceph daemon 可以查看到相应的守护进程的信息 </span><br><span class="hljs-comment">#ceph中每个 守护进程都对应一个 asok 文件</span><br><br>[root@node29 ~]<span class="hljs-comment"># ls /var/run/ceph/</span><br>ceph-client.radosgw.gateway.28290.93853901817120.asok  ceph-mon.mon-node29.asok  ceph-osd.1.asok<br>ceph-mgr.node29.asok                                   ceph-osd.0.asok           ceph-osd.2.asok<br><br><span class="hljs-comment"># asok类型的文件就是 进程启动时生成的</span><br><br>[root@node29 run]<span class="hljs-comment"># ceph daemon /var/run/ceph/ceph-osd.0.asok config</span><br>no valid <span class="hljs-built_in">command</span> found; 7 closest matches:<br>config <span class="hljs-built_in">set</span> &lt;var&gt; &lt;val&gt; [&lt;val&gt;...]<br>config <span class="hljs-built_in">help</span> &#123;&lt;var&gt;&#125;<br>config diff<br>config get &lt;var&gt;<br>config diff get &lt;var&gt;<br>config show<br>config <span class="hljs-built_in">unset</span> &lt;var&gt;<br><br><span class="hljs-comment">#获取全部配置内容</span><br>[root@node29 run]<span class="hljs-comment"># ceph daemon /var/run/ceph/ceph-osd.0.asok config show | head -10</span><br>&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;osd.0&quot;</span>,<br>    <span class="hljs-string">&quot;cluster&quot;</span>: <span class="hljs-string">&quot;ceph&quot;</span>,<br>    <span class="hljs-string">&quot;admin_socket&quot;</span>: <span class="hljs-string">&quot;/var/run/ceph/ceph-osd.0.asok&quot;</span>,<br>    <span class="hljs-string">&quot;admin_socket_mode&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-string">&quot;auth_client_required&quot;</span>: <span class="hljs-string">&quot;cephx&quot;</span>,<br>    <span class="hljs-string">&quot;auth_cluster_required&quot;</span>: <span class="hljs-string">&quot;cephx&quot;</span>,<br>   ......<br>&#125;<br><br><span class="hljs-comment">#获取指定配置内容</span><br>[root@node29 run]<span class="hljs-comment">#  ceph daemon /var/run/ceph/ceph-osd.0.asok config get admin_socket</span><br>&#123;<br>    <span class="hljs-string">&quot;admin_socket&quot;</span>: <span class="hljs-string">&quot;/var/run/ceph/ceph-osd.0.asok&quot;</span><br>&#125;<br><br>[root@node29 run]<span class="hljs-comment"># </span><br><br><span class="hljs-comment">#修改 指定配置内容</span><br>[root@node29 ceph]<span class="hljs-comment"># ceph daemon /var/run/ceph/ceph-osd.0.asok config set &quot;mon_osd_initial_require_min_compat_client&quot; &quot;jewel&quot;</span><br>&#123;<br>    <span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>......<br>[root@node29 ~]<span class="hljs-comment"># ceph daemon /var/run/ceph/ceph-osd.1.asok perf dump | head -n15</span><br>&#123;<br>    <span class="hljs-string">&quot;AsyncMessenger::Worker-0&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;msgr_recv_messages&quot;</span>: 2665895,<br>        <span class="hljs-string">&quot;msgr_send_messages&quot;</span>: 2665927,<br>        <span class="hljs-string">&quot;msgr_recv_bytes&quot;</span>: 853128095,<br>        <span class="hljs-string">&quot;msgr_send_bytes&quot;</span>: 4958397491,<br>        <span class="hljs-string">&quot;msgr_created_connections&quot;</span>: 13,<br>        <span class="hljs-string">&quot;msgr_active_connections&quot;</span>: 2,<br>        <span class="hljs-string">&quot;msgr_running_total_time&quot;</span>: 600.146200311,<br>        <span class="hljs-string">&quot;msgr_running_send_time&quot;</span>: 223.453728410,<br>        <span class="hljs-string">&quot;msgr_running_recv_time&quot;</span>: 152.217070353,<br>        <span class="hljs-string">&quot;msgr_running_fast_dispatch_time&quot;</span>: 77.218817120<br>    &#125;,<br><br></code></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>ceph daemon 后面跟的文件路径一定要为绝对路径</li><li>使用 admin sokcet修改参数，不一定马上生效，还需要结合实际情况分析</li></ul><h3 id="admin-socket启动整体流程"><a href="#admin-socket启动整体流程" class="headerlink" title="admin socket启动整体流程"></a>admin socket启动整体流程</h3><p>admin socket 大致的启动流程</p><p><img src="http://img.rui.vin/202208302123194.png" alt="image-20220830212314969"></p><p>admin socket  执行命令流程</p><p><img src="http://img.rui.vin/202208302123688.png" alt="image-20220830212347528"></p><h3 id="AdminSocket-类"><a href="#AdminSocket-类" class="headerlink" title="AdminSocket 类"></a><strong>AdminSocket</strong> 类</h3><p>在代码中   admin socket和 <strong>AdminSocket</strong> 类有关系，在一开始初始化 CephContext （ceph的上下文）时候，就已经 new 出  AdminSocket类的实例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++">CephContext::<span class="hljs-built_in">CephContext</span>(<span class="hljs-type">uint32_t</span> module_type_,<br>                         <span class="hljs-keyword">enum</span> <span class="hljs-type">code_environment_t</span> code_env,<br>                         <span class="hljs-type">int</span> init_flags_)&#123;<br>                         <br><span class="hljs-comment">//  ..............</span><br>  _admin_socket = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AdminSocket</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">// ...............</span><br>  _admin_hook = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CephContextHook</span>(<span class="hljs-keyword">this</span>);<br><span class="hljs-comment">// 并添加了几个命令</span><br>  _admin_socket-&gt;<span class="hljs-built_in">register_command</span>(<span class="hljs-string">&quot;assert&quot;</span>, <span class="hljs-string">&quot;assert&quot;</span>, _admin_hook, <span class="hljs-string">&quot;&quot;</span>);<br>  _admin_socket-&gt;<span class="hljs-built_in">register_command</span>(<span class="hljs-string">&quot;abort&quot;</span>, <span class="hljs-string">&quot;abort&quot;</span>, _admin_hook, <span class="hljs-string">&quot;&quot;</span>);<br>  _admin_socket-&gt;<span class="hljs-built_in">register_command</span>(<span class="hljs-string">&quot;perfcounters_dump&quot;</span>, <span class="hljs-string">&quot;perfcounters_dump&quot;</span>, _admin_hook, <span class="hljs-string">&quot;&quot;</span>);<br>  _admin_socket-&gt;<span class="hljs-built_in">register_command</span>(<span class="hljs-string">&quot;config show&quot;</span>, <span class="hljs-string">&quot;config show&quot;</span>, _admin_hook, <span class="hljs-string">&quot;dump current config settings&quot;</span>);<br><br><span class="hljs-comment">//  ..............</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从 <strong>register_command</strong> 的参数可以推断出 是添加命令并注册命令对应的回调函数，这里结合代码概述下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//先看参数类型</span><br><span class="hljs-comment">//string_view 是和有着string一样功能，但没有涉及内存的额外分配（c++17特性）</span><br><span class="hljs-comment">// AdminSocketHook 也是一个类， call 是纯虚函数，说明肯定有某个类继承并重写 call</span><br><span class="hljs-comment">// hook后续会单独分析 </span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdminSocketHook</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">call</span><span class="hljs-params">(std::string_view command, <span class="hljs-type">const</span> <span class="hljs-type">cmdmap_t</span>&amp; cmdmap,</span></span><br><span class="hljs-params"><span class="hljs-function">    std::string_view format, bufferlist&amp; out)</span> </span>= <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">AdminSocketHook</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">AdminSocket::register_command</span><span class="hljs-params">(std::string_view command,</span></span><br><span class="hljs-params"><span class="hljs-function">  std::string_view cmddesc,</span></span><br><span class="hljs-params"><span class="hljs-function">  AdminSocketHook *hook,</span></span><br><span class="hljs-params"><span class="hljs-function">  std::string_view help)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> ret;<br>  <span class="hljs-function">std::unique_lock <span class="hljs-title">l</span><span class="hljs-params">(lock)</span></span>;<br><span class="hljs-comment">// hooks 是AdminSocket 类里的一个 map，用来存命令的</span><br><span class="hljs-comment">// std::map&lt;std::string, hook_info, std::less&lt;&gt;&gt; hooks;</span><br><span class="hljs-comment">// hook_info 是一个包含函数的结构体</span><br><span class="hljs-comment">// 首先在 map中查有无 相对应的命令</span><br>  <span class="hljs-keyword">auto</span> i = hooks.<span class="hljs-built_in">find</span>(command); <br>  <span class="hljs-keyword">if</span> (i != hooks.<span class="hljs-built_in">cend</span>()) &#123;<br>    <span class="hljs-built_in">ldout</span>(m_cct, <span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">&quot;register_command &quot;</span> &lt;&lt; command &lt;&lt; <span class="hljs-string">&quot; hook &quot;</span> &lt;&lt; hook<br>    &lt;&lt; <span class="hljs-string">&quot; EEXIST&quot;</span> &lt;&lt; dendl;<br>    ret = -EEXIST;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">ldout</span>(m_cct, <span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">&quot;register_command &quot;</span> &lt;&lt; command &lt;&lt; <span class="hljs-string">&quot; hook &quot;</span> &lt;&lt; hook<br>    &lt;&lt; dendl;<br>    <span class="hljs-comment">//  加入 将 命令和对应的AdminSocketHook加入 是AdminSocket中</span><br>    hooks.<span class="hljs-built_in">emplace_hint</span>(i,<br>       std::piecewise_construct,<br>       std::forward_as_tuple(command),<br>       std::forward_as_tuple(hook, cmddesc, help));<br>    ret = <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="admin-socket-启动流程"><a href="#admin-socket-启动流程" class="headerlink" title="admin socket 启动流程"></a>admin socket 启动流程</h3><p>一开始就提到过 用户是通过socket来获取ceph中配置信息的，那肯定是有初始化流程，结合代码看看其启动流程</p><p>有一个函数在 ceph_osd 模块中出现了很多次 <strong>common_init_finish</strong> （出现了七次），<br><img src="http://img.rui.vin/202208301019731.png" alt="image-20220829233025193"></p><p>但其实跳转进去看，最多会执行一次，因为里面有个标志位；这个函数 主要是启动日志服务线程和 admin socket的服务线程，而多次调用是我猜是确保服务线程启动；<br><img src="http://img.rui.vin/202208301020249.png" alt="image-20220829233801487" style="zoom:80%;"></p><p>最终在 里看到 <strong>AdminSocket</strong> 的init函数</p><p><img src="http://img.rui.vin/202208301020654.png" alt="image-20220830002333423"></p><p>AdminSocket::init 函数主要是启动 AdminSocket 线程，既然是启了线程，这个线程应该是 osd 的守护进程启动的，在系统看 果然是有 admin_socket；<br><img src="http://img.rui.vin/202208301020621.png" alt="image-20220830003109748"></p><h4 id="AdminSocket-init"><a href="#AdminSocket-init" class="headerlink" title="AdminSocket::init"></a>AdminSocket::init</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码有点多，只留关键的代码</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AdminSocket::init</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; path)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">hrp</span>(<span class="hljs-string">&quot;admin socket 初始化&quot;</span>)<br>  <span class="hljs-comment">/* Set up things for the new thread */</span><br>  std::string err;<br>  <span class="hljs-type">int</span> pipe_rd = <span class="hljs-number">-1</span>, pipe_wr = <span class="hljs-number">-1</span>;<br>  err = <span class="hljs-built_in">create_shutdown_pipe</span>(&amp;pipe_rd, &amp;pipe_wr);<br><br>  <span class="hljs-comment">/* Create socket */</span><br>  <span class="hljs-type">int</span> sock_fd;<br>  err = <span class="hljs-built_in">bind_and_listen</span>(path, &amp;sock_fd);<br><br><br>  <span class="hljs-comment">/* Create new thread */</span><br>  m_sock_fd = sock_fd;<br>  m_shutdown_rd_fd = pipe_rd;<br>  m_shutdown_wr_fd = pipe_wr;<br>  m_path = path;<br>  <span class="hljs-built_in">hrp</span>(m_path);<br>  version_hook = std::<span class="hljs-built_in">make_unique</span>&lt;VersionHook&gt;();<br>  <span class="hljs-built_in">register_command</span>(<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>, version_hook.<span class="hljs-built_in">get</span>(), <span class="hljs-string">&quot;&quot;</span>);<br>  .....<br><br>  th = <span class="hljs-built_in">make_named_thread</span>(<span class="hljs-string">&quot;admin_socket&quot;</span>, &amp;AdminSocket::entry, <span class="hljs-keyword">this</span>);<br>  <span class="hljs-built_in">add_cleanup_file</span>(m_path.<span class="hljs-built_in">c_str</span>());<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从  AdminSocket::init 可以看的，主要有 三个部分组成，创建 pipe、socket，以及启动 线程</p><p><strong>AdminSocket::create_shutdown_pipe</strong><br>创建一个管道，在注释中可以了解到，线程会监听 读管道，当这有有数据的时候，会<strong>优雅</strong>的将线程 kill 掉，其实从名字也会可以推测出  <strong>创建 shutdown 管道</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">AdminSocket::create_shutdown_pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> *pipe_rd, <span class="hljs-type">int</span> *pipe_wr)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> pipefd[<span class="hljs-number">2</span>];<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">pipe_cloexec</span>(pipefd) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-type">int</span> e = errno;<br>    ostringstream oss;<br>    oss &lt;&lt; <span class="hljs-string">&quot;AdminSocket::create_shutdown_pipe error: &quot;</span> &lt;&lt; <span class="hljs-built_in">cpp_strerror</span>(e);<br>    <span class="hljs-keyword">return</span> oss.<span class="hljs-built_in">str</span>();<br>  &#125;<br>  <br>  *pipe_rd = pipefd[<span class="hljs-number">0</span>];<br>  *pipe_wr = pipefd[<span class="hljs-number">1</span>];<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="bind-and-listen-path-amp-sock-fd"><a href="#bind-and-listen-path-amp-sock-fd" class="headerlink" title="bind_and_listen(path, &amp;sock_fd);"></a>bind_and_listen(path, &amp;sock_fd);</h4><p>函数主要工作是生成 socket，但这里的socket是单机版的socket( <strong>UNI Domian Socket</strong> )，和以前接触网络socket 不相同，不同之处如下所示（这也说明为什么<strong>ceph  daemon 后面要加个 asok文件</strong>！）<br><img src="http://img.rui.vin/202208301119157.png" alt="image-20220829175922827"></p><p>从 bind_and_listen 也可以看出确实是 用sockaddr_un 结构体，其实网络socket也是可以实现的（地址回环），那为什么用 <strong>UNI Domian Socket</strong> 呢？</p><blockquote><p>  <strong>当我们使用 admin socket 读取或修改ceph 配置时候，都是需要在对应节点主机上操作，假如说ceph 集群中有 A、B、C三个几点，各自部署了 osd，A节点不能直接修改 B节点的osd配置（远程过去也行…），因为 那个 asok文件并不在A节点上，现在这些操作都是在同一台主机上，相当于 IPC（进程间通信），UNIX Domain Socket是不需要 经过网络协议栈，只需要将 应用层数据从一个进程拷贝到另一个进程</strong>,<strong>这样效率比较高</strong></p></blockquote><p><img src="http://img.rui.vin/202208301118275.png" alt="image-20220830111830154"></p><p>接下来步骤就是 bind 和 listen 了，和 网络socket建立没多大区别….<br>一个 socket 只能bind一次， 在 <strong>UNI Domian Socket</strong>  调用bind的时候，会根据 address 给出的路径生成 socket文件</p><h4 id="start-thread"><a href="#start-thread" class="headerlink" title="start  thread"></a>start  thread</h4><p>启动线程用来监听socket </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-comment">/* Create new thread */</span><br><span class="hljs-comment">// 将上生成的 fd 保存到 类成员中</span><br>  m_sock_fd = sock_fd;<br>  m_shutdown_rd_fd = pipe_rd;<br>  m_shutdown_wr_fd = pipe_wr;<br><span class="hljs-comment">//这里path 是  asok文件路径</span><br>  m_path = path;<br>  <span class="hljs-built_in">hrp</span>(m_path);<br><span class="hljs-comment">//VersionHook 继承了 AdminSocketHook 并实现 call接口 </span><br>  version_hook = std::<span class="hljs-built_in">make_unique</span>&lt;VersionHook&gt;();<br>  <span class="hljs-built_in">register_command</span>(<span class="hljs-string">&quot;0&quot;</span>, <span class="hljs-string">&quot;0&quot;</span>, version_hook.<span class="hljs-built_in">get</span>(), <span class="hljs-string">&quot;&quot;</span>);<br>  <span class="hljs-built_in">register_command</span>(<span class="hljs-string">&quot;version&quot;</span>, <span class="hljs-string">&quot;version&quot;</span>, version_hook.<span class="hljs-built_in">get</span>(), <span class="hljs-string">&quot;get ceph version&quot;</span>);<br>  <span class="hljs-built_in">register_command</span>(<span class="hljs-string">&quot;git_version&quot;</span>, <span class="hljs-string">&quot;git_version&quot;</span>, version_hook.<span class="hljs-built_in">get</span>(),<br>   <span class="hljs-string">&quot;get git sha1&quot;</span>);<br><br><span class="hljs-comment">//help_hook 也继承了 AdminSocketHook 并实现 call接口 </span><br>  help_hook = std::<span class="hljs-built_in">make_unique</span>&lt;HelpHook&gt;(<span class="hljs-keyword">this</span>);<br>  <span class="hljs-built_in">register_command</span>(<span class="hljs-string">&quot;help&quot;</span>, <span class="hljs-string">&quot;help&quot;</span>, help_hook.<span class="hljs-built_in">get</span>(),<br>   <span class="hljs-string">&quot;list available commands&quot;</span>);<br><span class="hljs-comment">//同上， 这里可以出 针对不同的命令，用不同的类进行call 重写</span><br>  getdescs_hook = std::<span class="hljs-built_in">make_unique</span>&lt;GetdescsHook&gt;(<span class="hljs-keyword">this</span>);<br>  <span class="hljs-built_in">register_command</span>(<span class="hljs-string">&quot;get_command_descriptions&quot;</span>, <span class="hljs-string">&quot;get_command_descriptions&quot;</span>,<br>   getdescs_hook.<span class="hljs-built_in">get</span>(), <span class="hljs-string">&quot;list available commands&quot;</span>);<br><br><br><span class="hljs-comment">// 最后启动线程</span><br><span class="hljs-comment">// 函数设置了 线程名字，和线程启动时调用的函数 &amp;AdminSocket::entry</span><br>  th = <span class="hljs-built_in">make_named_thread</span>(<span class="hljs-string">&quot;admin_socket&quot;</span>, &amp;AdminSocket::entry, <span class="hljs-keyword">this</span>);<br>  <span class="hljs-built_in">add_cleanup_file</span>(m_path.<span class="hljs-built_in">c_str</span>());<br><br><br></code></pre></td></tr></table></figure><h4 id="AdminSocket-entry"><a href="#AdminSocket-entry" class="headerlink" title="AdminSocket::entry"></a>AdminSocket::entry</h4><p>admin_socket 线程运行的函数，和常规写法一样用一个 while循环，里面用 poll 来检测两个 m_sock_fd，和 m_shutdown_rd_fd（就是最初创建 pipe那个 ）的事件响应。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AdminSocket::entry</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>.....<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">pollfd</span> fds[<span class="hljs-number">2</span>];<br>    fds[<span class="hljs-number">0</span>].fd = m_sock_fd;<br>    fds[<span class="hljs-number">0</span>].events = POLLIN | POLLRDBAND;<br>    fds[<span class="hljs-number">1</span>].fd = m_shutdown_rd_fd;<br>    fds[<span class="hljs-number">1</span>].events = POLLIN | POLLRDBAND;<br><br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">poll</span>(fds, <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-type">int</span> err = errno;<br>      <span class="hljs-keyword">if</span> (err == EINTR) &#123;<br><span class="hljs-keyword">continue</span>;<br>      &#125;<br>      <span class="hljs-built_in">lderr</span>(m_cct) &lt;&lt; <span class="hljs-string">&quot;AdminSocket: poll(2) error: &#x27;&quot;</span><br>   &lt;&lt; <span class="hljs-built_in">cpp_strerror</span>(err) &lt;&lt; dendl;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (fds[<span class="hljs-number">0</span>].revents &amp; POLLIN) &#123;<br>      <span class="hljs-comment">// Send out some data</span><br>      <span class="hljs-built_in">do_accept</span>();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (fds[<span class="hljs-number">1</span>].revents &amp; POLLIN) &#123;<br>      <span class="hljs-comment">// Parent wants us to shut down</span><br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">ldout</span>(m_cct, <span class="hljs-number">5</span>) &lt;&lt; <span class="hljs-string">&quot;entry exit&quot;</span> &lt;&lt; dendl;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="AdminSocket-do-accept"><a href="#AdminSocket-do-accept" class="headerlink" title="AdminSocket::do_accept()"></a>AdminSocket::do_accept()</h4><p>当 m_sock_fd 有时间响应时候，会执行  do_accept();  看函数名应该是 对收到的数据做些处理</p><p>accept 返回一个 fd，这里是用while <strong>逐个字符读取</strong> 客户端传来的命令</p><p><img src="http://img.rui.vin/202208301706126.png" alt="image-20220830170649879"></p><p>while里面做了些处理，结合日志，可以看到最终读出来的格式是字符串是 json 格式的</p><p><img src="http://img.rui.vin/202208301709774.png" alt="image-20220830170949647"></p><p>最后字符传到 execute_command 函数中</p><p><img src="http://img.rui.vin/202208301748216.png" alt="image-20220830174834047"></p><p>现在 知道传进来的字符串 c 是一条 json字符串， 在 execute_command 函数中，会将 json解析到map中（目的是 提取value）<br><img src="http://img.rui.vin/202208301753499.png" alt="image-20220830175309370"></p><p>接下来是从 map中获取我们需要的 命令, 假如说  c是  <strong>{“prefix”,”config show”}</strong> ，那么 <strong>match为   config show</strong><br><img src="http://img.rui.vin/202208301754147.png" alt="image-20220830175420009"></p><p>在文章的 整体流程部分提到了 ，cct初始化时，会注册一些函数到 hooks 中 ，现在就通过 传进来的参数在 hooks中查找对应的回调，hooks也是一个map</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::unique_lock <span class="hljs-title">l</span><span class="hljs-params">(lock)</span></span>;<br><span class="hljs-comment">// 创建一个 hooks类型的 变量 </span><br>  <span class="hljs-keyword">decltype</span>(hooks)::iterator p; <br><span class="hljs-comment">// match 为参数命令</span><br>  <span class="hljs-keyword">while</span> (match.<span class="hljs-built_in">size</span>()) &#123;<br>    p = hooks.<span class="hljs-built_in">find</span>(match);<br>    <span class="hljs-keyword">if</span> (p != hooks.<span class="hljs-built_in">cend</span>())<br>      <span class="hljs-keyword">break</span>;<br><br>    <span class="hljs-comment">// drop right-most word</span><br>    <span class="hljs-type">size_t</span> pos = match.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br>    <span class="hljs-keyword">if</span> (pos == std::string::npos) &#123;<br>      match.<span class="hljs-built_in">clear</span>();  <span class="hljs-comment">// we fail</span><br>      <span class="hljs-keyword">break</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      match.<span class="hljs-built_in">resize</span>(pos);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (p == hooks.<span class="hljs-built_in">cend</span>()) &#123;<br>    <span class="hljs-built_in">lderr</span>(m_cct) &lt;&lt; <span class="hljs-string">&quot;AdminSocket: request &#x27;&quot;</span> &lt;&lt; cmd &lt;&lt; <span class="hljs-string">&quot;&#x27; not defined&quot;</span> &lt;&lt; dendl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  string args;<br>  <span class="hljs-keyword">if</span> (match != cmd) &#123;<br>    args = cmd.<span class="hljs-built_in">substr</span>(match.<span class="hljs-built_in">length</span>() + <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// Drop lock to avoid cycles in cases where the hook takes</span><br>  <span class="hljs-comment">// the same lock that was held during calls to register/unregister,</span><br>  <span class="hljs-comment">// and set in_hook to allow unregister to wait for us before</span><br>  <span class="hljs-comment">// removing this hook.</span><br>  in_hook = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// p的key是 string， value是 struct hook_info，这个结构体包含了 hook</span><br>  <span class="hljs-keyword">auto</span> match_hook = p-&gt;second.hook;<br>  l.<span class="hljs-built_in">unlock</span>();<br><span class="hljs-comment">// match_hook 是 AdminSocketHook类 可以执行 call，也就是一开始注册的函数</span><br>  <span class="hljs-type">bool</span> success = (<span class="hljs-built_in">validate</span>(match, cmdmap, out) &amp;&amp;<br>      match_hook-&gt;<span class="hljs-built_in">call</span>(match, cmdmap, format, out));<br>  l.<span class="hljs-built_in">lock</span>();<br>  in_hook = <span class="hljs-literal">false</span>;<br>  in_hook_cond.<span class="hljs-built_in">notify_all</span>();<br></code></pre></td></tr></table></figure><p>执行完 注册的函数后，其输出的内容保存在 <strong>bufferlist类型的 out</strong>中,最后写入 到新建连接的 connection_fd中<br><img src="http://img.rui.vin/202208302008166.png" alt="image-20220830200816019"></p><h3 id="客户端-如何发起连接和读数据的"><a href="#客户端-如何发起连接和读数据的" class="headerlink" title="客户端 如何发起连接和读数据的"></a>客户端 如何发起连接和读数据的</h3><p>当我们输入 ceph daemon 的时候，首先会先解析命令，ceph daemon 命令首先 会在<strong>ceph.in</strong> 中的函数<strong>maybe_daemon_command</strong> 被解析：</p><p><img src="http://img.rui.vin/202209120900773.png" alt="image-20220912085729817"></p><p>如果命令解析正确，最后会执行   admin_socket 函数<br><img src="http://img.rui.vin/202209120901934.png" alt="image-20220912090124891">  </p><p> admin_socket 函数 在 ceph_daemon.py 文件里<br><img src="http://img.rui.vin/202209120903174.png" alt="image-20220912090349117"></p><p>在  admin_socket 函数中有个关键的函数 <strong>do_sockio</strong> 用于发起连接，并发送命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"> <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">do_sockio</span>(<span class="hljs-params">path, cmd_bytes</span>):<br>    <span class="hljs-string">&quot;&quot;&quot; helper: do all the actual low-level stream I/O &quot;&quot;&quot;</span><br>    <span class="hljs-comment">#发起连接，connect的参数是 path，也就是 socket文件路径</span><br>    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)<br>    sock.connect(path)<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 发送数据，即解析好的参数</span><br>        sock.sendall(cmd_bytes + <span class="hljs-string">b&#x27;\0&#x27;</span>)<br>        len_str = sock.recv(<span class="hljs-number">4</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(len_str) &lt; <span class="hljs-number">4</span>:<br>            <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&quot;no data returned from admin socket&quot;</span>)<br>        l, = struct.unpack(<span class="hljs-string">&quot;&gt;I&quot;</span>, len_str)<br>        sock_ret = <span class="hljs-string">b&#x27;&#x27;</span><br>        <span class="hljs-comment"># 读取数据</span><br>        got = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> got &lt; l:<br>            <span class="hljs-comment"># recv() receives signed int, i.e max 2GB</span><br>            <span class="hljs-comment"># workaround by capping READ_CHUNK_SIZE per call.</span><br>            want = <span class="hljs-built_in">min</span>(l - got, READ_CHUNK_SIZE)<br>            bit = sock.recv(want)<br>            sock_ret += bit<br>            got += <span class="hljs-built_in">len</span>(bit)<br><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> sock_e:<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;exception: &#x27;</span> + <span class="hljs-built_in">str</span>(sock_e))<br>    <span class="hljs-keyword">return</span> sock_ret<br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#命令 执行流程</span><br><span class="hljs-comment">#先获取命令集合 </span><br>    <span class="hljs-keyword">try</span>:<br>        cmd_json = do_sockio(asok_path,<br>                             <span class="hljs-string">b&#x27;&#123;&quot;prefix&quot;: &quot;get_command_descriptions&quot;&#125;&#x27;</span>)<br>        <br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;exception getting command descriptions: &#x27;</span> + <span class="hljs-built_in">str</span>(e))<br><br><span class="hljs-comment"># cmd和get_command_descriptions一样说明只是获取帮助</span><br>    <span class="hljs-keyword">if</span> cmd == <span class="hljs-string">&#x27;get_command_descriptions&#x27;</span>:<br>        <span class="hljs-keyword">return</span> cmd_json<br><br><span class="hljs-comment"># 将命令集合 解析成字典</span><br>    sigdict = parse_json_funcsigs(cmd_json.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), <span class="hljs-string">&#x27;cli&#x27;</span>)<br><span class="hljs-comment">#查找对应的命令</span><br>    valid_dict = validate_command(sigdict, cmd)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> valid_dict:<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;invalid command&#x27;</span>)<br>    <br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">format</span>:<br>        valid_dict[<span class="hljs-string">&#x27;format&#x27;</span>] = <span class="hljs-built_in">format</span><br><span class="hljs-comment"># 在字典中查找到相应的命令，则调用 do_sockio</span><br>    <span class="hljs-keyword">try</span>:<br>        ret = do_sockio(asok_path, json.dumps(valid_dict).encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">raise</span> RuntimeError(<span class="hljs-string">&#x27;exception: &#x27;</span> + <span class="hljs-built_in">str</span>(e))<br>    <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><p>返回的结果最后写到终端上<br><img src="http://img.rui.vin/202209120945067.png" alt="image-20220912094553017"><img src="http://img.rui.vin/202209120946937.png"></p><h3 id="执行对应的函数"><a href="#执行对应的函数" class="headerlink" title="执行对应的函数"></a>执行对应的函数</h3><p>以上，一个命令执行的整体流程就结束了，结合一个命令分析并做一个总结</p><p>比如说 config命令，注册时候 command 为 config show，命令描述也是，回调类是  **CephContextHook *_admin_hook**，最后一个参数信息是帮助信息</p><p><img src="http://img.rui.vin/202208302027724.png" alt="image-20220830202731573"></p><p>和  类重写父类的 call，最终调用的 do_comand 函数</p><p><img src="/C:/Users/h00165/AppData/Roaming/Typora/typora-user-images/image-20220830203152555.png" alt="image-20220830203152555"></p><p>do_comand 里面一大推 if-else 做字符串匹配<br><img src="http://img.rui.vin/202208302034718.png" alt="image-20220830203445568"></p><h4 id="show-config"><a href="#show-config" class="headerlink" title="_show_config"></a>_show_config</h4><p>最终调用了 <strong>_show_config</strong>函数<br><img src="http://img.rui.vin/202208302048867.png" alt="image-20220830204814705"></p><p>从上图可以看出，有些 参数是保存到Formatter *f中，Formatter可以理解为 是一种格式化流；最后执行完回到 do_commad 函数，会将 格式化好的数据刷新到到 out 中<img src="http://img.rui.vin/202208302052742.png" alt="image-20220830205231570"></p><p>这里做个测试 ： 我在   _show_config 中添加些内容，看下打印的结果怎样<br><img src="http://img.rui.vin/202208302056348.png" alt="image-20220830205633149"></p><h2 id="自定义一个hook"><a href="#自定义一个hook" class="headerlink" title="自定义一个hook"></a>自定义一个hook</h2><p>尝试自己注册一个命令，这里回调函数还是 和show config 相同，添加了if 语句</p><p><img src="http://img.rui.vin/202208302115559.png" alt="image-20220830211514358"></p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>ceph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一致性哈希的简单理解</title>
    <link href="/2022/08/04/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    <url>/2022/08/04/%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C/</url>
    
    <content type="html"><![CDATA[<p>什么是一致性哈希</p><blockquote><p>  一致性hash算法，是麻省理工学院1997年提出的一种算法，目前主要应用于分布式缓存当中。<br>  一致性hash算法可以有效地解决分布式存储结构下动态增加和删除节点所带来的问题。</p></blockquote><h3 id="传统hash"><a href="#传统hash" class="headerlink" title="传统hash"></a>传统hash</h3><p>假如现在有三台服务器用作图片缓存，如何使用大量的图片均衡的分布在服务器上呢，如果有30万张图片，最理想的是每个服务器都负载10万张图片；使用传统hash可以对文件名进行hash（假设文件名字都不相同），得到的结果按服务器个数取模，这样做可以尽可能做到均衡；但是这有个弊端，就是服务器动态增删的事，会产生很大问题；现在有三台服务器 node1 ，node2，node3；其中node1故障，那么现在要改变映射（理论上后台会重新构建），这一时刻，命中node1的缓存是不可以使用了，需要重新hash，同理增加一台服务器也是如此，因为是对服务器数量取模，前的hash映射都会失效，无法动态调整，此时也需要重新取模，会涉及全部数据；</p><img src="http://imt.rui.vin/202208281113268.png" alt="image-20220726112919046" style="zoom:50%;">    <h3 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h3><p>而一致性hash在普通hash功能之上，解决动态增加和删除节点带来的问题（牵一发而动全身）</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><strong>实现原理</strong></h3><p>一致性哈希算法通过一个叫作一致性哈希环的数据结构实现。这个环的起点是 0，终点是 2^32 - 1，并且起点与终点连接，故这个环的整数分布范围是 [0, 2^32-1]<br>第一步： 固定好节点位置，也是hash取模，可以节点ip或者节点名称取模，即 hash(ip)%  2^32 - 1，既可以固定好节点位置；</p><img src="http://imt.rui.vin/202208281113157.png" alt="image-20220726114429945" style="zoom:50%;">     <p>第二部： 接下来和普通hash一样，hash的值对2^32 - 1取模，找哈希环的位置然后顺时针寻找节点，找到的第一个节点则就是要存放数据的节点如下图， key-1 找到节点A，key-2找到节点B以此类推….</p><img src="http://imt.rui.vin/202208281113228.png" alt="cke_136.png" style="zoom:50%;">        <p>如果增加一个节点，并不会影响全局，只会影响局部的映射，如增加了节点D，影响的只有key-2，其他的key不影响，删除的也是如此</p><img src="http://imt.rui.vin/202208281113159.png" alt="image-20220726115038487" style="zoom:50%;">    <h4 id="有什么缺陷"><a href="#有什么缺陷" class="headerlink" title="有什么缺陷"></a><strong>有什么缺陷</strong></h4><p>但是有个问题：在第一步的时候，节点定位分布到比较集中（节点数比较少也不是不可能）如下图，节点A承载了大量的数据， 如果过节点蹦了，大量的数据会迁移到节点B，这样会导致节点B的压力增大，可能会造成雪崩效应。<br><img src="http://imt.rui.vin/202208281113215.png" alt="image-20220726115316385" style="zoom:50%;"></p><p><strong>解决的方法</strong>可以在第一步时候添加虚拟节点，不使用真实的节点，比如节点A可以由多个节点映射，保证节点的均衡性，如下图所示，真实的A节点用虚拟节点A-01 A-02 A-03来取代，B，C同理。<br><img src="http://imt.rui.vin/202208281113174.png" alt="image-20220726151408066" style="zoom:45%;"> </p>]]></content>
    
    
    
    <tags>
      
      <tag>分布式基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ceph中的 weight</title>
    <link href="/2022/08/03/ceph%E4%B8%ADweight/"/>
    <url>/2022/08/03/ceph%E4%B8%ADweight/</url>
    
    <content type="html"><![CDATA[<p>最近在群里讨论 crush weight的问题，什么是 crush weight？这两天都只是部署安装，还没了解这个，在osd tree中是可以看到 weight，如下图，有weight 和 reweight。前者我知道是对应osd （磁盘）容量，后者呢？这个reweight有什么？这几个问题网上几乎是千篇一律，说是 weight会改变 它影响PG的到OSD的映射关系？是为什么呢？而且还有一个问题，Ceph osd weight与ceph osd crush weight 这两个命令之间又有什么区别？</p> <img src="http://img.rui.vin/202208071417007.png" alt="image-20220730012445791" style="zoom:80%;"><p>先说下几个知识点</p><ul><li><p>CRUSH 层级结构</p><p>假如一个数据中心里面有很多个机房，机房里面又有很多机柜，机柜里面又有很多服务器，服务器又可以挂载很多磁盘，层层递进就像是多叉树一样，前面所说的 基础设备，在ceph中统称为 <strong>故障域</strong>或者<strong>CRUSH bucket</strong> ，这里的 bucket 就是桶的意思，如在机房room0里面就是一个桶，桶里面装的时候rack0，rack1，rack2，rack0也是个bucket，这个bucket里面装的是host，以此类推，但是osd并不是桶，在这个层级结构中osd是最小的单位 ；这些bucket 表明了设备的位置，此外 ceph在管理这种大型分级存储网络，会将这些  基础设备 用crush map映射起来形成一个嵌套层次的结构如下图</p><img src="http://img.rui.vin/202208071417723.png" alt="image-20220731001442177" style="zoom:67%;"><p>在 ceph 的命令 也可以看到设备对应的层级结构</p><img src="/C:/Users\h00165\AppData\Roaming\Typora\typora-user-images\image-20220730012445791.png" alt="image-20220730012445791" style="zoom: 70%;"></li><li><p>crush rule</p><p>从 crush map知道了数据可以放在哪里，数据应该怎么放呢，这也是有对应的规则的，ceph客户端如何去选bucket，以及到最后的osd，选择那个osd作为主osd，那个作为辅助osd ；如果我想 把将热数据存放于SSD中，而将冷数据放在HDD中，这也可以设定相关的规则，crush 算法会根据相应的规则去调整，接下来看下ceph 中的规则是怎样的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># getcrushmap 获取CRUSH map，这个输出是编译后的，人不看不了，需要反编译下</span><br>[root@node29 ceph]<span class="hljs-comment"># ceph osd getcrushmap -o crushmap.bin</span><br>33<br><span class="hljs-comment">#crushtool -d 反编译</span><br>[root@node29 ceph]<span class="hljs-comment"># crushtool -d crushmap.bin -o crushmap.txt</span><br><br><span class="hljs-comment">#这里面有map 中 每个bucket的详细情况 </span><br><span class="hljs-comment"># 如 node29  和  root,参照上一张图片的 osd tree</span><br><span class="hljs-comment"># buckets</span><br>host node29 &#123;<br><span class="hljs-built_in">id</span> -3<span class="hljs-comment"># do not change unnecessarily   id为正数说明是osd</span><br><span class="hljs-built_in">id</span> -4 class hdd<span class="hljs-comment"># do not change unnecessarily</span><br><span class="hljs-comment"># weight 0.586</span><br>alg straw2<br><span class="hljs-built_in">hash</span> 0<span class="hljs-comment"># rjenkins1</span><br>item osd.0 weight 0.293<br>item osd.3 weight 0.293<br>&#125;<br>.....<br>root default &#123;<br><span class="hljs-built_in">id</span> -1<span class="hljs-comment"># do not change unnecessarily</span><br><span class="hljs-built_in">id</span> -2 class hdd<span class="hljs-comment"># do not change unnecessarily</span><br><span class="hljs-comment"># weight 1.177       #这的weight是 item weight的总和  </span><br>alg straw2  <span class="hljs-comment">#每个bucket选择item时都有指定算法，这里用的是 straw2算法</span><br><span class="hljs-built_in">hash</span> 0<span class="hljs-comment"># rjenkins1</span><br><span class="hljs-comment"># bucket 里面的item， 按照层级关系 </span><br>item rack01 weight 0.586<br>item rack02 weight 0.298<br>item rack03 weight 0.293<br>&#125;<br><br><span class="hljs-comment">#最后是rules</span><br><span class="hljs-comment"># rules</span><br>rule replicated_rule &#123;<br><span class="hljs-built_in">id</span> 0  <span class="hljs-comment">#rule 的编号</span><br><span class="hljs-built_in">type</span> replicated   <span class="hljs-comment"># pool的类型   多副本还是EC</span><br>min_size 1    <span class="hljs-comment">#pool的最小副本数</span><br>max_size 10   <span class="hljs-comment">#pool 的最大副本数</span><br>step take default   <span class="hljs-comment"># bucket的入口点， default 是bucket root的名称  </span><br>step chooseleaf firstn 0 <span class="hljs-built_in">type</span> host  <span class="hljs-comment"># fistst 算法，返回 osd位置</span><br>step emit<br>&#125;<br><br></code></pre></td></tr></table></figure><p>rule中有三个 <strong>setp</strong></p><ol><li>take 从crush map选定编号（选定特定的bucket，示例中 选择的是 root ），作为步骤的开始</li><li>select 从输入的bucket中选择随机选择指定类型 <strong>type</strong> 的item（桶里面的元素），bucket里面有type类型的item，为了尽可能的随机，会使用随机选择算法（有四种），ceph默认是使用 straw2 算法，使用straw2算法，选择item概率都相同，但是会为每一个item计算一个长度，最终会取最长的那个item；计算公式是一个hash值（这个hash值产生与pgid有关系）乘以 item的<strong>weight</strong>（crush weight ），item weight大的元素有较大的概率算出最长的长度，从而更容易被抽中，当达到一点的数量规模，宏观上看是随机的。（straw2算法还有很多细节，这里知识简单概述下）</li><li>emit 将结果返回上一层；</li></ol><p>接下来的crush 算法步骤，这里不在继续讨论，会再另外篇文章 结合源码再来介绍crush 中具体实现算法</p><hr><p>bucket weight是其item weight 的总和，weight是从下往上推的，若是改变osd的weight，osd的上一层bucket weight，会影响cursh 层级，修改 weight 的命令是 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs bash"> <span class="hljs-comment">#ceph osd crush reweight &#123;name&#125; &#123;weight&#125;</span><br> <span class="hljs-comment">#这里修改 osd.0 的weight</span><br>[root@node29 ~]<span class="hljs-comment"># ceph osd tree |grep -E  &quot;WEIGHT|osd.0&quot;</span><br>ID  CLASS WEIGHT  TYPE NAME           STATUS REWEIGHT PRI-AFF <br>  0   hdd 0.29300             osd.0       up  1.00000 1.00000 <br><span class="hljs-comment">#修改之前导出 pg的分布</span><br>[root@node29 ~]<span class="hljs-comment"># ceph pg dump pgs|awk &#x27;&#123;print $1,$17&#125;&#x27; &gt; old</span><br>dumped pgs<br>[root@node29 ~]<span class="hljs-comment"># cat old | head -n 10</span><br>2.0 [1,3,2]<br>3.1 [1,3,2]<br>2.1 [3,2,1]<br>3.0 [1,2,0]<br>2.2 [2,0,1]<br>3.3 [0,2,1]<br>2.3 [3,1,2]<br>3.2 [3,1,2]<br>2.4 [3,1,2]<br>[root@node29 ~]<span class="hljs-comment"># </span><br> <span class="hljs-comment">#现在修改 osd.0 weight   </span><br>    [root@node29 ~]<span class="hljs-comment">#  ceph osd crush reweight osd.0 0.1</span><br>^[[Areweighted item <span class="hljs-built_in">id</span> 0 name <span class="hljs-string">&#x27;osd.0&#x27;</span> to 0.1 <span class="hljs-keyword">in</span> crush map<br>    [root@node29 ~]<span class="hljs-comment"># ceph osd tree |grep -E  &quot;WEIGHT|osd.0&quot;</span><br>ID  CLASS WEIGHT  TYPE NAME           STATUS REWEIGHT PRI-AFF <br>      0   hdd 0.09999             osd.0       up  1.00000 1.00000 <br>[root@node29 ~]<span class="hljs-comment"># ceph pg dump pgs|awk &#x27;&#123;print $1,$17&#125;&#x27; &gt; new</span><br>    dumped pgs<br><br>[root@node29 ~]<span class="hljs-comment"># diff old new  -y -W 30 --suppress-common-lines | head -n 10</span><br>2.0 [1,3,2]   |2.0 [1,2,3]<br>3.0 [1,2,0]   |3.0 [1,2,3]<br>2.2 [2,0,1]   |2.2 [2,3,1]<br>3.4 [2,1,0]   |3.4 [2,1,3]<br>2.6 [3,1,2]   |2.6 [1,0,2]<br>3.6 [1,3,2]   |3.6 [1,0,2]<br>2.8 [0,1,2]   |2.8 [3,1,2]<br>3.9 [3,2,1]   |3.9 [1,3,2]<br>2.a [0,1,2]   |2.a [1,3,2]<br>2.d [2,0,1]   |2.d [2,3,1]<br>[root@node29 ~]<span class="hljs-comment"># diff old new  -y -W 30 --suppress-common-lines |wc -l</span><br>101<br>[root@node29 ~]<span class="hljs-comment"># wc -l old </span><br>259 <br><span class="hljs-comment">#pg在osd分布可以看出， 将osd weight 调小后，选择 osd.0 比较少了，所以调整item权重在step 中select是有影响的</span><br>  <br></code></pre></td></tr></table></figure></li></ul><p>总之我们的目的是，尽最大可能让数据均衡在 osd中，这个均衡并不是说 让每个osd存放的数据尽可能一样多，而是说数据所占的百分比，假如有两个硬盘，容量是100g和300g，如果要均衡，存放数据时，存放比例为 1:3 时才能到达均衡，而 osd reweight 就可以的调节；osd reweight 默认为1 ，其这个过程称为过载测试，算法流程如下：</p><p><img src="http://img.rui.vin/202208071417994.png" alt="image-20220731175714700"></p><p>is_out 则是 选出osd的结果，reweight 调整得越高，那么通过测试的概率越高，通过调节reweight可以使数据分布更加合理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">ceph osd reweight &#123;osd&#125; &#123;reweight&#125;<br>[root@node29 ~]# ceph osd reweight osd.1 0.5<br>reweighted osd.1 to 0.5 (8000)<br>[root@node29 ~]# ceph osd tree |grep -E  &quot;WEIGHT|osd.1&quot;<br>ID  CLASS WEIGHT  TYPE NAME           STATUS REWEIGHT PRI-AFF <br>  1   hdd 0.29799             osd.1       up  0.50000 1.00000 <br><span class="hljs-meta prompt_">#</span><span class="language-bash">修改后pg分布也有改变</span><br><br></code></pre></td></tr></table></figure><p>ceh osd weight  是修改 reweight，数值在 [0,1]， 选出osd后，通过 reweight可以进行过载测试<br>ceph osd crush weight 是修改 bucket weight，  这个weight 影响在bucket中选择那个 item起着关键作用</p>]]></content>
    
    
    
    <tags>
      
      <tag>ceph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rgw 部署</title>
    <link href="/2022/08/03/ceph/%5Bceph%5Drgw%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/08/03/ceph/%5Bceph%5Drgw%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p><img src="http://img.rui.vin/image-20220803145842254.png" alt="image-20220803145842254">\</p><h2 id="what-rgw"><a href="#what-rgw" class="headerlink" title="what rgw"></a>what rgw</h2><blockquote><p>  RGW（Rados GateWay)  对象存储网关，ceph 是分布式对象系统，完全是可以做对象存储的，然而 Rados提供的是私有接口，不符合市场趋势，因为对象存储狭义上说是 云存储（互联网应用），所以接口应该支持主流网络协议，如http；ceph为了支持 http协议访问，设计了RGW存储网关，提供接口，此外还兼容云存储领域较为主流的接口  如 S3，Swift。</p></blockquote><h2 id="创建-rgw的keyring"><a href="#创建-rgw的keyring" class="headerlink" title="创建 rgw的keyring"></a>创建 rgw的keyring</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 每添加一个 功能节点都需要  创建一个 keyring</span><br>[root@node29 ~]<span class="hljs-comment"># ceph-authtool --create-keyring /etc/ceph/ceph.client.radosgw.keyring </span><br>creating /etc/ceph/ceph.client.radosgw.keyring<br><br>[root@node29 ceph]<span class="hljs-comment"># ls/etc/ceph</span><br>ceph.client.admin.keyring  ceph.client.radosgw.keyring  ceph.conf<br><span class="hljs-comment">#将 新建立 rgw 节点  都注册到 ceph.client.radosgw.keyring中  并且为 node 生产密钥  （后面试了下不用这也可完成？是因为你把 cephx给关闭了）</span><br><span class="hljs-comment">#注意  名字 为 client.&#123;rgwname&#125;</span><br>[root@node29 ceph]<span class="hljs-comment"># ceph-authtool /etc/ceph/ceph.client.radosgw.keyring -n client.radosgw.gateway --gen-key</span><br><br><br><br><span class="hljs-comment">#赋予节点访问权限 --cap osd &#x27;allow rwx&#x27;    读写执行权限</span><br>[root@node29 ceph]<span class="hljs-comment"># ceph-authtool -n client.radosgw.gateway --cap osd &#x27;allow rwx&#x27; --cap mon &#x27;allow rwx&#x27; /etc/ceph/ceph.client.radosgw.keyring</span><br><br><span class="hljs-comment">#将节点添加到集群</span><br>[root@node29 ceph]<span class="hljs-comment"># ceph -k /etc/ceph/ceph.client.admin.keyring auth add client.radosgw.gateway -i /etc/ceph/ceph.client.radosgw.keyring </span><br>added key <span class="hljs-keyword">for</span> client.radosgw.gateway<br><br><br><br><span class="hljs-comment">#ceph auth ls 可以 查看到  已认证的node</span><br>[root@node29 ceph]<span class="hljs-comment"># ceph auth ls | grep -10 rados </span><br>client.radosgw.gateway<br>key: AQBTJepinqB+JBAAqYgKorE4nfwrtsN9LdpIzg==<br>caps: [mon] allow rwx<br>caps: [osd] allow rwx<br>client.rgw.node29<br>key: AQDGNepiNtYXLhAAGMGUlsRA8EfP0iDkXiBKSQ==<br>caps: [mon] allow rwx<br>caps: [osd] allow rwx<br></code></pre></td></tr></table></figure><h2 id="配置-ceph-conf"><a href="#配置-ceph-conf" class="headerlink" title="配置 ceph. conf"></a>配置 ceph. conf</h2><p>由于 安装的这个版本 修改过代码，起rgw之前，<strong>需要将 rgw系统的系统池创建好，然后在拉RGW！</strong></p><p>先创建池 ，这里参考并修改了同事的部署脚本（<strong>这里用 是单机部署如果是集群记得 将 修改好后的 ceph 同步到其他节点</strong>！<strong>用了单副本，结合实际情况设置副本数</strong>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">##################################################################################################</span><br>ceph osd pool create .rgw.root 8 8<br>ceph osd pool create master.rgw.control 8 8<br>ceph osd pool create master.rgw.meta 8 8<br>ceph osd pool create master.rgw.log 8 8<br>ceph osd pool create master1.rgw.buckets.cache 8 8<br>ceph osd pool create master1.rgw.buckets.index 8 8<br>ceph osd pool create master1.rgw.buckets.non-ec 8 8<br>ceph osd pool create master1.rgw.buckets.data 8 8<br>ceph osd pool create master1.rgw.buckets.data2 8 8<br>ceph osd pool create master1.rgw.buckets.data3 8 8<br>ceph osd pool <span class="hljs-built_in">set</span> .rgw.root size 1<br>ceph osd pool <span class="hljs-built_in">set</span> master.rgw.control size 1<br>ceph osd pool <span class="hljs-built_in">set</span> master.rgw.meta size 1<br>ceph osd pool <span class="hljs-built_in">set</span> master.rgw.log size 1<br>ceph osd pool <span class="hljs-built_in">set</span> master1.rgw.buckets.cache size 1<br>ceph osd pool <span class="hljs-built_in">set</span> master1.rgw.buckets.index size 1<br>ceph osd pool <span class="hljs-built_in">set</span> master1.rgw.buckets.non-ec size 1<br>ceph osd pool <span class="hljs-built_in">set</span> master1.rgw.buckets.data size 1<br>ceph osd pool <span class="hljs-built_in">set</span> master1.rgw.buckets.data2 size 1<br>ceph osd pool <span class="hljs-built_in">set</span> master1.rgw.buckets.data3 size 1<br><br><span class="hljs-comment">#创建 realm 用户</span><br>radosgw-admin realm create --rgw-realm=default --default <br><span class="hljs-comment">#</span><br>radosgw-admin zonegroup create --rgw-zonegroup=default --rgw-realm=default --default --master<br><br>radosgw-admin zone create --rgw-zone=master --rgw-zonegroup=default --default --master<br><br>radosgw-admin user create --uid admin --display-name admin --access_key admin --secret_key admin --system<br>radosgw-admin zone modify --rgw-zone=master --access_key admin --secret_key admin --endpoints=http://10.1.20.176:7480<br><span class="hljs-comment">#记得改成你的ip！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！</span><br>radosgw-admin zonegroup placement add --rgw-zonegroup=default --placement-id=<span class="hljs-built_in">test</span><br><br><span class="hljs-comment">#这里设置 placement rule （具体为什么这样还没搞明白）</span><br>radosgw-admin zonegroup placement add --placement-id mplacement --storage-class STANDARD<br><br>radosgw-admin zonegroup placement add --placement-id mplacement --storage-class GLACIER<br><br>radosgw-admin zonegroup placement add --placement-id <span class="hljs-built_in">test</span> --storage-class STANDARD<br><br>radosgw-admin zone placement add --placement-id <span class="hljs-built_in">test</span> --storage-class STANDARD --default-storage STANDARD --active-pool master1.rgw.buckets.data3 --index-pool master1.rgw.buckets.index --data-extra-pool master1.rgw.buckets.non-ec --cache-pool master1.rgw.buckets.cache<br><br><br>radosgw-admin zone placement add --placement-id mpplacement_testlacement --storage-class STANDARD --default-storage STANDARD --active-pool master1.rgw.buckets.data --index-pool master1.rgw.buckets.index --data-extra-pool master1.rgw.buckets.non-ec --cache-pool master1.rgw.buckets.cache<br><br>radosgw-admin zone placement add --placement-id mplacement --storage-class GLACIER --active-pool master1.rgw.buckets.data2 --compression zlib<br><br>radosgw-admin period update --commit<br><br><span class="hljs-comment">#创建rgw用户 </span><br>radosgw-admin user create --uid piglet --display-name piglet --access_key 123456 --secret_key 123456<br><span class="hljs-comment">##################################################################################################</span><br><br><span class="hljs-comment">#修改 conf </span><br><span class="hljs-comment">#这是你要上文你设置 网关名</span><br>[client.radosgw.gateway]          <br>rgw_frontends = <span class="hljs-string">&quot;beast port=8009&quot;</span>    <span class="hljs-comment"># 解析hthp的库 新版本 默认用 beast，以及指定端口 默认  7480</span><br>keyring = /etc/ceph/ceph.client.radosgw.keyr<br><span class="hljs-comment">#debug_rgw=20</span><br>rgw_zone=master    <span class="hljs-comment">#这里 是命名空间， 和刚才建的 pool前缀一样</span><br>rgw_gc_obj_min_wait=60<br>rgw_gc_processor_max_time=60<br>rgw_gc_processor_period=6<br><br><span class="hljs-comment">#######################################</span><br><span class="hljs-comment"># 修改ceph配置文件</span><br>auth cluster required = none<br>auth service required = none<br>auth client required = none<br><br><span class="hljs-comment"># 将下面配置 添加到ceph配置中</span><br>[client.radosgw.gateway]<br>rgw_frontends = <span class="hljs-string">&quot;beast port=8009&quot;</span><br>keyring = /etc/ceph/ceph.client.radosgw.keyring<br><span class="hljs-comment">#debug_rgw=20</span><br>rgw_zone=master <br>rgw_gc_obj_min_wait=60<br>rgw_gc_processor_max_time=60<br>rgw_gc_processor_period=60<br><br><span class="hljs-comment">#最后重启 ，建议其他 节点也重启下</span><br>systemctl restart ceph-osd@*<br>systemctl restart ceph-mgr@node29_mgr.service<br>systemctl restart ceph-mon@mon-node29.service<br><br><span class="hljs-comment">#启动服务</span><br>systemctl restart ceph-radosgw@radosgw.gateway.service<br><br><span class="hljs-comment">#最后我把整个 ceph.co 都贴出来，供参考</span><br><br><span class="hljs-comment">#ceph -s 看是否有 rgw ，以及看 端口是否 有监听</span><br><span class="hljs-comment">#也可以测试下端口 </span><br>[root@node29 home]<span class="hljs-comment"># curl http://10.1.23.29:7480</span><br>&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;&lt;ListAllMyBucketsResult xmlns=<span class="hljs-string">&quot;http://s3.amazonaws.com/doc/2006-03-01/&quot;</span>&gt;&lt;Owner&gt;&lt;ID&gt;anonymous&lt;/ID&gt;&lt;DisplayName&gt;&lt;/DisplayName&gt;&lt;/Owner&gt;&lt;Buckets&gt;&lt;/Buckets&gt;&lt;/ListAllMyBucketsResult&gt;<br>[root@node29 home]<span class="hljs-comment"># </span><br><br></code></pre></td></tr></table></figure><h2 id="部署遇的问题"><a href="#部署遇的问题" class="headerlink" title="部署遇的问题"></a>部署遇的问题</h2><ol><li>rgw服务起不来</li></ol><pre><code class="hljs"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#名字搞错！ 这个rgwname 要和 你在ceph.conf 中配置rgw名字一样！</span><br>systemctl restart ceph-radosgw@&#123;rgwname&#125;.service<br><span class="hljs-comment">#配置 文件有误</span><br><br><span class="hljs-comment">#这里 pool不是随便建立的 ，&#123;zone-name&#125;.pool-name.&#123;池的功能&#125;，这里zone 应该是为了隔离多站点， 我可以启很多哥 rgw服务</span><br><span class="hljs-comment">#补充 </span><br>systemctl | grep &#123;name&#125; 可以搜服务，结合 ps 看看经常  <br><br>journalctl |grep <span class="hljs-string">&#x27;error&#x27;</span>  可以看启动服务时有哪些报错<br><br></code></pre></td></tr></table></figure></code></pre><ol start="2"><li><p>服务起来了，但是  ceph -s 没有显示 rgw 节点</p><ul><li><p><strong>保证集群 是正常状态 ！</strong>  这个很关键！！用  ceph health detail 可查看  </p><p><img src="/C:%5CUsers%5Ch00165%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20220804162818423.png" alt="image-20220804162818423"></p><p>（我的一开始就  pg chunk ， <strong>记得先坚持 集群正常状态</strong>）</p></li><li><p>查看 mgr 服务是否正常 （开始我的mgr是挂的）</p></li><li><p>更新了cepf.conf  要重启服务，mon，mgr，osd也要重启， 此外 <strong>ceph.conf 也要同步到其他节点</strong>（最后都再这里 栽跟头了）</p></li></ul></li></ol><p>:point_up_2:</p><h2 id="附件-ceph-conf"><a href="#附件-ceph-conf" class="headerlink" title="附件 ceph.conf"></a>附件 ceph.conf</h2><p>rwg配置参数还有很多  ，可以参考官网的 <a href="https://docs.ceph.com/en/nautilus/radosgw/config-ref/">https://docs.ceph.com/en/nautilus/radosgw/config-ref/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@node29 home]<span class="hljs-comment"># cat /etc/ceph/ceph.conf </span><br>[global]<br>fsid = 311a4057-0837-4af8-92ab-a8053e4a3a57 <br>mon initial members = mon-node29,mon-node31<br>mon host = 10.1.23.29 , 10.1.23.31<br>public network = 10.1.23.0/24<br><br>auth cluster required = none<br>auth service required = none<br>auth client required = none<br><br>osd journal size = 1024<br>osd pool default size = 3<br>osd pool default min size = 2<br>osd pool default pg num = 333<br>osd pool default pgp num = 333<br>osd crush chooseleaf <span class="hljs-built_in">type</span> = 1<br>mon allow pool delete = <span class="hljs-literal">true</span><br><br>mon_max_pg_per_osd = 2000<br><br>rbd_default_features = 1<br><br>[client.rgw.node29]<br><br>keyring =  /etc/ceph/ceph.client.radosgw.keyring<br><br>rgw_zone = master<br>rgw_override_bucket_index_max_shards = 10<br>rgw_frontends = <span class="hljs-string">&quot;beast port=7480&quot;</span><br>rgw_override_bucket_index_max_shards = 10<br>debug_rgw = 20<br><br>[client.radosgw.gateway]<br>rgw_frontends = <span class="hljs-string">&quot;beast port=8009&quot;</span><br>keyring = /etc/ceph/ceph.client.radosgw.keyring<br><span class="hljs-comment">#debug_rgw=20</span><br>rgw_zone=master <br>rgw_gc_obj_min_wait=60<br>rgw_gc_processor_max_time=60<br>rgw_gc_processor_period=60<br><br><br><br>[client.radosgw1.gateway]<br>rgw_frontends = <span class="hljs-string">&quot;beast port=809&quot;</span><br>keyring = /etc/ceph/ceph.client.radosgw.keyring<br><span class="hljs-comment">#debug_rgw=20</span><br>rgw_zone=master <br>rgw_gc_obj_min_wait=60<br>rgw_gc_processor_max_time=60<br>rgw_gc_processor_period=60<br>You have new mail <span class="hljs-keyword">in</span> /var/spool/mail/root<br>[root@node29 home]<span class="hljs-comment"># </span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ceph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rbd 原理初步探索</title>
    <link href="/2022/08/03/ceph/%5Bceph%5Drbd%20%E5%8E%9F%E7%90%86%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2/"/>
    <url>/2022/08/03/ceph/%5Bceph%5Drbd%20%E5%8E%9F%E7%90%86%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<p>ceph中RBD 建立 image后，可以map到操作系统，当磁盘使用和插入STAT一样，此外内核模块已经支持 rbd（krbd）， modinfo 可以查看内核模块；创建100g的image并不是在真实磁盘中占用了100g，而是用多少，在ceph中就占用多少</p><p><img src="http://img.rui.vin/image-20220802162244952.png"></p><h2 id="创建RBD发生了什么"><a href="#创建RBD发生了什么" class="headerlink" title="创建RBD发生了什么"></a>创建RBD发生了什么</h2><p>现在创建pool，名字为rbd，并在rbd pool里创建image</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node29 hrp]# rados lspools<br>pool_A1<br>pool_A2<br>pool_rack<br>rbd<br>[root@node29 hrp]# rbd create foo --size 10240<br>[root@node29 hrp]# rbd -p rbd ls<br>foo<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看rbd信息</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">[root@node29 hrp]<span class="hljs-comment"># rbd info foo</span></span><br>rbd image &#x27;foo&#x27;:<br>size 10 GiB in 2560 objects<br>order 22 (4 MiB objects) #22是次方  4M是22， 8M是23，因为2^22 bytes = 4MB, 2^23 bytes = 8MB<br>snapshot_count: 0<br>id: 87fa3437b808<br>block_name_prefix: rbd_data.87fa3437b808 #每个块 唯一的前缀编号<br>format: 2  # 有两种格式，1 和 2 ，两者区别只是 data的obj命名不同<br>features: layering #这里特性 在其他文章有提过<br>op_features: <br>flags: <br>create_timestamp: Tue Aug  2 16:31:58 2022<br>access_timestamp: Tue Aug  2 16:31:58 2022<br>modify_timestamp: Tue Aug  2 16:31:58 2022<br><br><br></code></pre></td></tr></table></figure><p>现在rbd pool里建了rbd，看看此时产生了什么数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@node29 hrp]<span class="hljs-comment"># rados -p rbd ls</span><br>rbd_directory<br>rbd_info<br>rbd_id.foo<br>rbd_header.87fa3437b808<br>[root@node29 hrp]<span class="hljs-comment"># </span><br></code></pre></td></tr></table></figure><p>建立 foo 后，生成了 rbd_id.foo，现在 查看下 rbd_directory 这个对象的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@node29 hrp]<span class="hljs-comment">#  rados listomapvals rbd_directory -p rbd </span><br>id_87fa3437b808<br>value (7 bytes) :<br>00000000  03 00 00 00 66 6f 6f                              |....foo|<br>00000007<br><br>name_foo<br>value (16 bytes) :<br>00000000  0c 00 00 00 38 37 66 61  33 34 33 37 62 38 30 38  |....87fa3437b808|<br>00000010<br><br>You have new mail <span class="hljs-keyword">in</span> /var/spool/mail/root<br><span class="hljs-comment">#不是给人看的，反编译下</span><br>[root@node29 hrp]<span class="hljs-comment">#  rados listomapvals rbd_directory -p rbd &gt; temp &amp;&amp; hexdump -vC temp &amp;&amp; cat temp</span><br>00000000  69 64 5f 38 37 66 61 33  34 33 37 62 38 30 38 0a  |id_87fa3437b808.|<br>00000010  76 61 6c 75 65 20 28 37  20 62 79 74 65 73 29 20  |value (7 bytes) |<br>00000020  3a 0a 30 30 30 30 30 30  30 30 20 20 30 33 20 30  |:.00000000  03 0|<br>00000030  30 20 30 30 20 30 30 20  36 36 20 36 66 20 36 66  |0 00 00 66 6f 6f|<br>00000040  20 20 20 20 20 20 20 20  20 20 20 20 20 20 20 20  |                |<br>00000050  20 20 20 20 20 20 20 20  20 20 20 20 20 20 7c 2e  |              |.|<br>00000060  2e 2e 2e 66 6f 6f 7c 0a  30 30 30 30 30 30 30 37  |...foo|.00000007|<br>00000070  0a 0a 6e 61 6d 65 5f 66  6f 6f 0a 76 61 6c 75 65  |..name_foo.value|<br>00000080  20 28 31 36 20 62 79 74  65 73 29 20 3a 0a 30 30  | (16 bytes) :.00|<br>00000090  30 30 30 30 30 30 20 20  30 63 20 30 30 20 30 30  |000000  0c 00 00|<br>000000a0  20 30 30 20 33 38 20 33  37 20 36 36 20 36 31 20  | 00 38 37 66 61 |<br>000000b0  20 33 33 20 33 34 20 33  33 20 33 37 20 36 32 20  | 33 34 33 37 62 |<br>000000c0  33 38 20 33 30 20 33 38  20 20 7c 2e 2e 2e 2e 38  |38 30 38  |....8|<br>000000d0  37 66 61 33 34 33 37 62  38 30 38 7c 0a 30 30 30  |7fa3437b808|.000|<br>000000e0  30 30 30 31 30 0a 0a                              |00010..|<br>000000e7<br></code></pre></td></tr></table></figure><p>从信息可以看到 信息包含了 刚才建立的image foo，从 rbd_directory可以猜测 这对象可能是保存 image信息的，现在再建立一个 rbd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@node29 hrp]<span class="hljs-comment"># rbd create bar --size 10240</span><br>[root@node29 hrp]<span class="hljs-comment"># rados -p rbd ls</span><br>rbd_directory<br>rbd_id.bar<br>rbd_id.foo<br>rbd_header.881e37e3e168<br>rbd_header.87fa3437b808<br>rbd_info<br>[root@node29 hrp]<span class="hljs-comment"># </span><br><br>[root@node29 hrp]<span class="hljs-comment">#  rados listomapvals rbd_directory -p rbd &gt; temp &amp;&amp; hexdump -vC temp &amp;&amp; cat temp | grep name</span><br>name_bar<br>name_foo<br><br></code></pre></td></tr></table></figure><p>太多信息，过滤了其他其他内容，不过可以确定的是，每次创建一个rbd，都会pool里面rbd_directory 添加数据信息，而且还会添加 一个 rbd_header开头的 obj，rbd_header后面跟的是一个id，可以 再 rbd info看到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@node29 hrp]<span class="hljs-comment"># rbd info foo</span><br>rbd image <span class="hljs-string">&#x27;foo&#x27;</span>:<br>size 10 GiB <span class="hljs-keyword">in</span> 2560 objects<br>order 22 (4 MiB objects)<br>snapshot_count: 0<br><span class="hljs-built_in">id</span>: 87fa3437b808<br>block_name_prefix: rbd_data.87fa3437b808  <span class="hljs-comment"># 这里后面的id和rbd_header后面一样，很重要</span><br>format: 2<br>features: layering<br>op_features: <br>flags: <br>create_timestamp: Tue Aug  2 16:31:58 2022<br>access_timestamp: Tue Aug  2 16:31:58 2022<br>modify_timestamp: Tue Aug  2 16:31:58 2022<br>[root@node29 hrp]<span class="hljs-comment"># </span><br><span class="hljs-comment">#发现一个命令  可以从 rbd_head 中看 这些信息</span><br><span class="hljs-comment">#比如我想看 order  </span><br>[root@node29 ~]<span class="hljs-comment"># rados getomapval -p rbd rbd_header.8a15f6edcaf9 order</span><br>value (1 bytes) :<br>00000000  16                                                |.|<br>00000001<br><span class="hljs-comment">#想看 features </span><br>[root@node29 ~]<span class="hljs-comment"># rados getomapval -p rbd rbd_header.8a15f6edcaf9 features</span><br>value (8 bytes) :<br>00000000  01 00 00 00 00 00 00 00                           |........|<br>00000008<br><br></code></pre></td></tr></table></figure><p>​<img src="http://img.rui.vin/image-20220803101534670.png" alt="image-20220803101534670">（补充 info 里面 feature）</p><p><strong>可以得出，每创建一个 rbd 会在 pool里 生产 rbd_id.{name }和 rbd_header.{id}这两个 obj，并且也会更新 池中rbd_directory 的内容（可以理解一个目录，现在加了新的内容，要更新目录），</strong> <strong>rbd_header.{id} 里面包含了  image 的配置信息</strong></p><hr><h2 id="使用时底层发生什么"><a href="#使用时底层发生什么" class="headerlink" title="使用时底层发生什么"></a>使用时底层发生什么</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#简单使用下</span><br>[root@node29 hrp]<span class="hljs-comment"># rbd ls</span><br>bar<br>foo<br>[root@node29 hrp]<span class="hljs-comment">#  rbd map foo</span><br>/dev/rbd1<br><span class="hljs-comment"># 格式化  xfs</span><br>[root@node29 hrp]<span class="hljs-comment"># mkfs.xfs /dev/rbd1</span><br><span class="hljs-comment">#挂载后</span><br>[root@node29 mnt]<span class="hljs-comment"># df -h | grep rbd1</span><br>/dev/rbd1        10G   33M   10G   1% /mnt/foo<br>[root@node29 mnt]<span class="hljs-comment"># </span><br><br></code></pre></td></tr></table></figure><p>文件系统建立后，查看 rdb pool增加的内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@node29 home]<span class="hljs-comment"># rados -p rbd ls |sort </span><br>rbd_data.87fa3437b808.0000000000000000<br>rbd_data.87fa3437b808.0000000000000001<br>rbd_data.87fa3437b808.00000000000000a0<br>rbd_data.87fa3437b808.0000000000000140<br>rbd_data.87fa3437b808.00000000000001e0<br>rbd_data.87fa3437b808.0000000000000280<br>rbd_data.87fa3437b808.0000000000000320<br>rbd_data.87fa3437b808.00000000000003c0<br>rbd_data.87fa3437b808.0000000000000460<br>rbd_data.87fa3437b808.0000000000000500<br>rbd_data.87fa3437b808.0000000000000501<br>rbd_data.87fa3437b808.0000000000000502<br>rbd_data.87fa3437b808.00000000000005a0<br>rbd_data.87fa3437b808.0000000000000640<br>rbd_data.87fa3437b808.00000000000006e0<br>rbd_data.87fa3437b808.0000000000000780<br>rbd_data.87fa3437b808.0000000000000820<br>rbd_data.87fa3437b808.00000000000008c0<br>rbd_data.87fa3437b808.0000000000000960<br>rbd_data.rbd_data.00000000000009ff<br>...<br><span class="hljs-comment">#主要增加了 rbd_data.87fa3437b808.&#123;index&#125; 这些内容 </span><br></code></pre></td></tr></table></figure><p>rbd_data数据井然有序，查看下 第一个data内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@node29 hrp]<span class="hljs-comment"># rados -p rbd get rbd_data.87fa3437b808.0000000000000001 tmp1 &amp;&amp; hexdump -vC tmp1 |more</span><br>00000000  58 46 53 42 00 00 10 00  00 00 00 00 00 28 00 00  |XFSB.........(..|<br>00000010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>00000020  e7 f1 7c c2 16 09 4b <span class="hljs-built_in">fc</span>  ba 61 4e fd b0 8d 18 2f  |..|...K..aN..../|<br>[root@node29 ~]<span class="hljs-comment"># rados -p rbd get rbd_data.87fa3437b808.0000000000000001 tmp1 &amp;&amp; ls -lah tmp1 </span><br>-rw-r--r-- 1 root root 4.0M Aug  2 20:15 tmp1<br></code></pre></td></tr></table></figure><p>可以确定，块格式化为 <strong>xfs</strong>时候 ，是有对块读写数据的，每个 obj都是 4M，这也书上说的一样，ceph中会将大文件切割成 4M 大小的obj，而且都遵循 对象文件名都是 以</p><p> rbd_data.{block_name_prefix}.{index}命名（<strong>format 2 风格</strong>）</p><p> block_name_prefix作为全局唯一标识，在加上索引即可成为一个obj；</p><p>在ceph 设计原理与实现有一张图可以很好体现出 image的结构  ？（）</p><h3 id="format-1-，2之间区别"><a href="#format-1-，2之间区别" class="headerlink" title="format 1 ，2之间区别"></a>format 1 ，2之间区别</h3><ul><li><p><strong>format 1 - 此格式兼容所有版本的 librbd 和内核模块，但是不支持较新的功能，像克隆。</strong></p></li><li><p><strong>format 2 - librbd 和 3.11 版以上内核模块才支持。此格式增加了克隆支持，使得扩展更容易，还允许以后增加新功能。</strong></p></li></ul><img src="http://img.rui.vin/image-20220803095650245.png" alt="image-20220803095650245" style="zoom:80%;"><p>如果我在挂载的目录 新建一个有内容的文件，在 obj 文件中是否有更新呢？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#新建一个文件</span><br>[root@node29 foo]<span class="hljs-comment"># echo &quot;aaaaaaaaaaaaaaagggggggggggggggggggggg&quot; &gt; file3</span><br><span class="hljs-comment">#同上面一样，提取obj 并反编译，发现刚才写的内容就保存在 obj中</span><br><span class="hljs-comment">#通过文件对比可以查到 具体是更新到那个文件里面</span><br>[root@node29 ~]<span class="hljs-comment"># rados -p rbd get rbd_data.87fa3437b808.0000000000000001 tmp1 &amp;&amp; hexdump -vC tmp1 | grep -5 &quot;gggg&quot;</span><br>0000afc0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>0000afd0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>0000afe0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>0000aff0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>0000b000  61 61 61 61 61 61 61 61  61 61 61 61 61 61 61 67  |aaaaaaaaaaaaaaag|<br>0000b010  67 67 67 67 67 67 67 67  67 67 67 67 67 67 67 67  |gggggggggggggggg|<br>0000b020  67 67 67 67 67 0a 00 00  00 00 00 00 00 00 00 00  |ggggg...........|<br>0000b030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br>0000b040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|<br><br></code></pre></td></tr></table></figure><p>显然文件内容在 obj中可以找到，只不过被压缩编译了下。如果 写入一个大文件，会有什么变化呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">这里写入一个 1G的 大文件</span>  <br>[root@node29 mnt]# dd if=/dev/zero  of=/mnt/foo/maxfile count=1000 bs=1M<br>[root@node29 foo]# ls -lah maxfile <br>-rw-r--r-- 1 root root 1000M Aug  2 20:19 maxfile<br>[root@node29 foo]# <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">在rbd pool里查看obj数量是否增加</span><br>[root@node29 mnt]# rados -p rbd ls | wc -l| sort<br>280<br><span class="hljs-meta prompt_">#</span><span class="language-bash">原本才20几，现在290多个，1000/4=250  这样一算好像也差不多，符合上面说的，文件会分割成 4M大小obj</span><br></code></pre></td></tr></table></figure><p>以上操作可以得出， rbd 生产 image 后，然后 map（这里用到的是 内核rbd）到操作系统，格式化，挂载使用；在挂载目录里面进行 crud操作，此时还没到 ceph pool 中，而是先通过 文件系统将数据整理后，在交给ceph，分割成4M对象文件（不一定都是是4M！！），接下来怎么操作是ceph底层的事情了。（后期结合代码更新）</p><p><img src="http://img.rui.vin/image-20220803114900839.png" alt="image-20220803114900839"></p><h2 id="文件是怎么分割的"><a href="#文件是怎么分割的" class="headerlink" title="文件是怎么分割的"></a>文件是怎么分割的</h2><p>待总结…..</p><h2 id="思考的问题"><a href="#思考的问题" class="headerlink" title="思考的问题"></a><strong>思考的问题</strong></h2><blockquote><p>  以下是日常遇到RBD问题补充的</p></blockquote><p>上文说到，数据通过编译后才看得到数据，这种是直接以二进制的方式来存放数据的，在RADOS还有两种存放数据的方式，第二种是 以键值对的方式（xattr），地方是也是键值对 omap方式</p>]]></content>
    
    
    
    <tags>
      
      <tag>ceph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ceph中 RBD 使用</title>
    <link href="/2022/08/02/ceph/%5Bceph%5DRBD/"/>
    <url>/2022/08/02/ceph/%5Bceph%5DRBD/</url>
    
    <content type="html"><![CDATA[<h3 id="RBD"><a href="#RBD" class="headerlink" title="RBD"></a>RBD</h3><blockquote><p>  RBD是Ceph对外的三大存储服务组件之一，块存储接口Ceph ，企业环境中最常见的一种数据存储格式，支持的最大镜像为 16GB 这些镜像可以作为磁盘映射到物理裸机、虚拟机或者其他主机使用 ，此外Ceph RBD 驱动程序已经被集成到 Linux 内核( 2.6.39 或更高版本)中；还可以作为虚拟化平台的存储后端 </p></blockquote><h4 id="创建-块设备rbd"><a href="#创建-块设备rbd" class="headerlink" title="创建 块设备rbd"></a>创建 块设备rbd</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">rbd create &#123;poolname&#125;/&#123;rbdname&#125; --size &#123;rbdsize&#125;</span><br>[root@node29 ~]# rbd create pool_A1/myrbd --size 102400<br>[root@node29 ~]# rbd -p pool_A1 ls<br>myrbd<br>[root@node29 ~]# <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">rbd扩容</span><br>[root@node29 ~]#  rbd resize pool_A1/myrbd --size 51200 --allow-shrink<br>Resizing image: 100% complete...done.<br><br><br>[root@node29 ~]# rbd info pool_A1/myrbd<br>rbd image &#x27;myrbd&#x27;:<br>size 50 GiB in 12800 objects<br>order 22 (4 MiB objects)<br>snapshot_count: 0<br>id: 42422a7512b3<br>block_name_prefix: rbd_data.42422a7512b3<br>format: 2<br>features: layering, exclusive-lock, object-map, fast-diff, deep-flatten<br>op_features: <br>flags: <br>create_timestamp: Mon Aug  1 15:38:48 2022<br>access_timestamp: Mon Aug  1 15:38:48 2022<br>modify_timestamp: Mon Aug  1 15:38:48 2022<br>[root@node29 ~]# <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看pool里面的rbd</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">这里不指定pool 默认的是 rbd</span><br>rbd ls &#123;poolname&#125;<br>[root@node29 ceph]# rbd ls pool_A1<br>myrbd<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看rbd详细信息</span><br>[root@node29 ~]# rbd info  --pool pool_A1 --image myrbd<br>rbd image &#x27;myrbd&#x27;:<br>size 50 GiB in 12800 objects<br>order 22 (4 MiB objects)<br>snapshot_count: 1             #快照数<br>id: 42422a7512b3               <br>block_name_prefix: rbd_data.42422a7512b3   #块唯一的前缀编号，<br>format: 2<br>features: layering            # 层级特性，这个和Linux有关  <br>op_features: <br>flags: <br>create_timestamp: Mon Aug  1 15:38:48 2022<br>access_timestamp: Mon Aug  1 15:38:48 2022<br>modify_timestamp: Mon Aug  1 15:38:48 2022<br><br><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看 rbd使用情况</span> <br>[root@node29 hrp]# rbd du pool_A1/myrbd<br>warning: fast-diff map is not enabled for myrbd. operation may be slow.<br>NAME        PROVISIONED USED    <br>myrbd@snap1      50 GiB 196 MiB <br>myrbd@snap2      50 GiB 104 MiB <br>myrbd@snap3      50 GiB  12 MiB <br>myrbd@snap4      50 GiB  12 MiB <br>myrbd            50 GiB 296 MiB <br>&lt;TOTAL&gt;          50 GiB 620 MiB <br><br></code></pre></td></tr></table></figure><h4 id="删除-amp-移动回收站"><a href="#删除-amp-移动回收站" class="headerlink" title="删除&amp; 移动回收站"></a>删除&amp; 移动回收站</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">移动到回收站</span><br>[root@node29 ~]# rbd trash move --pool pool_A1 --image myrbd<br>[root@node29 ~]# rbd status --pool pool_A1 --image myrbd<br>rbd: error opening image myrbd: (2) No such file or directory<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看回收站列表</span><br>[root@node29 ~]# rbd trash list --pool pool_A1<br>42422a7512b3 myrbd<br><span class="hljs-meta prompt_">#</span><span class="language-bash">恢复rbd --image-id 值得时候回收站的里 rbd对应的 <span class="hljs-built_in">id</span></span><br>[root@node29 ~]# rbd trash restore  --pool pool_A1 --image myrbd --image-id 42422a7512b3<br><br>[root@node29 ~]# rbd ls --pool pool_A1 -l<br>NAME         SIZE   PARENT FMT PROT LOCK <br>myrbd        50 GiB          2         <br></code></pre></td></tr></table></figure><h4 id="映射块设备"><a href="#映射块设备" class="headerlink" title="映射块设备"></a>映射块设备</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">rdb map &#123;poolname&#125;/&#123;rbdname&#125;</span><br>[root@node29 ~]# rbd map pool_A1/myrbd<br>rbd: sysfs write failed<br>RBD image feature set mismatch. You can disable features unsupported by the kernel with &quot;rbd feature disable pool_A1/myrbd object-map fast-diff deep-flatten&quot;.<br>In some cases useful info is found in syslog - try &quot;dmesg | tail&quot;.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">出现映射报错</span><br><br>[root@node29 ~]# dmesg | tail<br>[431601.152693] libceph: mon2 10.1.23.31:3300 socket closed (con state CONNECTING)<br>[431602.160874] libceph: mon3 10.1.23.31:6789 socket closed (con state CONNECTING)<br>[431603.152717] libceph: mon3 10.1.23.31:6789 socket closed (con state CONNECTING)<br>[431604.152924] libceph: mon3 10.1.23.31:6789 socket closed (con state CONNECTING)<br>[431605.152983] libceph: mon0 10.1.23.29:3300 socket closed (con state CONNECTING)<br>[431606.154832] libceph: mon0 10.1.23.29:3300 socket closed (con state CONNECTING)<br>[431607.154763] libceph: mon0 10.1.23.29:3300 socket closed (con state CONNECTING)<br>[431608.162428] libceph: mon1 10.1.23.29:6789 session established<br>[431608.168616] libceph: client16974 fsid 311a4057-0837-4af8-92ab-a8053e4a3a57<br>[431608.181694] rbd: image myrbd: [431608.181694] rbd: image myrbd: image uses unsupported features: 0x38 <br> uses unsupported features: 0x38<br><span class="hljs-meta prompt_"> </span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">最后一行提示 imgage 不支持特性 ？？？？？？？</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">用 rbd info 查看信息</span><br>[root@node29 ~]#  rbd info pool_A1/myrbd | grep feature<br>features: layering, exclusive-lock, object-map, fast-diff, deep-flatten<br><br>layering: 支持分层<br>striping: 支持条带化 v2<br>exclusive-lock: 支持独占锁<br>object-map: 支持对象映射（依赖 exclusive-lock ）<br>fast-diff: 快速计算差异（依赖 object-map ）<br>deep-flatten: 支持快照扁平化操作<br>journaling: 支持记录 IO 操作（依赖独占锁）<br><span class="hljs-meta prompt_">#</span><span class="language-bash">CentOS的 内核仅支持其中的 layering feature，所以其他的得停用</span> <br><br>[root@node29 ~]# rbd feature disable  pool_A1/myrbd exclusive-lock, object-map, fast-diff, deep-flatten<br><span class="hljs-meta prompt_">#</span><span class="language-bash">一劳永逸方法 ，在 ceph.conf 加入  rbd_default_features = 1</span><br>[root@node29 ~]# rbd map pool_A1/myrbd<br>/dev/rbd0<br><br>[root@node29 ~]# lsblk /dev/rbd0<br>NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT<br>rbd0 252:0    0  50G  0 disk <br>You have new mail in /var/spool/mail/root<br>[root@node29 ~]# <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">取消映射</span><br><br>[root@node29 ~]#  rbd showmapped<br>id pool    namespace image snap device    <br>0  pool_A1           myrbd -    /dev/rbd0 <br><br>[root@node29 ~]# rbd --user lck -p pool_A1 unmap myrbd<br>[root@node29 ~]#  rbd showmapped<br><br></code></pre></td></tr></table></figure><h4 id="fio测试-设备块"><a href="#fio测试-设备块" class="headerlink" title="fio测试 设备块"></a>fio测试 设备块</h4><p>随机写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node29 home]# cat fio_test <br>[global]<br>direct=1<br>ioengine=libaio<br>group_reporting=1<br>iodepth=32<br>size=1g<br>verify=md5<br>verify_fatal=1<br>verify_interval=512<br>verify_dump=1<br>runtime=30<br>rwmixread=70<br>rwmixwrite=30<br>time_based<br><br>[job1]<br>bssplit=4k/33:8k/33;16k/34<br>rw=randwrite<br>filename=/dev/rbd0<br><br>[root@node29 home]# fio fio_test <br>job1: (g=0): rw=randwrite, bs=4K-8K/4K-8K, ioengine=libaio, iodepth=32<br>fio 2.0.7<br>Starting 1 process<br>Jobs: 1 (f=1): [w] [100.0% done] [0K/5650K /s] [0 /861  iops] [eta 00m:00s]<br>job1: (groupid=0, jobs=1): err= 0: pid=52184<br>  write: io=158620KB, bw=5283.3KB/s, iops=809 , runt= 30023msec<br>    slat (usec): min=3 , max=461 , avg= 9.31, stdev= 9.32<br>    clat (msec): min=5 , max=448 , avg=39.51, stdev=35.73<br>     lat (msec): min=5 , max=448 , avg=39.52, stdev=35.73<br>    clat percentiles (msec):<br>     |  1.00th=[   12],  5.00th=[   15], 10.00th=[   18], 20.00th=[   21],<br>     | 30.00th=[   23], 40.00th=[   26], 50.00th=[   30], 60.00th=[   34],<br>     | 70.00th=[   42], 80.00th=[   52], 90.00th=[   70], 95.00th=[   87],<br>     | 99.00th=[  202], 99.50th=[  249], 99.90th=[  437], 99.95th=[  449],<br>     | 99.99th=[  449]<br>    bw (KB/s)  : min= 1551, max= 7474, per=100.00%, avg=5355.09, stdev=1441.25<br>    lat (msec) : 10=0.26%, 20=19.37%, 50=58.37%, 100=18.48%, 250=3.07%<br>    lat (msec) : 500=0.45%<br>  cpu          : usr=1.74%, sys=0.91%, ctx=5009, majf=0, minf=602<br>  IO depths    : 1=0.1%, 2=0.1%, 4=0.1%, 8=0.1%, 16=0.1%, 32=99.9%, &gt;=64=0.0%<br>     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, &gt;=64=0.0%<br>     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.1%, 64=0.0%, &gt;=64=0.0%<br>     issued    : total=r=0/w=24296/d=0, short=r=0/w=0/d=0<br><br>Run status group 0 (all jobs):<br>  WRITE: io=158620KB, aggrb=5283KB/s, minb=5283KB/s, maxb=5283KB/s, mint=30023msec, maxt=30023msec<br><br>Disk stats (read/write):<br>  rbd0: ios=0/24216, merge=0/16, ticks=0/951410, in_queue=950541, util=99.97%<br><br><br></code></pre></td></tr></table></figure><h4 id="使用块设备"><a href="#使用块设备" class="headerlink" title="使用块设备"></a>使用块设备</h4><p>格式化、挂载后就可正常使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@node29 ~]<span class="hljs-comment"># mkfs.xfs -f /dev/rbd0</span><br>[root@node29 ~]<span class="hljs-comment"># mount /dev/rbd0 /mnt/</span><br>[root@node29 mnt]<span class="hljs-comment"># df -h | grep rbd</span><br>/dev/rbd0        50G   33M   50G   1% /mnt<br><br> 使用 <span class="hljs-built_in">dd</span>命令写入 100M数据<br>[root@node29 rbd_test]<span class="hljs-comment"># dd if=/dev/zero  of=/root/rbd_test/file1 count=100 bs=1M</span><br>100+0 records <span class="hljs-keyword">in</span><br>100+0 records out<br>104857600 bytes (105 MB) copied, 0.121638 s, 862 MB/s<br><br></code></pre></td></tr></table></figure><h4 id="创建快照"><a href="#创建快照" class="headerlink" title="创建快照"></a>创建快照</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">此时文件</span><br>[root@node29 hrp]# touch 1 2 3 4 5<br>[root@node29 hrp]# ls<br>1  2  3  4  5<br><span class="hljs-meta prompt_">#</span><span class="language-bash">打快照  <span class="hljs-comment">#是写时复制 所以很快！ COW</span></span><br>[root@node29 hrp]# rbd snap create pool_A1/myrbd@snap8  <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">查看创建的快照</span><br>[root@node29 hrp]# rbd snap ls pool_A1/myrbd<br>SNAPID NAME  SIZE   PROTECTED TIMESTAMP                <br>     6 snap1 50 GiB           Mon Aug  1 22:45:54 2022 <br>     7 snap2 50 GiB           Mon Aug  1 22:47:17 2022 <br>     8 snap3 50 GiB           Mon Aug  1 22:51:54 2022 <br>     9 snap4 50 GiB           Mon Aug  1 22:56:57 2022 <br>    10 snap5 50 GiB           Tue Aug  2 10:59:32 2022 <br>    11 snap6 50 GiB           Tue Aug  2 11:00:24 2022 <br>    12 new   50 GiB           Tue Aug  2 11:08:31 2022 <br>    13 snap8 50 GiB           Tue Aug  2 11:22:38 2022 <br>[root@node29 hrp]# <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">测试 删除后能否恢复</span><br>[root@node29 hrp]# rm -f  1 2 3 <br>[root@node29 hrp]# ls<br>4  5<br>[root@node29 hrp]# cd ..<br><span class="hljs-meta prompt_">#</span><span class="language-bash">ummount 注意： umount 时不要在 挂载目录下，否则会报错</span><br>[root@node29 mnt]# umount /mnt/hrp/<br><span class="hljs-meta prompt_">#</span><span class="language-bash">回滚</span><br>[root@node29 mnt]# rbd snap rollback pool_A1/myrbd@snap8<br>Rolling back to snapshot: 100% complete...done.<br><span class="hljs-meta prompt_">#</span><span class="language-bash">重新挂载</span><br>[root@node29 mnt]# mount /dev/rbd0 /mnt/hrp/<br><span class="hljs-meta prompt_">#</span><span class="language-bash">文件回来了</span><br>[root@node29 mnt]# cd hrp/ &amp;&amp; ls<br>[root@node29 hrp]# ls<br>1  2  3  4  5<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除快照</span><br>[root@node29 hrp]# rbd snap rm pool_A1/myrbd@snap1<br>Removing snap: 100% complete...done.<br>[root@node29 hrp]# rbd snap ls pool_A1/myrbd<br>SNAPID NAME  SIZE   PROTECTED TIMESTAMP                <br>     7 snap2 50 GiB           Mon Aug  1 22:47:17 2022 <br>     8 snap3 50 GiB           Mon Aug  1 22:51:54 2022 <br>     9 snap4 50 GiB           Mon Aug  1 22:56:57 2022 <br>    10 snap5 50 GiB           Tue Aug  2 10:59:32 2022 <br>    11 snap6 50 GiB           Tue Aug  2 11:00:24 2022 <br>    12 new   50 GiB           Tue Aug  2 11:08:31 2022 <br>    13 snap8 50 GiB           Tue Aug  2 11:22:38 2022 <br>    <br><span class="hljs-meta prompt_">#</span><span class="language-bash">删除全部快照 purge</span><br>[root@node29 hrp]# rbd snap purge pool_A1/myrbd<br>Removing all snapshots: 100% complete...done.<br>[root@node29 hrp]# <br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>ceph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ceph 部署</title>
    <link href="/2022/08/01/ceph/%5Bceph%5D%20ceph%E9%83%A8%E7%BD%B2%20(copy)/"/>
    <url>/2022/08/01/ceph/%5Bceph%5D%20ceph%E9%83%A8%E7%BD%B2%20(copy)/</url>
    
    <content type="html"><![CDATA[<h3 id="ceph部署-mon"><a href="#ceph部署-mon" class="headerlink" title="ceph部署(mon)"></a>ceph部署(mon)</h3><h4 id="更改的yum源（我这里用的公司的）"><a href="#更改的yum源（我这里用的公司的）" class="headerlink" title="更改的yum源（我这里用的公司的）"></a>更改的yum源（我这里用的公司的）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@node29 ~]<span class="hljs-comment"># cat /etc/yum.repos.d/ceph.repo </span><br>[obs-ceph]<br>name=Obs-Ceph-CentOS-<span class="hljs-variable">$releasever</span><br>baseurl=http://10.1.31.40/ceph-rpm-centos7-x86_64-basic/ref/v14.2.11-2022071420/<span class="hljs-variable">$basearch</span>/<br>gpgcheck=0<br>[obs-ceph-noarch]<br>name=Obs-Ceph-CentOS-<span class="hljs-variable">$releasever</span> Noarch<br>baseurl=http://10.1.31.40/ceph-rpm-centos7-x86_64-basic/ref/v14.2.11-2022071420/noarch/<br>gpgcheck=0<br>You have new mail <span class="hljs-keyword">in</span> /var/spool/mail/root<br>[root@node29 ~]<span class="hljs-comment"># yum install ceph </span><br><br></code></pre></td></tr></table></figure><p>安装时遇到问题：  提示无法访问 host，后来发现，在yum.repos.d中，有个repo是失效的（用yum安装时会对 yum.repos.d 的源都检查一遍），所以无法通过，通过ip找到对应的rppo文件并移除就可以安装了</p><p><img src="http://img.rui.vin/202208071101783.png" alt="image-20220727194704455"></p><p> 安装完成后查看ceph 版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@node31 tmp]<span class="hljs-comment"># ceph -v</span><br>ceph version 14.2.11-2022071420 (cfbcf2f104d05f7d6c69573d275597371890966e) nautilus (stable)<br></code></pre></td></tr></table></figure><h4 id="安装mon准备工作"><a href="#安装mon准备工作" class="headerlink" title="安装mon准备工作"></a>安装mon准备工作</h4><p>最开始是要先安装一个mon（moniter），mon也是集群最为关键的组件</p><p>创建 mon需要三个信息：</p><ul><li><p>mon 名字</p></li><li><p>集群 id （uuid）</p></li><li><p>秘钥环  （认证信息）每个集群都需要个id，可以用uuidgen生产，将mon节点和节点ip和FSID进行映射并保存到指定文件中</p></li></ul><p>集群id</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">uuidgen <span class="hljs-comment">#k可以生产 uuid</span><br>monmaptool --create --add &#123;hostname&#125; &#123;ip-address&#125; --fsid &#123;uuid&#125; /tmp/monmap<br></code></pre></td></tr></table></figure><p>秘钥环</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#为 mon 创建秘钥环，并创建用户  用户名为  mon.</span><br>sudo ceph-authtool --create-keyring /tmp/ceph.mon.keyring --gen-key -n mon. --<span class="hljs-built_in">cap</span> mon <span class="hljs-string">&#x27;allow *&#x27;</span><br><br><span class="hljs-comment">#也是生成一个client，名字为  client.admin，以后的登录集群默认 使用这个用户（执行 ceph -s 默认指定的用户）</span><br>sudo ceph-authtool --create-keyring /etc/ceph/ceph.client.admin.keyring --gen-key -n client.admin --<span class="hljs-built_in">cap</span> mon <span class="hljs-string">&#x27;allow *&#x27;</span> --<span class="hljs-built_in">cap</span> osd <span class="hljs-string">&#x27;allow *&#x27;</span> --<span class="hljs-built_in">cap</span> mds <span class="hljs-string">&#x27;allow *&#x27;</span> --<span class="hljs-built_in">cap</span> mgr <span class="hljs-string">&#x27;allow *&#x27;</span><br><br><span class="hljs-comment">#生成  client.bootstrap-osd， 引导osd用户 </span><br>sudo ceph-authtool --create-keyring /var/lib/ceph/bootstrap-osd/ceph.keyring --gen-key -n client.bootstrap-osd --<span class="hljs-built_in">cap</span> mon <span class="hljs-string">&#x27;profile bootstrap-osd&#x27;</span> --<span class="hljs-built_in">cap</span> mgr <span class="hljs-string">&#x27;allow r&#x27;</span><br><br><br><span class="hljs-comment">#将 用户 client.admin的 keyring  加入到 mon中，bootstrap-osd也是、</span><br><span class="hljs-comment">#这里操作只是 把keyring文件拷贝到 mon的 keyring中</span><br><span class="hljs-comment">#mon 是管理秘钥的</span><br>sudo ceph-authtool /tmp/ceph.mon.keyring --import-keyring /etc/ceph/ceph.client.admin.keyring<br>sudo ceph-authtool /tmp/ceph.mon.keyring --import-keyring /var/lib/ceph/bootstrap-osd/ceph.keyring<br></code></pre></td></tr></table></figure><p>生成 monmap，使用 monmaptool 可以生成 ，需要结合 节点主机ip，和mon的名字，以及 fsid，可以生成 monmap</p><p>ceph中的map 我理解是存放某个功能节点信息的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@node29 bootstrap-osd]<span class="hljs-comment"># monmaptool -h</span><br>usage: monmaptool [--<span class="hljs-built_in">print</span>] [--create [--clobber] [--fsid uuid]]<br>        [--enable-all-features]<br>        [--generate] [--set-initial-members]<br>        [--add name 1.2.3.4:567] [--<span class="hljs-built_in">rm</span> name]<br>        [--feature-list [plain|parseable]]<br>        [--feature-set &lt;value&gt; [--optional|--persistent]]<br>        [--feature-unset &lt;value&gt; [--optional|--persistent]]<br>        [--set-min-mon-release &lt;release-major-number&gt;]<br>        &lt;mapfilename&gt;<br>You have new mail <span class="hljs-keyword">in</span> /var/spool/mail/root<br>[root@node29 bootstrap-osd]<span class="hljs-comment"># monmaptool --create --add mon-node29 10.1.23.29  --fsid e518351f-a867-4ce6-b0c5-2e40a2bfcd1c /tmp/monmap</span><br><span class="hljs-comment">#查看生成了什么 </span><br>[root@node29 bootstrap-osd]<span class="hljs-comment"># cat /tmp/monmap </span><br>??¨gL?.@???^e??? ^e???  <br>mon-node298<br>mon-node29 <br> <br><span class="hljs-comment">#用 monmaptool工具也可以看 打印的是 monmap的纯文本视图</span><br>[root@node29 bootstrap-osd]<span class="hljs-comment"># monmaptool --print /tmp/monmap</span><br>monmaptool: monmap file /tmp/monmap<br>epoch 0<br>fsid e518351f-a867-4ce6-b0c5-2e40a2bfcd1c<br>last_changed 2022-08-10 15:59:26.547689<br>created 2022-08-10 15:59:26.547689<br>min_mon_release 0 (unknown)<br>0: v1:10.1.23.29:6789/0 mon.mon-node29<br>[root@node29 bootstrap-osd]<span class="hljs-comment"># </span><br><br></code></pre></td></tr></table></figure><p>创建mon 数据的文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">mkdir</span> /var/lib/ceph/mon/&#123;cluster-name&#125;-&#123;hostname&#125;<br>[root@node29 bootstrap-osd]<span class="hljs-comment"># sudo -u ceph mkdir -p /var/lib/ceph/mon/ceph-mon-node29</span><br></code></pre></td></tr></table></figure><p>关联 mon进程 和 密钥，并且初始化 mon 数据目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">ceph-mon -h 可以查看使用命令，不过 官网更为详细  https://docs.ceph.com/en/quincy/man/8/ceph-mon/</span><br>sudo -u ceph ceph-mon [--cluster &#123;cluster-name&#125;] --mkfs -i &#123;hostname&#125; --monmap /tmp/monmap --keyring /tmp/ceph.mon.keyring<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">--mkfs 初始化 保存mon 数据的目录</span>  <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">注意节点名字要和你的集群名字一致</span><br>sudo -u ceph ceph-mon --mkfs -i mon-node29 --monmap /tmp/monmap --keyring /tmp/ceph.mon.keyring<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">执行后在 mon 的数据目录里多了</span><br>[root@node29 ceph-mon-node29]# ls -rh /var/lib/ceph/mon/ceph-mon-node29<br>store.db  kv_backend  keyring<br><span class="hljs-meta prompt_"># </span><span class="language-bash">是个 rocksdb数据库？</span> <br></code></pre></td></tr></table></figure><p>最后编辑配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /etc/ceph/ceph.conf<br>[global]<br>fsid = a7f64266-0894-4f1e-a635-d0aeaca0e993   # 用 uuidgen生产的uid<br>mon initial members = mon-node29<br>mon host = 192.168.0.1   #节点ip<br>public network = 192.168.0.0/24  #   掩码<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">cephx 是一种验证方式，也可以设置为  none取消认证</span><br>auth cluster required = cephx   # 各个功能节点（mon，osd，mgr）之间交流 都是否需要验证<br>auth service required = cephx   # 各个功能节点（mon，osd，mgr）和集群之间的验证<br>auth client required = cephx    # 客户端需要验证  <br><br>osd journal size = 1024<br>osd pool default size = 3<br>osd pool default min size = 2<br>osd pool default pg num = 333<br>osd pool default pgp num = 500<br>osd crush chooseleaf type = 1<br></code></pre></td></tr></table></figure><p>启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl start ceph-mon@mon-node29<br>sudo systemctl status ceph-mon@mon-node29<br><span class="hljs-meta prompt_">#</span><span class="language-bash">最后要 ceph -s验证下</span><br>[root@node29 ~]# ceph -s<br>  cluster:<br>    id:     311a4057-0837-4af8-92ab-a8053e4a3a57<br>    health: HEALTH_WARN<br>            OSD count 1 &lt; osd_pool_default_size 3<br> <br>  services:<br>    mon: 1 daemons, quorum mon-node29 (age 3h)<br>    mgr: node29(active, since 3h)<br>    osd: 1 osds: 1 up (since 2h), 1 in (since 2h)<br> <br>  data:<br>    pools:   0 pools, 0 pgs<br>    objects: 0 objects, 0 B<br>    usage:   1.0 GiB used, 299 GiB / 300 GiB avail<br>    pgs:     <br></code></pre></td></tr></table></figure><p>如果服务没有启，可以去 ceph的日志查看，定位问题</p><p><img src="http://img.rui.vin/202208071308021.png" alt="image-20220727202748125"></p><h4 id="添加多个-mon"><a href="#添加多个-mon" class="headerlink" title="添加多个 mon"></a>添加多个 mon</h4><p>一般来说，一个集群要三个 mon（选举），现在有三台服务器，每个服务器都安装一个mon</p><h5 id="同步配置文件和秘钥"><a href="#同步配置文件和秘钥" class="headerlink" title="同步配置文件和秘钥"></a>同步配置文件和秘钥</h5><p>在ceph.conf 添加 节点ip和 mon 名字 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#这里我添加的  mon-node31    推荐 mon名字格式为    mon-&#123;hostname&#125;</span><br>[root@node29 mon]<span class="hljs-comment"># cat /etc/ceph/ceph.conf </span><br>[global]<br>fsid = e518351f-a867-4ce6-b0c5-2e40a2bfcd1c <br>mon initial members = mon-node29,mon-node30,mon-node31   <span class="hljs-comment">#添加了 mon-node31</span><br>mon host = 10.1.23.29,10.1.23.30,10.1.23.31     <span class="hljs-comment">#添加了 10.1.23.31    </span><br>public network = 10.1.23.0/24<br><br>auth cluster required = cephx<br>auth service required = cephx<br>auth client required = cephx<br><br>osd journal size = 1024<br>osd pool default size = 3<br>osd pool default min size = 2<br>osd pool default pg num = 333<br>osd pool default pgp num = 33<br><br><span class="hljs-comment">#debug_mon=20</span><br><br><span class="hljs-comment">#我这里将 ceph配置 和  client的keyring都拷贝到 node31上</span><br>[root@node29 mon]<span class="hljs-comment"># scp /etc/ceph/* node31:/etc/ceph/</span><br>ceph.client.admin.keyring                                                        100%  151   189.6KB/s   00:00    <br>ceph.conf                                                                        100%  429     1.0MB/s   00:00    <br>You have new mail <span class="hljs-keyword">in</span> /var/spool/mail/root<br>[root@node29 mon]<span class="hljs-comment"># </span><br><br><span class="hljs-comment">#bootstrap-osd 的keyring 也拷贝过去，这个为以后添加 osd做准备 </span><br>[root@node29 mon]<span class="hljs-comment">#  scp /var/lib/ceph/bootstrap-osd/ceph.keyring root@node31:/var/lib/ceph/bootstrap-osd/</span><br>ceph.keyring                                                                     100%  129    13.9KB/s   00:00    <br>[root@node29 mon]<span class="hljs-comment"># </span><br><br><span class="hljs-comment">#复制最为关键的  mon 的keyring </span><br>[root@node29 mon]<span class="hljs-comment">#  scp /tmp/ceph.mon.keyring root@node31:/tmp/ceph.mon.keyring</span><br>ceph.mon.keyring                                                                 100%  506   668.9KB/s   00:00    <br><span class="hljs-comment">#--------------------------------------------------</span><br><span class="hljs-comment">#现在登录到 node31上，要注意这些操作是在那台机子上操作的</span><br><span class="hljs-comment">#--------------------------------------------------</span><br><br><br><span class="hljs-comment">#创建  保存mon数据目录 </span><br>[root@node31 lib]<span class="hljs-comment"># sudo -u ceph mkdir -p /var/lib/ceph/mon/ceph-mon-node31</span><br><br><span class="hljs-comment">#刚才 复制了配置文件 和 client.admin 的keyring，现在可以和集群交互</span><br><span class="hljs-comment">#获取 集群中的mon. 的keyring，其实这一步我也可以在 node29上导出后再拷贝过来</span><br>[root@node31 mon]<span class="hljs-comment">#  ceph auth get mon. -o /tmp/ceph.mon.keyring</span><br>exported keyring <span class="hljs-keyword">for</span> mon.<br><br><span class="hljs-comment">#获取集群的 monmap</span><br>[root@node31 ~]<span class="hljs-comment"># ceph mon getmap -o /tmp/ceph.mon.map</span><br>got monmap epoch 5<br><br><span class="hljs-comment">#初始化 mon   （这几步和部署第一个 mon是一样的）</span><br>[root@node31 ~]<span class="hljs-comment"># sudo -u ceph ceph-mon --mkfs -i mon-node31 --monmap /tmp/ceph.mon.map --keyring /tmp/ceph.mon.keyring</span><br><br><span class="hljs-comment">#最为关键的一步   将mon添加到 集群内</span><br>[root@node31 ceph-mon-node31]<span class="hljs-comment"># ceph mon add mon-node31 10.1.23.31:6789</span><br>adding mon.node2 at [v2:10.1.23.31:3300/0,v1:10.1.23.31:6789/0]<br><span class="hljs-comment">#启动 mon</span><br>[root@node31 ceph-mon-node31]<span class="hljs-comment"># systemctl start ceph-mon@mon-node31</span><br><br>[root@node29 ~]<span class="hljs-comment"># ceph -s</span><br>  cluster:<br>    <span class="hljs-built_in">id</span>:     e518351f-a867-4ce6-b0c5-2e40a2bfcd1c<br>    health: HEALTH_WARN<br>            OSD count 2 &lt; osd_pool_default_size 3<br>            clock skew detected on mon.mon-node30<br> <br>  services:<br>    mon: 3 daemons, quorum mon-node29,mon-node30,mon-node31 (age 2m)<br>    mgr: node29(active, since 9h)<br>    osd: 2 osds: 2 up (since 23h), 2 <span class="hljs-keyword">in</span> (since 23h)<br> <br>  data:<br>    pools:   0 pools, 0 pgs<br>    objects: 0 objects, 0 B<br>    usage:   2.0 GiB used, 148 GiB / 150 GiB avail<br>    pgs:     <br> <br>[root@node29 ~]<span class="hljs-comment"># </span><br><br><br></code></pre></td></tr></table></figure><p>ceph 最开始 是要先创建一个  moniter ，最先创建的用户也是 mon，接下来创建  client，他们各自都有 keyring，上文有个步骤是将 client的 keyring 加入到mon的keyring，mon是有保存 client.admin 的秘钥，用户形成都是这 向下开始；刚才还有一个  bootstrap-osd也加入了 mon的keyring，这个 bootstrap-osd 以后将引导生成 osd用户；</p><p>集群启动，mon最先启动，然后才启动osd，mon启动时候是不需要想任何进程进行秘钥验证，其他用户验证操作时候，需要向mon进行验证keyring</p><hr><h3 id="添加mgr-节点"><a href="#添加mgr-节点" class="headerlink" title="添加mgr 节点"></a>添加mgr 节点</h3><blockquote><p>  ​eph-mgr 的主要功能是提供外部监测和管理系统的接口</p></blockquote><ol><li><p>在ceph里各个节点 都要有秘钥进行认证 ，所以 创建 mgr前应该为添加秘钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ceph auth get-or-create mgr.$name mon &#x27;allow profile mgr&#x27; osd &#x27;allow *&#x27; mds &#x27;allow *&#x27;</span><br><br><span class="hljs-comment"># 这命令的用途可以用  ceph auth -h 查看</span><br><br><span class="hljs-comment">#（很多命令都可以以 ceph &#123;模块功能名字&#125; -h 查看到，当然如果你以 ceph -h是查看全部的）</span><br><br><span class="hljs-comment">#我的 hostname 为node29上弄，所以mgr名字为 </span><br>ceph auth get-or-create mgr.node29 mon <span class="hljs-string">&#x27;allow *&#x27;</span> osd <span class="hljs-string">&#x27;allow *&#x27;</span><br><span class="hljs-comment">#查看是否生产 mgr.node29的认证秘钥</span><br>[root@node29 ceph-node29]<span class="hljs-comment"># ceph auth get mgr.node29</span><br>exported keyring <span class="hljs-keyword">for</span> mgr.node29<br>[mgr.node29]<br>key = AQBE/OBi5oFENxAAj5QZVDRi7NMOveXQTjathA==<br>caps mon = <span class="hljs-string">&quot;allow *&quot;</span><br>caps osd = <span class="hljs-string">&quot;allow *&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>创建mgr的数据目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> /var/lib/ceph/mgr/ceph-&#123;hostname&#125;/</span><br>mkdir /var/lib/ceph/mgr/ceph-node29<br></code></pre></td></tr></table></figure></li><li><p>将刚才生成的秘钥导出为 keyring</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">ceph auth get mgr.node29 -o <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/ceph/mg</span>r<span class="hljs-regexp">/ceph-node29/</span>keyring<br></code></pre></td></tr></table></figure></li><li><p>启动mgr</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ceph-mgr -i &#123;hostname&#125;</span><br>ceph-mgr -i mgr.node29<br></code></pre></td></tr></table></figure></li></ol><h3 id="添加osd"><a href="#添加osd" class="headerlink" title="添加osd"></a>添加osd</h3><p>L版本中  ceph-disk  都被 ceph-volum 取代了，下面都是都使用ceph-volume 创建osd</p><h4 id="傻瓜式安装："><a href="#傻瓜式安装：" class="headerlink" title="傻瓜式安装："></a>傻瓜式安装：</h4><p>用  ceph-volume 添加里面有很多细节，我看安装的日志，好像是执行了很多脚本，这里面具体细节原理，以后再补充（留坑）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#ceph-volume inventory 可以用于检测这个磁盘能否做 osd </span><br>[root@node29 ceph]<span class="hljs-comment"># ceph-volume inventory /dev/sdd3</span><br><br>====== Device report /dev/sdd3 ======<br><br>     available                 True<br>     rejected reasons          <br>     path                      /dev/sdd3<br>     device <span class="hljs-built_in">id</span>                 QEMU_HARDDISK_drive-scsi0-0-0-1<br>     human readable size       50.00 GB<br>[root@node29 ceph]<span class="hljs-comment"># </span><br><br></code></pre></td></tr></table></figure><ol><li><p>用 ceph-volume 创建osd（osd在其他服务器上）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#将其他其他节点的硬盘用做osd，需要有认证文件 </span><br><span class="hljs-comment"># 将/var/lib/ceph/bootstrap-osd/ceph.keyring 拷贝到对应的服务上</span><br><span class="hljs-comment"># 还需要拷贝相应的ceph配置文件</span><br><span class="hljs-comment">#使用 ceph-volume 在osd节点创建osd </span><br>sudo ceph-volume lvm create --data /dev/hdd1<br><br><br></code></pre></td></tr></table></figure></li><li><p>激活 osd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">生产osd 可以查看osd 的<span class="hljs-built_in">id</span> 和fsid</span><br>[root@node31 ~]# ceph-volume lvm list<br><br><br>====== osd.2 =======<br><br>  [block]       /dev/ceph-ffbb3830-6bbf-4c6a-9e64-4d2817e64965/osd-block-5b5f3d72-caed-4369-91c1-c1667951a5e7<br><br>      block device              /dev/ceph-ffbb3830-6bbf-4c6a-9e64-4d2817e64965/osd-block-5b5f3d72-caed-4369-91c1-c1667951a5e7<br>      block uuid                ri9l8O-g17I-s2wn-memc-vJt0-B3E1-B2tSdX<br>      cephx lockbox secret      <br>      cluster fsid              311a4057-0837-4af8-92ab-a8053e4a3a57<br>      cluster name              ceph<br>      crush device class        None<br>      encrypted                 0<br>      osd fsid                  5b5f3d72-caed-4369-91c1-c1667951a5e7<br>      osd id                    2<br>      osdspec affinity          <br>      type                      block<br>      vdo                       0<br>      devices                   /dev/sdb<br><span class="hljs-meta prompt_">#</span><span class="language-bash">同过<span class="hljs-built_in">id</span> 和fsid 激活 osd</span> <br><br>sudo ceph-volume lvm activate 2 5b5f3d72-caed-4369-91c1-c1667951a5e7<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">如果osd 挂掉了    osd tree 里  状态为dowm</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">可以使用 systemctl restart重启服务，  @后面数字为 osd序号</span><br>systemctl restart ceph-osd@3.service<br></code></pre></td></tr></table></figure></li><li><p>验证</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#ceph -s 可以查看</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#需要一个 uuid</span><br><span class="hljs-comment">#以下相当于执行shell 脚本（只是抽出来一条一条执行）</span><br>[root@node31 ~]<span class="hljs-comment"># UUID=$(uuidgen)</span><br><span class="hljs-comment">#UUID 会保存到当前bash 环境中</span><br>[root@node31 ~]<span class="hljs-comment"># echo $UUID</span><br>47225359-3e97-4c95-b1ae-992339d44ddc<br><br>[root@node31 ~]<span class="hljs-comment"># OSD_SECRET=$(ceph-authtool --gen-print-key)</span><br>[root@node31 ceph-4]<span class="hljs-comment"># echo $OSD_SECRET</span><br>AQCotPVihM3rDBAAJ1ikAGBHtti5ogVSrZ/xRg==<br>[root@node31 ceph-4]<span class="hljs-comment"># </span><br><br><br><span class="hljs-comment">#获取 OSD的id 其实也可以推断出来，osd tree 就可以看到  osd.&#123;number&#125;,新的 ID为  number+1 即可</span><br>ceph osd new <span class="hljs-variable">$UUID</span> <br>[root@node31 ceph-4]<span class="hljs-comment">#  ID = $(ceph osd new 2aff9fe6-eef8-4da2-9a03-d33ef062b2bb)</span><br>5<br><span class="hljs-comment">#注意，我这里是可以直接登录 集群的，如果你没有 keyring，需要想办法把 keyring 拷贝你要操作的机器上</span><br><span class="hljs-comment"># 创建osd目录  磁盘挂载的目录</span><br><br><span class="hljs-built_in">mkdir</span> /var/lib/ceph/osd/ceph-<span class="hljs-variable">$ID</span><br><br><span class="hljs-comment">#格式化磁盘  （为甚用xfs 还没弄清楚）</span><br>mkfs.xfs /dev/sdb<br><span class="hljs-comment">#挂载 </span><br>mount /dev/sdb /var/lib/ceph/osd/ceph-<span class="hljs-variable">$ID</span><br><br><span class="hljs-comment">#将 osd keyring 加入到 集群中</span><br>ceph-authtool --create-keyring /var/lib/ceph/osd/ceph-<span class="hljs-variable">$ID</span>/keyring \<br>     --name osd.<span class="hljs-variable">$ID</span> --add-key <span class="hljs-variable">$OSD_SECRET</span><br><br><span class="hljs-comment">#初始化</span><br>ceph-osd -i <span class="hljs-variable">$ID</span> --mkfs --osd-uuid <span class="hljs-variable">$UUID</span><br><br><span class="hljs-comment"># 启动 osd 服务 </span><br>systemctl start ceph-osd@<span class="hljs-variable">$ID</span><br><br><br></code></pre></td></tr></table></figure><h3 id="改变osd层级"><a href="#改变osd层级" class="headerlink" title="改变osd层级"></a>改变osd层级</h3><p>在部署 OSD 时，它们会自动添加到 CRUSH 映射中的主机存储桶下，这个存储桶以运行它们的节点命名，默认是平面节点层次，但实际上为了故障隔离，可以添加不同的 bucket类型 到默认的层级中， 如 osd(device)host，chassis，rack，row，datacenter，zone，region，root等<br><strong>实现 层级可以是  rack -&gt; host -&gt; osd</strong></p><ol><li><p>添加rack </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">添加rack</span><br>ceph osd crush add-bucker rack01 rack<br></code></pre></td></tr></table></figure></li><li><p>改变层级</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">默认是 osd直接在host下的，所以要需要修改host的root</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">ceph osd crush move 所在层级名 父层级名</span><br>ceph osd crush move node31 rack=rack03<br></code></pre></td></tr></table></figure></li><li><p>改变后效果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@node29 ceph-node29]# ceph osd tree<br>ID  CLASS WEIGHT  TYPE NAME           STATUS REWEIGHT PRI-AFF <br> -1       0.87900 root default                                <br> -9       0.29300     rack rack01                             <br> -3       0.29300         host node29                         <br>  0   hdd 0.29300             osd.0       up  1.00000 1.00000 <br>-10       0.29300     rack rack02                             <br> -5       0.29300         host node30                         <br>  1   hdd 0.29300             osd.1       up  1.00000 1.00000 <br>-11       0.29300     rack rack03                             <br> -7       0.29300         host node31                         <br>  2   hdd 0.29300             osd.2       up  1.00000 1.00000 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">weight 是指定osd对应磁盘大小，</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">REWEIGHT</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="添加池"><a href="#添加池" class="headerlink" title="添加池"></a>添加池</h3><p>Ceph 的池是一个用来存储对象的逻辑分区，每个池中有一定数量pg，通过pg可以吧一定数量的对象映射到不同OSD中，</p><ol><li>创建pool</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#ceph osd pool create &#123;pool-name&#125; [&#123;pg-num&#125; [&#123;pgp-num&#125;]] [replicated] \[crush-rule-name] [expected-num-objects]</span><br><span class="hljs-comment">#PG是指定存储池存储对象的目录有多少个，PGP是存储池PG的OSD分布组合个数</span><br><span class="hljs-comment">#可以指定 </span><br>[root@node29 ceph-node29]<span class="hljs-comment"># ceph osd pool create pool_A1 128 128 replicated </span><br>pool <span class="hljs-string">&#x27;pool_A1&#x27;</span> created<br><br></code></pre></td></tr></table></figure><ol start="2"><li>查看 pool 信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看创建的池  rados lspools也可以  ceph osd pool ls detail可以查看更多信息</span><br>[root@node29 ceph-node29]<span class="hljs-comment"># ceph osd lspools</span><br>2 pool_A1<br>[root@node29 ceph-node29]<span class="hljs-comment"># ceph osd pool ls detail</span><br>pool 2 <span class="hljs-string">&#x27;pool_A1&#x27;</span> replicated size 3 min_size 2 crush_rule 0 object_hash rjenkins pg_num 128 pgp_num 128 autoscale_mode warn last_change 38 flags hashpspool stripe_width 0<br><br><span class="hljs-comment">#查看 新建pool 的信息  </span><br><span class="hljs-comment"># ceph osd pool get &#123;poolname&#125; &#123;value&#125;</span><br><span class="hljs-comment"># value 是你想获得的信息</span><br><span class="hljs-comment">#eg</span><br>[root@node29 ceph-node29]<span class="hljs-comment"># ceph osd pool get pool_A1 min_size</span><br>min_size: 2<br>[root@node29 ceph-node29]<span class="hljs-comment"># ceph osd pool get pool_A1 pg_num</span><br>pg_num: 128<br>[root@node29 ceph-node29]<span class="hljs-comment"># ceph osd pool get pool_A1 crush_rule</span><br>crush_rule: replicated_rule<br>[root@node29 ceph-node29]<span class="hljs-comment"># ceph osd pool get pool_A1 size</span><br>size: 3<br><span class="hljs-comment">#如果忘记value参数，可以  ceph osd pool get 就会有其他value 参数了</span><br><br><span class="hljs-comment">#查看当前池的配额 对多可以存多少个对象 ，最多可以保存多大数据</span><br>[root@node29 ceph-3]<span class="hljs-comment"># ceph osd pool get-quota pool_A1</span><br>quotas <span class="hljs-keyword">for</span> pool <span class="hljs-string">&#x27;pool_A1&#x27;</span>:<br>  max objects: 1k objects<br>  max bytes  : 10 GiB<br>[root@node29 ceph-3]<span class="hljs-comment"># </span><br><br><br></code></pre></td></tr></table></figure><ol start="3"><li>修改 pool 配置信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#ceph osd pool set &#123;pool-name&#125; &#123;key&#125; &#123;value&#125;</span><br><span class="hljs-comment">#如更改 pool的副本数</span><br>ceph osd pool <span class="hljs-built_in">set</span> pool_A1 size 3 <br><span class="hljs-comment">#这里面的 key 也就是上一步 get 里的value，不知道key参数可以参考上一步（当然官方文档有更详细的解释）</span><br><br><span class="hljs-comment">#设置pool里面最大object数量</span><br>ceph osd pool set-quota &#123;poolname&#125; max_objects &#123;number&#125;<br>[root@node29 ceph-node29]<span class="hljs-comment"># ceph osd pool set-quota pool_A1 max_objects 1000</span><br>set-quota max_objects = 1000 <span class="hljs-keyword">for</span> pool pool_A1<br><br><br><span class="hljs-comment">#设置pool里面最大容量</span><br>ceph osd pool set-quota &#123;poolname&#125;  max_bytes &#123;byte number&#125;<br>[root@node29 ceph-node29]<span class="hljs-comment"># ceph osd pool set-quota pool_A1  max_bytes $((10 * 1024 * 1024 * 1024))</span><br>set-quota max_bytes = 10737418240 <span class="hljs-keyword">for</span> pool pool_A1<br><br>[root@node29 ceph-node29]<span class="hljs-comment"># ceph osd pool ls detail</span><br>pool 2 <span class="hljs-string">&#x27;pool_A1&#x27;</span> replicated size 3 min_size 2 crush_rule 0 object_hash rjenkins pg_num 128 pgp_num 128 autoscale_mode warn last_change 41 flags hashpspool max_bytes 10737418240 max_objects 1000 stripe_width 0<br><br></code></pre></td></tr></table></figure><ol start="4"><li>删除pool</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#如果直接删除 </span><br>ceph osd pool delete    &#123;poolname&#125;  &#123;poolname&#125; --yes-i-really-really-mean-it<br><span class="hljs-comment">#如果直接执行 可能会出现</span><br>Error EPERM: pool deletion is disabled; you must first <span class="hljs-built_in">set</span> the mon_allow_pool_delete config option to <span class="hljs-literal">true</span> before you can destroy a pool<br><span class="hljs-comment">#解决方案 : 在配置文件 ceph.conf 中添加  mon allow pool delete = true</span><br><br></code></pre></td></tr></table></figure><h3 id="rados命令实践"><a href="#rados命令实践" class="headerlink" title="rados命令实践"></a>rados命令实践</h3><h4 id="1-池相关命令"><a href="#1-池相关命令" class="headerlink" title="1. 池相关命令"></a>1. 池相关命令</h4><p>再上一步添加池后，使用 rados命令对池增删数据，当然 rados也可以对创建池</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#往池里加入一个对象，对象名为 obj_A  文件名为 mem_history</span><br>[root@node29 home]<span class="hljs-comment"># rados -p pool_A1 put obj_A mem_history</span><br><span class="hljs-comment">#查看已插入的对象</span><br>[root@node29 home]<span class="hljs-comment"># rados -p pool_A1 ls</span><br>obj_A<br><span class="hljs-comment">#查看对象信息</span><br>[root@node29 home]<span class="hljs-comment">#  rados -p pool_A1 stat obj_A </span><br>pool_A1/obj_A mtime 2022-07-28 17:34:54.000000, size 7943881<br><span class="hljs-comment">#查看资源池信息</span><br>[root@node29 home]<span class="hljs-comment"># rados df -p pool_A1</span><br>POOL_NAME   USED OBJECTS CLONES COPIES MISSING_ON_PRIMARY UNFOUND DEGRADED RD_OPS      RD WR_OPS      WR USED COMPR UNDER COMPR <br>pool_A1   23 MiB       1      0      3                  0       0        0     11 7.6 MiB      5 7.6 MiB        0 B         0 B <br><br>total_objects    1<br>total_used       3.0 GiB<br>total_avail      897 GiB<br>total_space      900 GiB<br><span class="hljs-comment"># 资源池可以看出 存入了一个对象，占用了23m的空间 </span><br><br><span class="hljs-comment">#获取池里的对象内容 并导出来 -p 指的是poolname  get 后面 对象名 紧接着 输出的文件</span><br>[root@node29 home]<span class="hljs-comment"># rados -p pool_A1 get obj_A tmp | head -n1 tmp</span><br>root     516703  1.2  0.1 16320864 419544 ?     Sl   09:15   0:10 python3 /opt/expontech/obs-manager/obs_manager/csm_manager_status.py<br>[root@node29 home]<span class="hljs-comment"># </span><br><br><span class="hljs-comment">#对象 追加内容</span><br><span class="hljs-comment"># rados -p pool_A1 append obj_A mem_history</span><br><br><br><span class="hljs-comment">#删除 对象</span><br><span class="hljs-comment"># rados -p pool_A1 rm obj_A</span><br><br><br></code></pre></td></tr></table></figure><p>…..</p><p>​</p>]]></content>
    
    
    
    <tags>
      
      <tag>ceph</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>存储通识</title>
    <link href="/2022/07/07/%E5%AD%98%E5%82%A8%E9%80%9A%E8%AF%86/"/>
    <url>/2022/07/07/%E5%AD%98%E5%82%A8%E9%80%9A%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2 id="io模型"><a href="#io模型" class="headerlink" title="io模型"></a>io模型</h2><p>一些关于io的知识</p><h3 id="iops"><a href="#iops" class="headerlink" title="iops"></a>iops</h3><blockquote><p>  iops（Input&#x2F;Output Operations Per Second），每秒能进行多少次io（读写次数），是衡量磁盘性能的主要指标之一</p></blockquote><h2 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h2><blockquote><p>  RAID （ Redundant Array of Independent Disks ）即独立磁盘冗余阵列，简称为「磁盘阵列」，其实就是用多个独立的磁盘组成在一起形成一个大的磁盘系统，从而实现比单块磁盘更好的存储性能和更高的可靠性。</p></blockquote><h3 id="RAID0"><a href="#RAID0" class="headerlink" title="RAID0"></a>RAID0</h3><p>通俗的理解：数据分割成 n分，并行写入 n个磁盘中，但是启动一个磁盘坏了，整体数据也丢失了，不可靠</p><p>技术上分析： </p><ul><li>RAID0 在逻辑上讲多个磁盘横向划分为 Stripe（条带），而 Strip是条带单元，称之为Segment，如下图 有五个条带单元构成了一个Stripe，这个条带的宽度是磁盘数即 5，条带的深度为4（条带单元的块个数）</li><li>当系统下发IO是，RAID控制器会根据读写块以及条带深度均衡 io（尽量让每个磁盘都有活干），当然也有不理想的时候读取的刚好都是在一个 Segment中，这个均衡就没意思了，而且还浪费资源，若是想要最大化的均衡io，让Segment的粒度更小，更多占用物理盘；</li><li>由于冗余处理，读取速度快，空间使用率百分百，不足的就是数据不可靠</li></ul><p><img src="http://imt.rui.vin/202207180018451.png" alt="image-20220717231603585"></p><ul><li><p>条带化技术</p><p>当只有一块磁盘时候，很多进程访问磁盘，可能会出现磁盘冲突操作系统会限制访问，进程则会堵塞等待，  而条带化技术可以自动的将I&#x2F;O 的负载均衡到多个物理磁盘上，条带化技术就是将一块连续的数据分成很多小部分并把他们分别存储到不同磁盘上去。这就能使多个进程同时访问数据的多个不同部分而不会造成磁盘冲突，而且在需要对这种数据进行顺序访问的时候可以获得最大程度上的I&#x2F;O 并行能力，从而获得非常好的性能。很多操作系统、磁盘设备供应商、各种第三方软件都能做到条带化。</p></li></ul><h3 id="RAID1"><a href="#RAID1" class="headerlink" title="RAID1"></a>RAID1</h3><p>通俗理解： 在RAID0的缺点上该进，增加一个镜像磁盘作为备份，有个磁盘坏了可以从备用磁盘中读取，但读写翻倍，性能下降，稳定性高</p><p>技术上分析：</p><p>改进对数据的保护措施 ，每一个物理块都有一个备份，写的时候要写两份，写的速度下降了</p><p><img src="http://imt.rui.vin/202207200002647.png" alt="image-20220720000224691"></p><h3 id="RAID2"><a href="#RAID2" class="headerlink" title="RAID2"></a>RAID2</h3><p>​    RAID2 比较特殊，已经淘汰了….  可以理解为 RAID0带的深度为1，这里的1 是1b，但是我们知道磁盘最小读写单位是一个扇区 512b，那不是浪费了？ 加入现在有四块磁盘，写512b数据，控制器会对数据进行分割，怎么分呢？第一块磁盘写入的顺序是 1，5，14，第二块磁盘写入的顺序是 2，6，10，15，以此类推，就是说把数据分割1b的粒度分割，逐个写到磁盘，写完的话每个磁盘占了128b，剩下的空间怎么办呢？等下次的写的时候，把数据先读出来，并且和待写入的数据合并，然后再按照刚才的方式写数据… 这个效率肯定是大打折扣，但是这样可以保证任意时刻，这个每个盘都不会空闲，性能压榨到极致，也说明了，为什么比较适用于大io，但是这技术，可以提高 连续io。</p><h3 id="RAID3"><a href="#RAID3" class="headerlink" title="RAID3"></a>RAID3</h3><p>​RAID2 条带的Segment深度是1b，在RAID3中其segment深度通常为一个扇区或者多个扇区作为单位划分数据，保持磁盘并行性；此外使用XOR校验算法进行判断数据是否有错，但是无法定位到那一位（无论多少块磁盘，只需要一块校验盘）；</p><p>​举个例子，4个数据盘和一个校验盘使用的是RAID3，条带长度4k，写入4k的数据，此时写入数据刚好和条带一样大；控制器在第一个磁盘写入1,2块，第二个磁盘写入3,4，以此类推，4k的数据分散到四个磁盘，此是是并行写入的；如果是只写入2k的话，只能读写两个磁盘，也就是说只能获得两倍的磁盘性能，剩下的就浪费了，调高效率的方法是如果此是还有其他io需要用到磁盘，那么可以合并到一次，实现并发io</p><p>对于随机io，RAID并不能优化，随机io耗费时间在于磁头的寻道时间，</p><hr><p><strong>待更新…..</strong></p><p>RAID2： 基于前两种引用了一种数据纠错算法进行保证数据正确性，一种叫做汉明码的算法，RAID2允许一块一快磁盘出错，但是两块以上就不可以了</p><p>RAID3： 基于RAID2的校验率提升了（XOR算法），利用奇偶校验信息来恢复故障硬盘上的数据</p>]]></content>
    
    
    
    <tags>
      
      <tag>存储</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>近期的安排</title>
    <link href="/2022/07/07/%E8%BF%91%E6%9C%9F%E7%9A%84%E5%AE%89%E6%8E%92/"/>
    <url>/2022/07/07/%E8%BF%91%E6%9C%9F%E7%9A%84%E5%AE%89%E6%8E%92/</url>
    
    <content type="html"><![CDATA[<p>  <strong>当初</strong> 搞这blog 为了输出一些东西，当然也是为了找工作（虽然我也不知道这个在我找工作的时候有没有起到作用）； 就目前而言，找工作这事可以告一段落了，现在是开启了职场生活，现在做的工作和当初预想的有所偏差，阴差阳错走到了存储的方向，既然走到这里了，那就是最好的安排，当然这也是结合当下认知做的最好的选择! 所以呢，以后的 blog大部分关于 分布式存储方面的，这里就组做一个输出平台吧，记录下小白职场成长经历。</p><p>​</p><img src="http://imt.rui.vin/202207080003802.png" alt="image-20220708000303424" style="zoom:50%;">]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo 搭建记录</title>
    <link href="/2022/06/09/hexo%E6%90%AD%E5%BB%BA%20&amp;&amp;%20%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/06/09/hexo%E6%90%AD%E5%BB%BA%20&amp;&amp;%20%E4%BC%98%E5%8C%96%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>就记录下 blog ，一开始 是放在GitHub page上，但是 哪个访问太慢了，而且有时候 push不上去，于是后来 在直接在 服务器上 运行hexo，刚 开始想怎么在本地 直接发布，并并部署在 服务器，一开始的做法 ， git 同步 hexo整个代码，额。。。后来发现只需要同步 public的文件夹的内容就可以，服务器后来也没有用 hexo 部署，而是 用Nginx  做静态资源的服务器，端口直接定向到 80，后面 还加了 git hook，实现git自动 pull 部署， 目前 大致 框架算是完成好了（能写就行的原则），后续在添加功能</p><h3 id="Nginx-做域名指向"><a href="#Nginx-做域名指向" class="headerlink" title="Nginx 做域名指向"></a>Nginx 做域名指向</h3><p>​域名备案完成，想使用域名代替ip，域名解析指向ip就行，但没那么简单，最后还是修改了 Nginx 的配置文件</p><h3 id="图床的搭建"><a href="#图床的搭建" class="headerlink" title="图床的搭建"></a>图床的搭建</h3><p>​起初： 直接把图片上传，好像装个什么插件(这个忘了)，用是挺好用的，但有时候路径不对，还没找到原因</p><p>​    后面： 一直想尝试用图床，但懒得折腾；恰好现在有 备案好的域名，于是 就捣鼓了下七牛云的云储存，其实也不难~</p><h4 id="1-注册七牛云并实名-然后点-对象存储-创建空间"><a href="#1-注册七牛云并实名-然后点-对象存储-创建空间" class="headerlink" title="1. 注册七牛云并实名 然后点  对象存储  创建空间"></a>1. 注册七牛云并实名 然后点  <strong>对象存储</strong>  创建空间</h4><p>​![image-20220206134637817](img&#x2F;hexo搭建 &amp;&amp; 优化过程记录&#x2F;image-20220206134637817.png)</p><p>![image-20220206134748451](img&#x2F;hexo搭建 &amp;&amp; 优化过程记录&#x2F;image-20220206134748451.png)</p><h4 id="2-添加域名"><a href="#2-添加域名" class="headerlink" title="2.添加域名"></a>2.添加域名</h4><p>如果你自己没有备案的域名只能 用七牛云的但是只有30 天…..</p><p><img src="http://imt.rui.vin/image-20220206135215658.png" alt="image-20220206135215658"></p><p>剩下就是添加域名啦</p><p>![image-20220206135312503](img&#x2F;hexo搭建 &amp;&amp; 优化过程记录&#x2F;image-20220206135312503.png)</p><p>缓存配置 我直接选默认（我也还没搞明白这个怎么用…）</p><p>![image-20220206135405161](img&#x2F;hexo搭建 &amp;&amp; 优化过程记录&#x2F;image-20220206135405161.png)</p><p>这里需要注意的是  域名的问题：  我直接用一级域名 会404，可能是因为 一级域名 被Nginx解析了，要在Nginx配置文件中修改下，于是我用了个二级域名（这个可以去对应的域名网站解析），一切完成后 下载 </p><h4 id="3-PicGO-图床上传工具"><a href="#3-PicGO-图床上传工具" class="headerlink" title="3.PicGO 图床上传工具"></a>3.PicGO 图床上传工具</h4><p>存储区域： 华南的是z2，以此类推</p><p>key和secretkey可以在找到</p><p><img src="http://imt.rui.vin/202202061425030.png" alt="image-20220206140329112"></p><p><img src="http://imt.rui.vin/202202061425172.png" alt="image-20220206140148172"></p><p>我用 typora   这个可以直接贴图上传，在偏好设置 配一下就可以</p><p><img src="http://imt.rui.vin/202202061425433.png" alt="image-20220206140424154"></p><h3 id="hexo-功能完善记录"><a href="#hexo-功能完善记录" class="headerlink" title="hexo 功能完善记录"></a>hexo 功能完善记录</h3><h4 id="实现文章置顶功能"><a href="#实现文章置顶功能" class="headerlink" title="实现文章置顶功能"></a>实现文章置顶功能</h4><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">$ npm uninstall hexo-generator-index --save<br><br>$ npm install hexo-generator-index-pin-top --save<br></code></pre></td></tr></table></figure><p>在 format 中 加入 top :1 </p><p><img src="http://imt.rui.vin/202203101455909.png" alt="image-20220310145545576"></p><p>置顶了但是没有标志</p><p>&#x2F;blog&#x2F;themes&#x2F;next&#x2F;layout&#x2F;_macro 目录下的<code>post.swig</code>文件，定位到<code>&lt;div class=&quot;post-meta&quot;&gt;</code>标签下，插入如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;% <span class="hljs-keyword">if</span> post.<span class="hljs-property">top</span> %&#125;<br>  &lt;i <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;fa fa-thumb-tack&quot;</span>&gt;&lt;/i&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">7D26CD</span>&gt;</span>置顶<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>&#123;% endif %&#125;<br></code></pre></td></tr></table></figure><p>效果展示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">        &lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;post-meta&quot;</span>&gt;<br>          <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post-time&quot;</span>&gt;</span></span><br><span class="language-xml">在此之下插入代码，包含在 span块内        </span><br><span class="language-xml">          &#123;% if post.top %&#125;</span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">i</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;fa fa-thumb-tack&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">i</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">7D26CD</span>&gt;</span>置顶<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;post-meta-divider&quot;</span>&gt;</span>|<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">          &#123;% endif %&#125;</span><br></code></pre></td></tr></table></figure><h4 id="实现首页背景每天更新图片"><a href="#实现首页背景每天更新图片" class="headerlink" title="实现首页背景每天更新图片"></a>实现首页背景每天更新图片</h4><p>今天打开必应搜索，突然突然想到我的blog背景图能不能和必应一样每天更新，于是搜了下必应背景图的api，果然有，于是直接在 配置文件上更换了这个，但是第一次加载没那么快了</p><h4 id="开启评论功能"><a href="#开启评论功能" class="headerlink" title="开启评论功能"></a>开启评论功能</h4><p>这个主题都集成了好多功能！！ 评论模块也有，这次选用 leancloud 提供的平台，只需要注册 拿到 api key就行，一步搞定…. 我在想自己有服务器，是不是也可以在后台搭建个评论系统 ; 这里留一个坑吧…. leancloud好像提供提供许多服务的</p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 常用命令</title>
    <link href="/2022/05/15/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/05/15/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>记录一些高频，功能强大的命令 </p><h3 id="mpstat-："><a href="#mpstat-：" class="headerlink" title="mpstat ："></a>mpstat ：</h3><p>​ 可以用来记录查看 多核心cpus 的运行信息 （具体用法可以看 查看man手册）</p><h3 id="vmstat："><a href="#vmstat：" class="headerlink" title="vmstat："></a>vmstat：</h3><p>​ 即时显示内存使用情况的工具</p><p><img src="http://imt.rui.vin/202206211128187.png" alt="image-20220621112805965"></p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">r  :The number of processes waiting for run time. 等待运行时间的进程数，即等待的进程数、<br>b  :The number of processes <span class="hljs-keyword">in</span> uninterruptible <span class="hljs-keyword">sleep</span>. 在等待io的进程数<br><span class="hljs-symbol">swpd:</span> 虚拟内存的使用量<br>free：空闲内存量<br>buff：缓冲区中的内存<br>cache：被用来做为高速缓存的内存数<br><span class="hljs-symbol">si:</span> 从磁盘交换到内存的交换页数量，单位：KB/秒。<br><span class="hljs-symbol">so:</span> 从内存交换到磁盘的交换页数量，单位：KB/秒。<br><span class="hljs-symbol">bi:</span> 发送到块设备的块数，单位：块/秒。<br><span class="hljs-symbol">bo:</span> 从块设备接收到的块数，单位：块/秒。<br><span class="hljs-symbol">in:</span> 每秒的中断数，包括时钟中断。<br><span class="hljs-symbol">cs:</span> 每秒的环境（上下文）转换次数。<br>us：用户进程使用的时间 。以百分比表示。<br>sy：系统进程使用的时间。 以百分比表示。<br>id：中央处理器的空闲时间 。以百分比表示。<br>wa：io等待时间<br><span class="hljs-keyword">st</span>：Time stolen from a virtual machine<br></code></pre></td></tr></table></figure><h3 id="sar："><a href="#sar：" class="headerlink" title="sar："></a>sar：</h3><p>sar  系统的 CPU、运行队列、磁盘读写（I&#x2F;O）、分区（交换区）、内存、CPU 中断和网络性能数据</p><p><code>[root@localhost ~]# sar [options] [-o filename] interval [count]</code></p><p>[<strong>options</strong>]</p><table><thead><tr><th>-A</th><th align="left">显示系统所有资源设备（CPU、内存、磁盘）的运行状况。</th></tr></thead><tbody><tr><td>-u</td><td align="left">显示系统所有 CPU 在采样时间内的负载状态。</td></tr><tr><td>-P</td><td align="left">显示当前系统中指定 CPU 的使用情况。</td></tr><tr><td>-d</td><td align="left">显示系统所有硬盘设备在采样时间内的使用状态。</td></tr><tr><td>-r</td><td align="left">显示系统内存在采样时间内的使用情况。</td></tr><tr><td>-b</td><td align="left">显示缓冲区在采样时间内的使用情况。</td></tr><tr><td>-v</td><td align="left">显示 inode 节点、文件和其他内核表的统计信息。</td></tr><tr><td>-n</td><td align="left">显示网络运行状态，此选项后可跟 DEV（显示网络接口信息）、EDEV（显示网络错误的统计数据）、SOCK（显示套接字信息）和 FULL（等同于使用 DEV、EDEV和SOCK）等，有关更多的选项，可通过执行 man sar 命令查看。</td></tr><tr><td>-q</td><td align="left">显示运行列表中的进程数、进程大小、系统平均负载等。</td></tr><tr><td>-R</td><td align="left">显示进程在采样时的活动情况。</td></tr><tr><td>-y</td><td align="left">显示终端设备在采样时间的活动情况。</td></tr><tr><td>-w</td><td align="left">显示系统交换活动在采样时间内的状态。</td></tr></tbody></table><h3 id="iostat"><a href="#iostat" class="headerlink" title="iostat:"></a>iostat:</h3><p>输出CPU和磁盘I&#x2F;O相关的统计信息.</p><p><strong>iostat [选项] [&lt;时间间隔&gt;] [&lt;次数&gt;]</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何对大文件进行排序</title>
    <link href="/2022/04/20/%E5%A6%82%E4%BD%95%E5%AF%B920G%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/04/20/%E5%A6%82%E4%BD%95%E5%AF%B920G%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<span id="more"></span><p>排序问题虽然有了解，很多只是基于理论上，实践比较少，刚好最近遇到个问题：</p><meta name="referrer" content="no-referrer"><p><img src="http://imt.rui.vin/202204201529678.png" alt="侵删"></p><p><img src="http://imt.rui.vin/202204201538979.png" alt="image-20220420153810671"></p><p>这个以前遇到过类似的问题， 假如 你有一个20GB的文件，对文件的内容排序，内存限制在 1G，你要怎么排序</p><p>以前有做过总结，就是分割文件，逐个文件先排好序，最后然后再合并，说起来很简单，但做起来就。。。。 </p><p>这次题目有 分割文件，我下载了这个压缩包，解压 看有1000个 20M的文件 </p><p><img src="http://imt.rui.vin/202204201531613.png" alt="image-20220420153113356"></p><p>思路：   将这个一 千个文件，文件名读取出来，按照条件逐个抽出来，并且排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">read_lryic</span><span class="hljs-params">(<span class="hljs-type">char</span> *path)</span></span><br><span class="hljs-function"></span>&#123;<br>    DIR *dir = <span class="hljs-built_in">opendir</span>(path); <span class="hljs-comment">//打开目录文件</span><br>    cout &lt;&lt; path &lt;&lt; endl;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> *entry;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((entry = <span class="hljs-built_in">readdir</span>(dir)) != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strstr</span>(entry-&gt;d_name, <span class="hljs-string">&quot;.txt&quot;</span>))<br>        &#123;<br>            filename.<span class="hljs-built_in">push_back</span>(entry-&gt;d_name);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d %s\n&quot;</span>, i++, entry-&gt;d_name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在文件名有了，进行筛选排序，这里用map来存放临时的数据，key 为时间戳，value 为对应的数据，为什么用map，map是会自动自动排序，根据key的值，而这里的没条数据都是 json，用了一个jsoncpp 库（如果用 go 估计已经写完了），原本想直接解析字符串，发现有点麻烦，还是用库吧， 提取出  时间戳，作为key，提取完一个文件后，重新写入到新的文件里</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortfile</span><span class="hljs-params">()</span></span>&#123;<br>    Json::Reader reader;<br>    Json::Value obj;<br>    <span class="hljs-comment">//读文件名字 </span><br>    <span class="hljs-built_in">read_lryic</span>(<span class="hljs-string">&quot;/home/hrp/Cpp/recore/&quot;</span>);<br>    string file;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> str : filename)&#123;<br>        file = <span class="hljs-string">&quot;/home/hrp/Cpp/recore/&quot;</span> + str;<br>        <span class="hljs-function">std::ifstream <span class="hljs-title">fIn</span><span class="hljs-params">(file)</span></span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (fIn)<br>        &#123;<br>            std::string str;<br>            <span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">getline</span>(fIn, str))<br>            &#123;<br>                <span class="hljs-keyword">if</span>(str.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;张三&quot;</span>) != string::npos)&#123;<br>                    <br>                    <span class="hljs-comment">//std::cout &lt;&lt; i++ &lt;&lt; endl;</span><br>                    reader.<span class="hljs-built_in">parse</span>(str, obj);<br>                    <span class="hljs-type">long</span> timestamp = obj[<span class="hljs-string">&quot;timestamp&quot;</span>].<span class="hljs-built_in">asInt64</span>();   <br>                    ret[timestamp] = str;             <br>                &#125;<br>            &#125; <br>            cout &lt;&lt; file &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Open file faild.&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-function">ofstream <span class="hljs-title">out1</span><span class="hljs-params">(file)</span></span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i=ret.<span class="hljs-built_in">begin</span>();i!=ret.<span class="hljs-built_in">end</span>();i++)&#123;<br>            <span class="hljs-comment">//cout &lt;&lt; i-&gt;second;</span><br>            out1 &lt;&lt; i-&gt;second ;<br>            out1 &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> ;<br>        &#125;<br>        ret.<span class="hljs-built_in">clear</span>();<br>        out1.<span class="hljs-built_in">close</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在完成 按照条件 完成每个文件的排序了</p><p>接下来就是 归并，如何归并呢，现在有1000个文件，逐个遍历这1000个文件，每次都提取一行来，一次遍历 提取了1000行数据，此时可以用大顶堆的特性，就是1000个数据放进这个大顶堆，堆顶肯定是最大数，按照这个特性，先读取一千条，放在大顶堆了，每次 pop出堆顶的（肯定最大），然后要 补上一个，读哪个文件的呢，肯定是pop出去哪条数据所在的文件，所以现在就是要去那个文件里再读一条数据，以此类推，说是这样说 ，但是这题还有其他附加条件（根据时间分类写）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">clock_t</span> start,end;<span class="hljs-comment">//定义clock_t变量</span><br>   start = <span class="hljs-built_in">clock</span>();  <span class="hljs-comment">//开始时间</span><br><br>   Json::Reader reader;<br>   Json::Value obj;<br><br>   map&lt;string,ifstream*&gt; filesmap;<br>   map&lt;string,ofstream*&gt; outfile;<br><br>   <span class="hljs-built_in">sortfile</span>();<br>   <span class="hljs-type">time_t</span> tt;<br>   <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tm</span> *ttime;<br><span class="hljs-comment">//用 map 保存文件的读写流，这里是读</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> file: filename)&#123;<br>       <span class="hljs-keyword">auto</span> temp = file;<br>       file = <span class="hljs-string">&quot;/home/hrp/Cpp/recore/&quot;</span> + temp;<br>       filesmap.<span class="hljs-built_in">emplace</span>(file, <span class="hljs-keyword">new</span> ifstream(file)); <br>   &#125;<br><span class="hljs-comment">//这里用c++ 的优先队列 来模拟堆，插入的数据  为 时间戳和文件的字符名字</span><br>  priority_queue&lt;pair&lt;<span class="hljs-type">long</span>, string&gt;&gt; topTime;<br>   map&lt;<span class="hljs-type">long</span>,string&gt; Temp;<br>   string data;<br><span class="hljs-comment">//先读取 全部文件的 第一条数据，push到 优先队列中 </span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter = filesmap.<span class="hljs-built_in">begin</span>(); iter != filesmap.<span class="hljs-built_in">end</span>(); iter++) &#123;<br>       std::<span class="hljs-built_in">getline</span>(*iter-&gt;second, data);<br><br>       reader.<span class="hljs-built_in">parse</span>(data, obj);<br>       <span class="hljs-type">long</span> timestamp = obj[<span class="hljs-string">&quot;timestamp&quot;</span>].<span class="hljs-built_in">asInt64</span>();<br>       <span class="hljs-function">pair&lt;<span class="hljs-type">long</span>,string&gt; <span class="hljs-title">b</span><span class="hljs-params">(timestamp,iter-&gt;first)</span></span>;<br><br>       topTime.<span class="hljs-built_in">push</span>(b);<br>       Temp[timestamp] = data;<br>   &#125;<br><span class="hljs-comment">// 现在 对队列操作，此时队列是 出一个，进一个，维持平衡，没有进，就一直出，知道 队列为空位止</span><br><span class="hljs-comment">// Temp 维护 这1000个数据，动态增减</span><br>   <span class="hljs-keyword">while</span> (!topTime.<span class="hljs-built_in">empty</span>())&#123;<br>       <span class="hljs-comment">// cout  &lt;&lt; Temp[topTime.top()] &lt;&lt; endl;</span><br>       <span class="hljs-comment">//时间戳转 日期</span><br>       <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tm</span> *ttime;<br>       tt = topTime.<span class="hljs-built_in">top</span>().first/<span class="hljs-number">1000</span>;<br>       ttime = <span class="hljs-built_in">localtime</span>(&amp;tt);<br>       <span class="hljs-type">char</span> formatime[<span class="hljs-number">64</span>];<br>       <span class="hljs-built_in">strftime</span>(formatime, <span class="hljs-number">64</span>, <span class="hljs-string">&quot;%Y-%m-%d&quot;</span>, ttime);<br>       <span class="hljs-function">string <span class="hljs-title">strtime</span><span class="hljs-params">(formatime)</span></span>;<br><span class="hljs-comment">//这里是写文件，根据时间戳 转换的日期来 写文件</span><br>       <span class="hljs-comment">// outfile   key 为文件名 value 对应的读写流</span><br>       <span class="hljs-comment">// 为 0 ，说明第一次，创建文件</span><br>       <span class="hljs-keyword">if</span>(outfile.<span class="hljs-built_in">count</span>(strtime)  == <span class="hljs-number">0</span>)&#123;<br>           <br>           outfile.<span class="hljs-built_in">emplace</span>(strtime,<span class="hljs-keyword">new</span> <span class="hljs-built_in">ofstream</span>(strtime));<br>           <span class="hljs-keyword">if</span> (!outfile[strtime]-&gt;<span class="hljs-built_in">is_open</span>()) <br>               cout &lt;&lt; strtime &lt;&lt; <span class="hljs-string">&quot;error&quot;</span> &lt;&lt; endl;<br>           *outfile[strtime] &lt;&lt; Temp[topTime.<span class="hljs-built_in">top</span>().first]+ <span class="hljs-string">&quot;\n&quot;</span>;<br>           Temp.<span class="hljs-built_in">erase</span>(topTime.<span class="hljs-built_in">top</span>().first);<br><br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-comment">//根据 日期写入 数据</span><br>           *outfile[strtime] &lt;&lt; Temp[topTime.<span class="hljs-built_in">top</span>().first] + <span class="hljs-string">&quot;\n&quot;</span>;<br>           Temp.<span class="hljs-built_in">erase</span>(topTime.<span class="hljs-built_in">top</span>().first);<br><br>       &#125;<br><span class="hljs-comment">// top是最大的，此时pop出去，记录下 pop去的是哪个文件 </span><br>       <span class="hljs-keyword">auto</span> TopTemp = topTime.<span class="hljs-built_in">top</span>();<br>       topTime.<span class="hljs-built_in">pop</span>();<br><br><span class="hljs-comment">//如果 读取到了，更行 优先队列的数据</span><br>       <span class="hljs-keyword">if</span>(std::<span class="hljs-built_in">getline</span>(*filesmap[TopTemp.second], data))&#123;<br>           reader.<span class="hljs-built_in">parse</span>(data, obj);<br>           <span class="hljs-type">long</span> timestamp = obj[<span class="hljs-string">&quot;timestamp&quot;</span>].<span class="hljs-built_in">asInt64</span>();<br>           <span class="hljs-function">pair&lt;<span class="hljs-type">long</span>,string&gt; <span class="hljs-title">b</span><span class="hljs-params">(timestamp,TopTemp.second)</span></span>;<br>           Temp[timestamp] = data;<br>           topTime.<span class="hljs-built_in">push</span>(b);<br>       &#125;<br>     <br><br>   &#125;<br><span class="hljs-comment">//最后 要关闭文件，才会保存</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> iter = outfile.<span class="hljs-built_in">begin</span>(); iter != outfile.<span class="hljs-built_in">end</span>(); iter++) &#123;<br>       iter-&gt;second-&gt;<span class="hljs-built_in">close</span>();<br>   &#125;<br>   end = <span class="hljs-built_in">clock</span>();   <span class="hljs-comment">//结束时间</span><br>   cout&lt;&lt;<span class="hljs-string">&quot;time = &quot;</span>&lt;&lt;<span class="hljs-built_in">double</span>(end-start)/CLOCKS_PER_SEC&lt;&lt;<span class="hljs-string">&quot;s&quot;</span>&lt;&lt;endl;  <span class="hljs-comment">//输出时间（单位：ｓ）</span><br><br><br></code></pre></td></tr></table></figure><p>运行的机器是：  腾讯云服务器   4核 4g</p><p><img src="http://imt.rui.vin/202204201626331.png" alt="耗时 117 .s"></p><img src="http://imt.rui.vin/202204201607730.png" alt="内存使用不大，500M 以内解决，就是 cpu 占用率高" style="zoom: 80%;">  <p><img src="http://imt.rui.vin/202204201609407.png" alt="排序好的"></p><p> <strong>总结：</strong></p><ul><li>认清了 知道 和 做到的差距！！！！！</li><li>有些api 日常少使用， 很不收悉，都是在查查查 </li><li>要先有整体思路  然后细化问题，逐个解决</li></ul><p>代码整体设计 不是很好，后续在改进， 用多线程 多路归并？</p>]]></content>
    
    
    
    <tags>
      
      <tag>有趣的问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cmake的初步使用</title>
    <link href="/2022/04/19/Cmake%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/04/19/Cmake%E7%9A%84%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>以前 接触Ros是有用过cmake，以及 clickhouse 编译源码时也有用过cmake，但是只是执行命令，没怎样看，最近了解了下</p><p>cmake 相对于 Makefile 更加便捷，cmake会根据 CMakeLists.txt的内容  会自动生成 Makefile，想着最近捣鼓的项目代码量也上来了，所以试试 cmake，这里记录做下记录</p><p>最近想着一个 项目源文件和头文件如何布局，以及一些模块的代码要在那个文件夹，这里现在考虑的不是很完善，现在方案是  .h 和 .cpp 分离开，并且一个功能模块占用一个文件夹</p><p><img src="http://imt.rui.vin/202204190055109.png" alt="image-20220419005501875">build 里面就是 cmake 生成的文件，在项目根目录编写 个 CmakeLists.txt ,cmake 会根据这个生成对应的makefile文件</p><p>aux_source_directory(路径 变量名字)   是指定路径的源文件 保存到指定的变量（这里都是用空格隔开的）<br>期初一直提示没有找   <strong>undefined reference</strong>  原因就是 没有导入相对应的文件</p><ul><li><p>$是取值的符号</p></li><li><p>set是赋值</p></li><li><p>message相对于 print</p></li><li><p>include_directories(路径)   是找到相对应的头文件</p></li><li><p>ADD_EXECUTABLE(生成文件  源文件….)  </p></li><li><p>target_link_libraries()  链接对应库  相当于  gcc 中的 -L</p></li><li><pre><code class="hljs">file(GLOB_RECURSE SRC_DIR_LIST &quot;src/*.cpp&quot; &quot;src/*.c&quot;)    这个可以一次性遍历出全部的源文件</code></pre></li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment">#cmake最低版本需求，不加入此行会受到警告信息</span><br>CMAKE_MINIMUM_REQUIRED(VERSION 2.6)<br>PROJECT(Server) <span class="hljs-comment">#项目名称</span><br><br>aux_source_directory(./src/common SRC_common)<br>aux_source_directory(./src/threadpool SRC_threadpool)<br><span class="hljs-comment">#file(GLOB_RECURSE SRC_DIR_LIST &quot;src/*.cpp&quot; &quot;src/*.c&quot;)#遍历获取source/路径下所有的*.cpp和*.c文件列表</span><br><br><span class="hljs-comment">#打印SRC_DIR_LIST中列表信息</span><br><br>set(SRC_ROOT_PATH $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;)<br>message(<span class="hljs-string">&quot;SRC_ROOT_PATH $&#123;SRC_ROOT_PATH&#125;&quot;</span>)<br><br>include_directories($&#123;SRC_ROOT_PATH&#125;/<span class="hljs-keyword">include</span>)<br><span class="hljs-comment"># 指定可执行文件的输出目录  </span><br>set( $&#123;PROJECT_SOURCE_DIR&#125;/bin)<br><br>ADD_EXECUTABLE(main main.cpp $&#123;SRC_common&#125; $&#123;SRC_threadpool&#125; )<br>target_link_libraries(main pthread)<br><br></code></pre></td></tr></table></figure><hr><p>现在看来 cmake 是比较方便，不用写编译的命令，威力很强大，以后遇到什么需求了再来完善，用着学，学着用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>cmake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gogs 搭建和githook自动化部署</title>
    <link href="/2022/04/16/Gog%E6%90%AD%E5%BB%BA%E5%92%8Chook%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/04/16/Gog%E6%90%AD%E5%BB%BA%E5%92%8Chook%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>​昨天 体验到了 rm 的威力（ 手残 把自己服务器的 &#x2F;home都给删除了,好多代码都寄了…..  ）… 导致 早期的搭建的git服务器 挂了，无法更新博客，想到备份而了镜像进行回滚，但是 回滚的是好久之前的，什么都没搭好，于是今天用了一下午的时间 搭建… </p><p>​   搭建 git的时候按照老办法，突然发现了一个 叫 Gogs的git管理工具，从介绍上看  <strong>Gogs</strong> 是一款极易搭建的自助 Git 服务，没试过，我也就试试，搭建一气呵成，我选择用 二进制安装的，方便快捷，搭建好后，开放了一个端口，然后需要用户登录，这就有点类似于 github 了</p><p><img src="http://imt.rui.vin/202204161748964.png" alt="image-20220416173330870" style="zoom:50%;"> 按照 网上教程很快就完成了</p><p>服务器搭建好了后，还是和以前一样方案    本地push到主分支 ， 触发githook ，执行指定代码，在服务器上 pull最新的源码， 最后用 Nginx做解析</p><p>遇到个问题就是   触发githook 后无法 执行pull ，一直说目录 没有  .git ,这个搞了很久，我忘记 上次是怎么弄了 （没总结的后果！！）</p><p>后来在 Stack Overflow 找到了答案 ，完美解决！！！</p><img src="http://imt.rui.vin/202204161748271.png" alt="image-20220416174052831" style="zoom:67%;"><p>为什么会这样呢？</p><blockquote><p>  原来 git 首选使用路径是 GIT_DIR, 其次 才是PWD ，用  unset GIT_DIR 把这个环境变量，git 则会用 PWD！</p></blockquote><p>想着以后可不可以将这个打包成一个镜像，以后直接用 docker 运行这镜像？</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>error while loading shared libraries错误解决办法</title>
    <link href="/2022/04/10/error%20while%20loading%20shared%20libraries%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2022/04/10/error%20while%20loading%20shared%20libraries%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>最近想实现 Reactor 多线程模式，因为线程池可以使用了，接下来尝试 将epoll 封装下一些api， 后来想到 有个框架 Libevent 也是基于事件通知机制的库，将epoll封装成api，方便调用，以前有看过一点，但是没有用过，所以现在站在巨人的肩膀上看看他们是怎样写的：</p><p>看源码之前需要将这个代码跑通，起码会用才行，从编译源代码，到运行demo都遇到了些问题，这里做个总结吧</p><p>clone 源码然后 make 这些就不说了，make 时出现个问题 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">bufferevent_openssl.c:<span class="hljs-number">228</span>:<span class="hljs-number">19</span>: error: storage size of <span class="hljs-string">&#x27;methods_bufferevent&#x27;</span> isn<span class="hljs-number">&#x27;</span>t known<br> <span class="hljs-type">static</span> BIO_METHOD methods_bufferevent = &#123;<br>                   ^~~~~~~~~~~~~~~~~~~<br>Makefile:<span class="hljs-number">793</span>: recipe <span class="hljs-keyword">for</span> target <span class="hljs-string">&#x27;bufferevent_openssl.lo&#x27;</span> failed<br></code></pre></td></tr></table></figure><p>后来查了下 是 openssl 版本不不兼容， 期初我在官网下的 Libevent是2.0.2 </p><blockquote><p>  openssl 是什么： openssl则是SSL的实现版（SSL https加密哪个 ），另外openssl还包含了公钥私钥的生成、摘要生成等各种工具</p></blockquote><p><img src="http://imt.rui.vin/202204100020544.png" alt="image-20220410001448008"></p><p>libevent 2.0.x版本的  openssl &lt; 1.1.0 ，不兼容，现在 Linux openssl  普遍  版本都是1.1.0+  </p><p><img src="http://imt.rui.vin/202204100017635.png" alt="image-20220410001724343"></p><p>解决方法： 用  libevent 2.1.x+ 以上的版本</p><hr><p>使用 libevent 库 编译过了，执行程序时报错 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">error <span class="hljs-keyword">while</span> loading shared libraries: libevent<span class="hljs-number">-2.1</span>.so<span class="hljs-number">.6</span>: <br>cannot open shared object file: No such file or directory<br></code></pre></td></tr></table></figure><p>问题 找不到共享库？</p><p>原因：  <a href="https://so.csdn.net/so/search?q=%E7%BC%96%E8%AF%91%E5%99%A8&spm=1001.2101.3001.7020">编译器</a>只会使用   <strong>&#x2F;lib</strong>  和   <strong>&#x2F;usr&#x2F;lib</strong>   这两个目录下的库文件， 编译源码的时候没有指定 库安装的目录，运行程序需要链接动态库时就找不到，所以现在需要添加 这个库的目录</p><p>解决方法：  </p><ul><li>先看下系统 是否有这个库  ，找到 库的位置</li></ul><p>​      <img src="http://imt.rui.vin/202204100026453.png" alt="image-20220410002648057"></p><ul><li><p>动态库文件所在的目录 在    **&#x2F;etc&#x2F;ld.so.conf **   ，将 libevent-2.1.so.6所在的目录添加到该文件下</p><p>​    <img src="http://imt.rui.vin/202204100031469.png" alt="image-20220410003108601">     </p></li><li><p>执行 &#x2F;sbin&#x2F;ldconfig  -v   才会生效</p></li></ul><p>如果还不行，而且确实有 有库存在，可以看下 是否是 权限问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指针数组和数组指针</title>
    <link href="/2022/04/01/%E5%87%BD%E6%95%B0%20%E6%8C%87%E9%92%88%20%E6%95%B0%E7%BB%84%20%E6%90%AD%E9%85%8D/"/>
    <url>/2022/04/01/%E5%87%BD%E6%95%B0%20%E6%8C%87%E9%92%88%20%E6%95%B0%E7%BB%84%20%E6%90%AD%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<!--==-->指针 ，数组， 函数  这个概念并不会陌生，但是组合起来 就有很多含义，总是搞混，如    数组指针 ，数组指针 ，函数指针等等...  死记硬背是不可能的，在这里总结下规律==<h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>这个比较容易理解 ，我们日常使用的数组有  整型的数组，如 <strong>int a[100];</strong> 有100个空间，里面都是存放整型变量的 ， 也有浮点型的数组  <strong>float b[100];</strong>   从前两个可以总结出这一类数组叫法都是   类型名 + 数组 ，  我们也知道 <strong>指针也是类型！</strong> 只不过是比较特殊的类型（存地址）！ 所以说 指针数组是存在指针的数组，那如何标识呢？</p><p>int *p[100]    —-&gt;    int * (p[100])         </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> a = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> b = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> c = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> d = <span class="hljs-number">4</span>;<br>    <span class="hljs-type">int</span> e = <span class="hljs-number">5</span>;<br>    <span class="hljs-type">int</span> *p[<span class="hljs-number">5</span>] = &#123;&amp;a, &amp;b, &amp;c, &amp;d, &amp;e&#125;;<br>    <span class="hljs-type">int</span> i; <br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, *p[i]);<br>    &#125;<br>    <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><p>还是按照 上面 指针数组的推理：    指针也是有很多种类型的，如 int * p，说明这个 指针p指向 指向整型的内存，那数组指针呢？ 我们可以重新理解为 这个指针是指向<strong>数组类型</strong>的，  数组指针的写法和指针数组很像，就是多了个括号   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span> (*pa)[<span class="hljs-number">3</span>] = &amp;a;<br></code></pre></td></tr></table></figure><p>pa 是指向 数组a[3] 的指针 ，   int (*pa)[3]  是挺难理解的 ， 我的理解是  *<em>（）和[ ] 是相同的优先级，现在是从左到右开始结合  int 代表着 <em>p指向的内容是整型的，[3] 是说明有3个这样的空间</em></em></p><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数即我们写的代码，代码也有有专门存放的空间，从内存布局上看，是存放在代码区，<strong>所以也是有地址的！</strong> 通过 函数名可以找到 代码块的地址</p><p>同数组指针一样的理解， 这个这个指针的类型是函数的（有点拗口，但还是抽象的形容吧） ，函数回调就可以用函数指针来实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span>;;   <span class="hljs-comment">/*声明一个函数*/</span><br><span class="hljs-type">int</span> (*p) (<span class="hljs-type">int</span>, <span class="hljs-type">int</span>);;  <span class="hljs-comment">/*定义一个函数指针*/</span><br>p = Func;          <span class="hljs-comment">/*将Func函数的首地址赋给指针变量p  不用 &amp; 符号*/</span> <br></code></pre></td></tr></table></figure><p>p是一个指针，返回的值是 整型的，后面 (int, int)  是函数的参数<br>这个规律是 返回值要相同，形参也要一致</p><h3 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h3><p>同上，这个数组的类型是 函数指针类型的，数组中的每一项都保存这个一个函数指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> (*p[<span class="hljs-number">10</span>])();<br></code></pre></td></tr></table></figure><p>p和 [10]相结合  有了个数组，然后和 * 结合 是个指针数组，和 int 结合 ，返回的值是 int 类型的， 然后和 （） 就是形参列表</p><h3 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h3><p>这个不用说都明白的了，函数 返回值是 指针类型的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *<span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span>;<br></code></pre></td></tr></table></figure><hr><p>待更新</p>]]></content>
    
    
    
    <tags>
      
      <tag>基础语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写线程池-第一版</title>
    <link href="/2022/03/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2022/03/28/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="线程池是什么"><a href="#线程池是什么" class="headerlink" title="线程池是什么"></a>线程池是什么</h3><p>举个例子，在以前文章又提到过 好几种reactor模式</p><img src="http://imt.rui.vin/202203291923967.png" alt="单Reactor多线程模式" style="zoom:50%;"> <p>可以大概分为这几种</p><p>  单 Reactor 单进程 &#x2F; 线程：    **接收数据  –&gt;  解析数据  –&gt; 发送数据 **           </p><p>  单 Reactor 多线程 ：             接收数据  –&gt; fd 交给线程        –&gt;  线程全程处理</p><p>​ 接收数据  –&gt; 从fd中抽出数据 –&gt; 数据交给线程</p><p>如果接收一次数据，创建一次线程处理完后又销毁线程，这样太消耗cpu资源了,为了改善这个性能，可以先创建好一定数量的线程，线程处理饥渴的模式，有业务需要处理了，就派一个线程去处理，处理完后，又处于饥渴的转态，其实典型的空间换时间的问题，有很设计都是这样，如内存池（减少系统调用的次数），连接池等。</p><p>如何设计呢一个池呢？ 好像Java有现成的类可以调，这次用C++ 写一个线程池，第一次写，有很多东西没考虑到，以后继续迭代吧</p><p>看了一个视频，用c写线程池，大致理解了思路，于是自己 用 c++写一遍（ c with class …) </p><p>思路： </p><ul><li>一个线程池类， 可以初始初始化线程 ，任务队列，锁</li><li>工作类， 一个线程对应个工作类，工作类从任务队列中抽取任务</li><li>任务类 ，产生一个任务 插入任务队列中</li><li>线程锁类， 用的还是 POSIX标准下的互斥锁，不过封装一遍（我看别人写的代码好多都是基本api在封装一遍的，所以我也尝试下）， 还有一个条件变量，没任务全部线程等待，有任务 发送信号，通知一个等待的线程获取任务</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">pool</span>&#123;<br><span class="hljs-keyword">private</span>:<br>list&lt;Job*&gt; Jobs;  <span class="hljs-comment">//用双向链表 存放任务  应该用队列比较好的</span><br>mylocker *mutelock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">mylocker</span>(); <span class="hljs-comment">// 初始化一个锁</span><br><span class="hljs-keyword">public</span>:<br>         <span class="hljs-comment">//初始化线程</span><br><span class="hljs-built_in">pool</span>(<span class="hljs-type">int</span> maxNumber)&#123;   <br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; maxNumber; i++)&#123;<br>                Worker *work = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Worker</span>(); <span class="hljs-comment">//工作类  </span><br>                work-&gt;lock = mutelock;       <span class="hljs-comment">//全部线程公用一个锁</span><br>                work-&gt;Jobs = &amp;Jobs;          <span class="hljs-comment">//任务队列包含    我想着尽量不要用到 全局的变量，全部归到一个类里面</span><br>                <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_create</span>(&amp;work-&gt;tid, <span class="hljs-literal">NULL</span>, fun, (<span class="hljs-type">void</span> *)work);  <span class="hljs-comment">// 开启线程  还有传参，工作类传进去</span><br>                <span class="hljs-built_in">pthread_detach</span>(work-&gt;tid);  <span class="hljs-comment">//线程分离，脱离主程序</span><br><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addjob</span><span class="hljs-params">(Job *job)</span></span>&#123; <span class="hljs-comment">//添加一个任务</span><br>            mutelock-&gt;<span class="hljs-built_in">mutelock</span>(); <span class="hljs-comment">//此时还是需要锁 保持同步  </span><br>            <span class="hljs-keyword">if</span>(job-&gt;state == run)&#123; <span class="hljs-comment">//添加了任务的转态，不是需要运行的就加进去  </span><br>                  <span class="hljs-comment">//这里做的不是很好，是不是应该分为待处理，马上处理的任务队列呢，以后在补充</span><br>                cout &lt;&lt; <span class="hljs-string">&quot;添加队列中&quot;</span> &lt;&lt; endl;<br>                Jobs.<span class="hljs-built_in">push_back</span>(job);<br>                mutelock-&gt;<span class="hljs-built_in">condsignal</span>();  <span class="hljs-comment">//通知线程</span><br>            &#125;<br>            mutelock-&gt;<span class="hljs-built_in">muteunlock</span>(); <br>&#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">jobSize</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> Jobs.<span class="hljs-built_in">size</span>();<br>        &#125;<br>~<span class="hljs-built_in">pool</span>()&#123;<br>            <span class="hljs-built_in">delete</span>(mutelock);<br>&#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//任务类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Job</span>&#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-type">int</span> state = run;<br>        <span class="hljs-type">int</span> data;<br>        <span class="hljs-built_in">void</span> (*job_function)(<span class="hljs-type">int</span> fd);  <span class="hljs-comment">// 这里 添加个回调函数，可以自定义 要怎样的任务类</span><br><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">Job</span>()&#123;<br><span class="hljs-comment">//这里初始化</span><br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">runFun</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-built_in">job_function</span>(data);<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;    <br>    <span class="hljs-comment">//cout &lt;&lt; &quot;创建成功 &quot; &lt;&lt; pthread_self() &lt;&lt; endl;  </span><br>    Worker *work = (Worker *)arg;  <span class="hljs-comment">//参数类型转换   这个arg参数太好用了！</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)&#123;<br>        work-&gt;lock-&gt;<span class="hljs-built_in">mutelock</span>();    <span class="hljs-comment">//条件变量需要 互斥锁</span><br>        <span class="hljs-comment">// cout &lt;&lt; &quot;原地待命，等通知&quot; &lt;&lt; endl;</span><br>        <span class="hljs-comment">// 队列空的话 等待等通知</span><br>        <span class="hljs-keyword">while</span> (work-&gt;Jobs-&gt;<span class="hljs-built_in">empty</span>())&#123;  <br>            cout &lt;&lt; <span class="hljs-string">&quot;等待任务队列 &quot;</span> &lt;&lt; work-&gt;Jobs-&gt;<span class="hljs-built_in">empty</span>() &lt;&lt; endl; <br>            work-&gt;lock-&gt;<span class="hljs-built_in">condwait</span>();<br>        &#125;<br>        <span class="hljs-comment">//走到这说明有任务了，此时还是锁的转态可以保持线程同步</span><br>        <span class="hljs-keyword">if</span>(work-&gt;<span class="hljs-built_in">getTer</span>() == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">pthread_exit</span>(<span class="hljs-literal">NULL</span>);<br>        &#125;<br>        <span class="hljs-comment">//从任务队列中 抽一个任务</span><br>        Job *job = work-&gt;Jobs-&gt;<span class="hljs-built_in">front</span>();<br>        <span class="hljs-comment">//pop掉任务</span><br>        work-&gt;Jobs-&gt;<span class="hljs-built_in">pop_front</span>();<br>        work-&gt;lock-&gt;<span class="hljs-built_in">muteunlock</span>();<br>        <span class="hljs-comment">//此时解锁，因为我已经拿到任务里，应该不锁了，好像也不是很安全，如果是对处理的是共享的数据呢....</span><br>        cout &lt;&lt; <span class="hljs-built_in">pthread_self</span>() &lt;&lt; <span class="hljs-string">&quot;   data : &quot;</span>;<br>        job-&gt;<span class="hljs-built_in">runFun</span>(); <span class="hljs-comment">//线程运行任务的回调函数</span><br>        <span class="hljs-built_in">delete</span>(job);      <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> terminate;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Worker</span>()&#123;<br>terminate = <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getTer</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> terminate;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>&#123;<br><br>        &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">pthread_t</span> tid;  <br>        mylocker *lock;    <br>        list&lt;Job*&gt; *Jobs;<br><br><br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//封装 互斥锁 和 条件变量</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mylocker</span>&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">pthread_mutex_t</span> mutexlock;<br><span class="hljs-type">pthread_cond_t</span> cond;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">mylocker</span>()&#123;<br>            mutexlock = PTHREAD_MUTEX_INITIALIZER;<br>cond = PTHREAD_COND_INITIALIZER;<br>        &#125;<br>        ~<span class="hljs-built_in">mylocker</span>()&#123;<br>            <span class="hljs-built_in">pthread_mutex_destroy</span>(&amp;mutexlock);<br>            <span class="hljs-built_in">pthread_cond_destroy</span>(&amp;cond);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">mutelock</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutexlock) == <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">muteunlock</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutexlock) == <span class="hljs-number">0</span>;<br>        &#125;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">condwait</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_cond_wait</span>(&amp;cond,&amp;mutexlock);<br>&#125;<br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">condsignal</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">pthread_cond_signal</span>(&amp;cond);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">pthread_mutex_t</span> *<span class="hljs-title">get</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> &amp;mutexlock;<br>        &#125;    <br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程的简单使用</title>
    <link href="/2022/03/25/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/03/25/%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>线程方面的知识一直是很薄弱的， 所以再次翻开 《APUE 》 ，重新再看一遍  第11 章 线程，有不一样的收获，在这总结下 线程的一些使用方法 ； （PS： 发现以前好多看得云里雾里的书籍，现在重头看，有种恍然大悟的感觉！）</p></blockquote><h3 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h3><blockquote><p>   进程是程序执行时的一个实例，是担当分配系统资源（CPU时间、内存等）的基本单位。在面向线程设计的系统中，进程本身不是基本运行单位，而是线程的容器。程序本身只是指令、数据及其组织形式的描述，进程才是程序（那些指令和数据）的真正运行实例。</p><p>　　线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。线程包含了表示进程内执行环境必须的信息，其中包括进程中表示线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno常量以及线程私有数据。进程的所有信息对该进程的所有线程都是共享的，包括可执行的程序文本、程序的全局内存和堆内存、栈以及文件描述符。在Unix和类Unix操作系统中线程也被称为轻量级进程（lightweight processes），但轻量级进程更多指的是内核线程（kernel thread），而把用户线程（user thread）称为线程。</p><p>线程和进程一样也有标志号作为识别 </p></blockquote><h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a><strong>线程创建</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">pthread_create</span> <span class="hljs-params">(<span class="hljs-type">pthread_t</span> *__restrict __newthread, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *__attr,<span class="hljs-type">void</span> *(*fun) (<span class="hljs-type">void</span> *),<span class="hljs-type">void</span> *arg)</span>;<br></code></pre></td></tr></table></figure><p>​参数分别是 线程的pid，线程属性，线程的函数，传入线程的参数，创建失败会返回错误码</p><p>​对于 传参 的arg指针，不需要给线程传入参数的话直接 设置为 null即可</p><h3 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h3><p>终止有三种方式</p><ul><li><p>运行完线程代码return 结束</p></li><li><p>被其他线程中终止</p></li><li><p>线程可以调用 pthread_exit  ( 自己终结自己 )</p><p>  pthread_exit（） 可以携带返回值</p></li></ul><p>如果需要 现有线程的返回值怎么办？ 有一个函数可以做到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Make calling thread wait for termination of the thread TH.  The</span><br><span class="hljs-comment">   exit status of the thread is stored in *THREAD_RETURN, if THREAD_RETURN</span><br><span class="hljs-comment">   is not NULL.</span><br><span class="hljs-comment">让调用线程等待线程TH的终止。线程的退出状态存储在*THREAD_RETURN中</span><br><span class="hljs-comment">This function is a cancellation point and therefore not marked with</span><br><span class="hljs-comment">   __THROW.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pthread_join</span> <span class="hljs-params">(<span class="hljs-type">pthread_t</span> __th, <span class="hljs-type">void</span> **__thread_return)</span>;<br><br></code></pre></td></tr></table></figure><p>线程的返回转态可以保存在 __thread_return 中；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/tcp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cleanup : %s \n&quot;</span>,(<span class="hljs-type">char</span> *)arg);<br>&#125;<br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br>    <span class="hljs-type">char</span> *str = (<span class="hljs-type">char</span> *)arg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str);    <br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">char</span> *ret = <span class="hljs-string">&quot;hrrrr&quot;</span>;<br>    <span class="hljs-keyword">return</span> ((<span class="hljs-type">void</span> *)ret);  <br>&#125;<br><span class="hljs-type">void</span>* <span class="hljs-title function_">fun2</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span>&#123;<br>    <span class="hljs-type">char</span> *str = (<span class="hljs-type">char</span> *)arg;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>,str);    <br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">char</span> *ret = <span class="hljs-string">&quot;cccc&quot;</span>;<br>    pthread_exit((<span class="hljs-type">void</span> *)ret);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br><br>    <span class="hljs-type">pthread_t</span> pid[<span class="hljs-number">5</span>];<br>    <span class="hljs-type">char</span> *str1 = <span class="hljs-string">&quot;str1 传入的参数内容&quot;</span>;<br>    <span class="hljs-type">char</span> *str2 = <span class="hljs-string">&quot;str2 传入的参数内容&quot;</span>;<br><br>    pthread_create(&amp;pid[<span class="hljs-number">0</span>],<span class="hljs-literal">NULL</span>,fun,str1);<br>    pthread_create(&amp;pid[<span class="hljs-number">1</span>],<span class="hljs-literal">NULL</span>,fun2,str2);<br><br>    <span class="hljs-type">void</span> *tre,*tre1;<br>    pthread_join(pid[<span class="hljs-number">0</span>],&amp;tre);   <br>    pthread_join(pid[<span class="hljs-number">1</span>],&amp;tre1);   <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s \n&quot;</span>,(<span class="hljs-type">char</span> *)tre);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s \n&quot;</span>,(<span class="hljs-type">char</span> *)tre1);<br>    sleep(<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://imt.rui.vin/202203261542936.png" alt="image-20220326154257729">   </p><p>线程结束后可以得到返回值，返回值分别是return返回的和  pthread_exit结束时返回的</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>​提到线程必然有很多问题 ，多线程并发的时，同时读取相同变量，不是原子性 可以能会有数据不一致的情况（i++）</p><p>​i++ 操作 是</p><ul><li>将内存读取寄存器</li><li>操作寄存器的值</li><li>新的值写内存单元</li></ul><p>哪如何保证线程的同步呢？</p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a><strong>互斥锁</strong></h4><p>对资源加锁后，任何线程试图再次对该互斥量加锁的线程都会阻塞，直到到该锁释放为止，这样可以确保每次只有一个线程可以获取资源，保证原子性</p><p>使用互斥锁得先初始化 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// pthread_mutex_t 是一个结构体</span><br><span class="hljs-type">pthread_mutex_t</span> __mutex;<br><span class="hljs-comment">//init</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_init</span> <span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *__mutex,</span><br><span class="hljs-params">       <span class="hljs-type">const</span> <span class="hljs-type">pthread_mutexattr_t</span> *__mutexattr)</span><br>     __THROW __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>))</span>;<br><br><span class="hljs-comment">/* Destroy a mutex.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_destroy</span> <span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *__mutex)</span><br>     __THROW __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>))</span>;<br><br><span class="hljs-comment">/* Try locking a mutex.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_trylock</span> <span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *__mutex)</span><br>     __THROWNL __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>))</span>;<br><br><span class="hljs-comment">/* Lock a mutex.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_lock</span> <span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *__mutex)</span><br>     __THROWNL __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>))</span>;<br><br><span class="hljs-comment">/* Unlock a mutex.  */</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> <span class="hljs-title function_">pthread_mutex_unlock</span> <span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *__mutex)</span><br>     __THROWNL __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>))</span>;<br><br></code></pre></td></tr></table></figure><p>使用的话就是在 访问临界区资源之前对 互斥量加锁，尽管这样可以解决线程同步的问题，但是如果存在多个锁，没有设计好加锁顺序，可能造成死锁，看代码</p><p>此时有两个锁和两个线程，每个线程加锁顺序相反的话，就会造成<strong>死锁，</strong>互相等待对方释放资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">pthread_mutex_t</span> plock2;<br><span class="hljs-type">pthread_mutex_t</span> plock1;<br><span class="hljs-type">pthread_mutex_t</span> plock3 = PTHREAD_MUTEX_INITIALIZER;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//以不同顺序加锁</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br><br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>)<br>    &#123;<br>      <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;plock1);<br>      cout &lt;&lt; <span class="hljs-string">&quot;plock1 已经上锁，准备获取plock2锁 &quot;</span> &lt;&lt; endl;<br>      <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;plock2);<br>      cout &lt;&lt; <span class="hljs-string">&quot;plock2 已经上锁&quot;</span> &lt;&lt; endl;<br><br>      <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;plock2);<br>      <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;plock1);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>) <br>    &#123;<br>      <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;plock2);<br>      cout &lt;&lt; <span class="hljs-string">&quot;plock2 已经上锁，准备获取plock1锁&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;plock1);<br>      cout &lt;&lt; <span class="hljs-string">&quot;plock1 已经上锁&quot;</span> &lt;&lt; endl;<br>      <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;plock2);<br>      <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;plock1);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">pthread_t</span> pid[<span class="hljs-number">5</span>];<br>    <span class="hljs-type">char</span> *str1 = <span class="hljs-string">&quot;str1 传入的参数内容&quot;</span>;<br>    <span class="hljs-type">char</span> *str2 = <span class="hljs-string">&quot;str2 传入的参数内容&quot;</span>;<br>    <span class="hljs-built_in">pthread_mutex_init</span>(&amp;plock2,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-built_in">pthread_mutex_init</span>(&amp;plock1,<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">pthread_create</span>(&amp;pid[<span class="hljs-number">0</span>],<span class="hljs-literal">NULL</span>,fun,str1);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;pid[<span class="hljs-number">1</span>],<span class="hljs-literal">NULL</span>,fun2,str2);<br>    <span class="hljs-comment">// pthread_create(&amp;pid[2],NULL,fun3,str2);</span><br><br>    <span class="hljs-type">void</span> *tre,*tre1;<br>    <span class="hljs-built_in">pthread_join</span>(pid[<span class="hljs-number">0</span>],&amp;tre);   <br>    <span class="hljs-built_in">pthread_join</span>(pid[<span class="hljs-number">1</span>],&amp;tre1);   <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s \n&quot;</span>,(<span class="hljs-type">char</span> *)tre);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s \n&quot;</span>,(<span class="hljs-type">char</span> *)tre1);<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>)<br>    &#123;<br>          cout &lt;&lt; <span class="hljs-string">&quot;i的值&quot;</span> &lt;&lt; i++ &lt;&lt; endl;<br>          <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="http://imt.rui.vin/202203272046460.png" alt="image-20220327204645817">  plock1 和  plock2都 已经上锁，两个线程都在等待对方释放锁，才能进行下去，这种情况下双方都不会释放</p><h4 id="读写锁（-共享互斥锁）"><a href="#读写锁（-共享互斥锁）" class="headerlink" title="读写锁（ 共享互斥锁）"></a>读写锁（ 共享互斥锁）</h4><p>写操作的时候才会互斥，而在进行读的时候是可以共享的进行访问临界区的，    在写少读多的情况下用读写锁更好，为什么呢？  写的时候临界区加锁，这没毛病，读的时候并不需要进修改数据，多线程读数据并不影响数据内容，所以读的时候不用锁共享资源，也节省了系统的开销</p><p>读写锁的分配规则：</p><ol><li>只有线程没有使用读写锁的写转态，那么任意数目的线程都可以使用读写锁</li><li>当有线程持有读写锁的写转态时，其他线程使用读写锁都会被阻塞</li><li>如果读写锁的读模式加锁时，所有线程以读模式它进行加锁的线程都可以得到访问权</li></ol><p>做了实验  使用读写锁，一个线程写数据，两个线程读数据</p><p>写的时候，读线程全部被阻塞<br>读的时候，读线程全都可以获取资源，写线程被阻塞</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">pthread_mutex_t</span> plock2;<br><span class="hljs-type">pthread_mutex_t</span> plock1;<br><span class="hljs-type">pthread_rwlock_t</span> rw_lock;<br><span class="hljs-type">pthread_rwlock_t</span> rwlock;<br><br><span class="hljs-type">int</span> i = <span class="hljs-number">13</span>;<br><span class="hljs-comment">//写数据</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-type">char</span> *arg1 = (<span class="hljs-type">char</span> *)arg;<br><br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>)<br>    &#123;<br>        <span class="hljs-built_in">pthread_rwlock_wrlock</span>(&amp;rwlock);<br>        <br>        cout &lt;&lt; <span class="hljs-string">&quot;开启 写的锁后  i = &quot;</span> &lt;&lt; i++  &lt;&lt; <span class="hljs-string">&quot; 并且i++&quot;</span>&lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;此时所获取这个锁的线程都会被堵塞 3s&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; endl;<br>        cout &lt;&lt; endl;<br><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">pthread_rwlock_unlock</span>(&amp;rwlock);<br>    &#125;<br>&#125;<br><span class="hljs-comment">//以下为读数据</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">char</span> *arg1 = (<span class="hljs-type">char</span> *)arg;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>) <br>    &#123;<br><br>        <span class="hljs-built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);<br>        cout &lt;&lt; <span class="hljs-string">&quot; 我是 fun2  开启只读的锁后  i =&quot;</span> &lt;&lt; i &lt;&lt; endl;<br><br>        <span class="hljs-built_in">pthread_rwlock_unlock</span>(&amp;rwlock);<br><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">fun3</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span>&#123;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">char</span> *arg1 = (<span class="hljs-type">char</span> *)arg;<br>    <span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>) <br>    &#123;<br>        <span class="hljs-built_in">pthread_rwlock_rdlock</span>(&amp;rwlock);<br>        cout &lt;&lt; <span class="hljs-string">&quot; 我是 fun3  开启只读的锁后  i =&quot;</span> &lt;&lt; i &lt;&lt; endl;<br><br>        <span class="hljs-built_in">pthread_rwlock_unlock</span>(&amp;rwlock);<br><br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-type">pthread_t</span> pid[<span class="hljs-number">5</span>];<br>    <span class="hljs-type">char</span> *str1 = <span class="hljs-string">&quot;str1 传入的参数内容&quot;</span>;<br>    <span class="hljs-type">char</span> *str2 = <span class="hljs-string">&quot;str2 传入的参数内容&quot;</span>;<br>    <span class="hljs-built_in">pthread_rwlock_init</span>(&amp;rwlock,<span class="hljs-literal">NULL</span>);<br><br>    <span class="hljs-built_in">pthread_create</span>(&amp;pid[<span class="hljs-number">0</span>],<span class="hljs-literal">NULL</span>,fun,str1);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;pid[<span class="hljs-number">1</span>],<span class="hljs-literal">NULL</span>,fun2,str1);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;pid[<span class="hljs-number">2</span>],<span class="hljs-literal">NULL</span>,fun3,str1);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-built_in">pthread_rwlock_destroy</span>(&amp;rwlock);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;    <br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h4><p>条件变量也是同步线程的同步的方式，但还是得借助互斥锁；  当一个线程获取锁之后，他需要等待一定的条件才能继续执行，执行完成再释放锁，这个条件可能是其他线程计算的结果，等待条件的时候可以 一直判断这个条件是否成立（加个while）但这样太消耗CPU的资源了，资源会被一个线程都占用，使用条件变量可以 使线程进入等待转态，等待其他线程完后发送信号给条件变量，从而继续执行</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>​ 与互斥锁类似，等待互斥锁时线程是阻塞的，而自旋锁是一直在询问这个锁是否可用（会占用CPU），所以自旋锁适用于锁持有时间短的场景，长时间占用自旋锁是很占用CPU资源的，使用自旋锁的话对于 竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞状态，等到持有锁的线程释放锁之后即可获取，这样就避免了用户进程和内核切换的消耗，也是自旋锁适用于所持有时间的场景的原因。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>以上加锁的目的保证数据&#x2F;操作是原子性的，如果说锁里面的操作&#x2F;数据是原子性的，没有锁也是可以的，就好比 i++，我们都知道这个并不是 原子性的操作，但是如果说用一个函数实现 i++，并且是要原子性的可以吗？有一些汇编指令就是可以原子操作，在函数里嵌入 汇编语言，用这个汇编来使用 i++的操作也是可以的；（其实c++ 11中的 atmoic 可以，对于atomic 以后再介绍）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">int inc(int *value, int add) &#123;<br>  int old;<br>  __asm__ volatile ( <br>  &quot;lock; xaddl %2, %1;&quot; // &quot;lock; xchg %2, %1, %3;&quot; <br>    : &quot;=a&quot; (old)<br>    : &quot;m&quot; (*value), &quot;a&quot; (add)<br>    : &quot;cc&quot;, &quot;memory&quot;<br>  );<br>  return old;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="CAS（先留坑）"><a href="#CAS（先留坑）" class="headerlink" title="CAS（先留坑）"></a>CAS（先留坑）</h2><p>。。。。。。。。。。。。。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http的小总结</title>
    <link href="/2022/03/24/http%E5%92%8Chttps%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <url>/2022/03/24/http%E5%92%8Chttps%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>最近看图解网络，在这里做个笔记</p><h4 id="http的概念"><a href="#http的概念" class="headerlink" title="http的概念"></a>http的概念</h4><p>​http -&gt; 超文本传输协议，早期只是用来传输文本，现在可以用了传输音频图像，所以称为超文本协议</p><h4 id="GET-与-POST"><a href="#GET-与-POST" class="headerlink" title="GET 与 POST"></a><strong>GET</strong> <strong>与</strong> <strong>POST</strong></h4><ul><li><p>get请求： get 意为得到，取得  get请求就是  请求<strong>从服务器获取资源</strong>，这个资源可以是静态的⽂本、⻚⾯、图⽚视频等。</p></li><li><p>post请求： post 投递的意思，他将指定的资源通过http协议提交服务器</p></li></ul><p>  说到get和post 又得提到 安全 和 幂等</p><ul><li>安全是指 多次请求不会对服务区产生副作用，即不会改变资源的转态，打个比方，我想用get请求一个网页，无论操作多少次，对服务器上的数据都不影响，而post有新增或提交数据的操作，会修改服务器上的资源，所以不是安全的</li><li>幂等是指多次执⾏相同的操作，得到的结果都是相同的，每次get请求一个页面，都是一样的则这个是幂等的</li></ul><h4 id="http特性"><a href="#http特性" class="headerlink" title="http特性"></a>http特性</h4><ul><li><p>跨平台，易扩展</p><p>  手机端，PC端都可以使用</p></li><li><p>简单，http 格式   有 header + body（数据 ),头部 key -value形式存储如下所示</p></li></ul><blockquote><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/admin_ui/rdx/core/images/close.png</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*<br><span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://xxx.xxx.xxx.xxx/menu/neo<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en-US<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET4.0C; .NET4.0E)<br><span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>xxx.xxx.xxx.xxx<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Keep-Alive<br><span class="hljs-attribute">Cookie</span><span class="hljs-punctuation">: </span>startupapp=neo; is_cisco_platform=0; rdx_pagination_size=250%20Per%20Page; SESSID=deb31b8eb9ca68a514cf55777744e339<br></code></pre></td></tr></table></figure></blockquote><ul><li>无状态  服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存⽤来对外提供服务 ，就好像  登录了某个网站，正常来说验证一次密码（那是有cookie情况下），没状态情况是 每次操作都得重新输入一次密码，这样肯定不方便，后来引入cookie；</li><li>不安全：<ul><li>明文传输，抓包一下子就数据就泄漏了</li><li>没有验证对方的真实身份，可能访问到伪装的网站</li><li>可以篡改报文内容，抓包后修改里面的内容也是可以的</li></ul></li></ul><hr><h4 id="http-和-https（重点）"><a href="#http-和-https（重点）" class="headerlink" title="http 和 https（重点）"></a>http 和 https（重点）</h4><p>上文收到htpp传输是明文传输不安全的，数据有篡改和冒充的风险，为了提高安全性，目前都基本使用 https, 这里的s指的 是SecureSocket Layer（SSL） 的首字母，意为安全套接层</p><h5 id="https是什么？"><a href="#https是什么？" class="headerlink" title="https是什么？"></a>https是什么？</h5><p>​HTTPS 可以解决 HTTP 不安全的缺陷，在TCP 和 HTTP ⽹络层之间加⼊了 SSL&#x2F;TLS 安全协议，使得报⽂能够加密传输。HTTPS 在 TCP 三次握⼿之后还需要进行 SSL&#x2F;TLS的握手过程，才可进⼊加密报⽂传输； HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的（防止伪装站点）。</p><p><img src="http://imt.rui.vin/202203271518389.png" alt="image-20220327133731705" style="zoom: 50%;"> HTTP和TCP直接加了一层SSL&#x2F;TLS</p><h5 id="公钥-私钥-对称加密"><a href="#公钥-私钥-对称加密" class="headerlink" title="公钥 私钥 对称加密"></a>公钥 私钥 对称加密</h5><ul><li>公钥 和 私钥  ：  可以类比为 公钥→锁头  私钥→钥匙（私钥只有一把只有一把） 我用公钥加密数据，那我就的用对应的私钥解密数据</li><li>非对称加密：  使用两个秘钥来加密数据， 就是上面提到的 公钥和秘钥</li><li>对称加密：  使用一个共同加密方式来 加密数据，简称 会话秘钥</li><li>证书： 可以理解为一种合法身份的象征，把公钥放在证书里，只要证书是可信的，公钥就是可信的</li></ul><h5 id="加密方式"><a href="#加密方式" class="headerlink" title="加密方式"></a>加密方式</h5><p>HTTPS 采⽤的是对称加密和⾮对称加密结合的「混合加密」⽅式：</p><ul><li>在通信建⽴<strong>前</strong>采⽤⾮对称加密的⽅式交换「会话秘钥」，后续就不再使⽤⾮对称加密。</li><li>在通信过程<strong>中</strong>全部使⽤对称加密的「会话秘钥」的⽅式加密明⽂数据。</li></ul><h5 id="如何实现的呢？"><a href="#如何实现的呢？" class="headerlink" title="如何实现的呢？"></a><strong>如何实现的呢？</strong></h5><p>在TCP三次握手后，   首先使用非对称加密的方式 生成会话秘钥，接下来服务端和客户端都是使用 这个会话秘钥加密数据（对称加密），所以现在分为两部分来讲，以下也会SSL&#x2F;TLS协议基本流程</p><ul><li><p>非对称加密</p><p>  <strong>这部分的目标是生成 会话秘钥，双方都可用的秘钥！</strong></p><p>  这里我先用通俗的语言来说</p><blockquote><p>服务器 自己有 公钥和秘钥， 他把公钥 交给比较权威的机构，生成证书，机构使用自己的私钥加密这个证书</p><p>客户端这边 携带了 机构的公钥，然后客户想服务端请求证书，然后用机构的公钥确定这个证书是否是可信的，如果用记过的公钥能解锁这个证书，说明服务端是经过机构认证的，就可通过证书获得服务端的公钥！</p></blockquote><ul><li>为什么要通过第三方来过去服务端的公钥呢？</li></ul><p>  ​      如果直接把服务端的公钥发给客户端没有加密的话，中间如果有人拦截了并伪造了公钥，那就后果不堪设想了，所以有了证书确认身份，可以减少这个风险发生；</p><p>  ​     现在客户端获得了服务端的公钥，用服务端的公钥加密消息，和服务端通信，商定好 会话秘钥，而这这个会话秘钥如何生成的呢？ 是通过 ssl协议的四次握手生成的<br>    - 首先客户端向服务器发起加密通信请求，加密内容包含了客户端产生的随机数， SSL&#x2F;TLS 协议版本，如 TLS 1.2 版本，以及客户端支持的解密算法，最后用从证书获取服务端的公钥进行加密。这里就保证了只有服务端才能看到这个消息（只有服务端才有私钥）。<br>    - 服务端收到后，给客户端发出响应，内容如下</p><pre><code class="hljs">    （1）确认 SSL/ TLS 协议版本，如果浏览器不⽀持，则关闭加密通信。</code></pre><p>  ​       （2）服务器⽣产的随机数（ Server Random ），后⾯⽤于⽣产「会话秘钥」。 </p><p>  ​       （3）确认的密码套件列表，如 RSA 加密算法。 （确定使用那种算法） </p><p>  ​       （4）服务器的数字证书</p><p>  ​          服务端也会产生随机数，且确定使用那种加密算法，此时还需要确定这个消息真实性，防止被别人篡改了，所以还需要再一次            验证证书是否可信</p><ul><li><p>客户端收到后，⾸先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。没问题的话取出证书的公钥来加密待会要发送的数据，待发送的数据如下</p><pre><code class="hljs">（1）⼀个随机数（ pre-master key ）。该随机数会被服务器公钥加密。</code></pre></li></ul><p>  ​         （2）加密通信算法改变通知，表示随后的信息都将⽤「会话秘钥」加密通信。 </p><p>  ​ （3）客户端握⼿结束通知，表示客户端的握⼿阶段已经结束。同时把之前所有内容的发⽣的数据做个摘要，⽤来供服务端校验</p><ul><li>服务端收到后，也会回应，也是最后一次回应了，通过私钥解密，服务器收到客户端的第三个随机数（ pre-master key ）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发⽣最后的信息。</li></ul><p>  ⾄此，整个 SSL&#x2F;TLS 的握⼿阶段全部结束。接下来，客户端与服务器进⼊加密通信，实际上还是使用基本http通信，只不过是 通信前双方 约定好加密解锁方式而已</p></li></ul><p>​       对于https 介绍到这里先结束，其实这其中还有很多的细节没有阐述清楚，后续又遇到关于https的问题再补充下；</p><hr><h4 id="https1-1-改进和瓶颈"><a href="#https1-1-改进和瓶颈" class="headerlink" title="https1.1 改进和瓶颈"></a>https1.1 改进和瓶颈</h4><ul><li><p>长链接</p><p>  http1.0 中 每一次的请求都建立三次握手（http是基于tcp的），增加了开销，http1.1 增加了长链接方式，建立了一次tcp链接后，接下来都不需要重新握手</p></li><li><p>管道传输</p><p>  hhtp1.0 中发一次请求，等待回应，有回应后然后在发送下一个请求，在1.1中，使用过管道传输则可以同⼀个 TCP 连接⾥⾯，客户端可以发起多个请求，只要第⼀个请求发出去了，不必等其回来，就可以发第⼆个请求出去，可以<strong>减少整体的响应时间</strong>  </p></li><li><p>瓶颈</p><ul><li>但是可能会造成对头堵塞  多个请求发个服务器后，服务器处理请求还是按照先后顺序来，如果某个请求耗时长，堵塞了接下来的请求（可以加开多几条连接）</li><li>协议头部无法压缩，只能压缩 Body 部分，传输效率低</li><li>请求只能客户端开始，服务器只能被动响应（websocket 可以）</li></ul></li></ul><h4 id="http2-0-改进"><a href="#http2-0-改进" class="headerlink" title="http2.0 改进"></a>http2.0 改进</h4><ul><li><p>头部压缩</p><p>发送多个请求如果 是头部数据相似，协议会使用头部压缩算法（HPACK）清除重复的部分</p></li><li><p>使用二进制文本</p><p>从明文报文改进为二进制格式的报文，对计算机来说，可以直接解析，增加数据的传输效率</p></li><li><p>多路复用</p><p>一个连接并发多个请求或回应，不用像上一代版本会有阻塞，通俗的说就是服务端处理这A和B两个请求，A的处理时间比较长，于是就先回应A处理好的部分，然后回应B请求，然后再回复A请求剩下的（如果出现丢包还能回阻塞的）</p></li><li><p>服务器推送</p><p>HTTP2.0新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。服务器向客户端推送资源无需客户端明确的请求。HTTP 2.0 可以使<strong>服务器主动返回资源</strong>给客户端用户。</p></li></ul><h4 id="http3-0"><a href="#http3-0" class="headerlink" title="http3.0"></a>http3.0</h4><p>基于UDP的QUIC协议，主要改进的问题还是 请求阻塞的问题（udp传输特性），减少了tcp三次握手时间，以及tls握手时间</p><hr><p>待更新</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCI/IP网络模型（层）</title>
    <link href="/2022/03/23/TCI-IP%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%BA%94%E5%B1%82%EF%BC%89/"/>
    <url>/2022/03/23/TCI-IP%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%BA%94%E5%B1%82%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>  看图解网络的一些理解：  总的来说数据通过一层一层封装后 ，最终转换成电信号发送到另外一台主机，数据也从底层开始，一层一层的解包得到想要的数据；将每一层都专注自己的职责，对于开发者说更多只需要 关注应用层的处理就可以了。</p><p>此外本文 网络模型 整体做个介绍，后续会对每一层 比较主要的 知识点进行详解</p></blockquote><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>​ 使用的一些http，ftp，ssh，这些都是属于应用层，要发送的数据通过 应用层的协议包装起，传到传输层，而且应用层是处于用户态，传输层是处于内核态</p><h4 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h4><p>​收到应用层的数据包，传输层又会对这些这些数据进行打包，或者将数据分割后打包，传输层有两种协议： TCP 和UDP （这两种区别不在本文细说），此时这些操作处于内核态操作了。</p><h4 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h4><p>​传输层是准备好数据，网络层则是将数据传输到另外一个设备，此外网络层用到的是IP协议，通过该协议进行再一次封装，</p><p><img src="http://imt.rui.vin/202203231557336.png" alt="image-20220323155745319" style="zoom: 80%;"> 参考图解网络的图</p><h4 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h4><p>​同一个局域网内可以通过子网地址和主机号来区别，而不同子网呢？则需要跨网络传输，在这层也是需要对数据进行封装，而且要附带设备的mac地址，路由器计算出了下⼀个⽬的地 IP 地址，再通过 ARP 协议找到该⽬的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了</p><p><img src="http://imt.rui.vin/202203231534067.jpeg" alt="TCP/IP协议的组成"></p><p>接下来的任务就是交给 物理层里，，需要把数据包转换成电信号，让其可以在物理介质中传输</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于虚函数的一些总结</title>
    <link href="/2022/03/12/%E5%85%B3%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2022/03/12/%E5%85%B3%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>说到多态又可以联想到虚函数，虚函数又有很多相关问题，这次做个小总结</p><p>1 . 什么是虚函数</p><ul><li><p>虚函数在有多态的前提下才有的特性，现在问题是多态是什么？</p><p>  多态可以分为：</p><p>  ​静态多态：函数重载，根据参数不同，从而调用不同的函数（这里不做重点介绍）</p><p>  ​    动态多态： 根据操作的对象不同，从而调用不同的函数（使用虚函数实现）</p><p>  总的来说：  同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结</p></li></ul><p>​     现在看下动态多态是怎么使用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">Shape</span>() &#123;&#125;<br>  ~<span class="hljs-built_in">Shape</span>() &#123;&#125;<br>  <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">int</span> x, y;<br>  <span class="hljs-built_in">Rectangle</span>(<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">0</span>) &#123;<br>    x = a;<br>    y = b;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot; Rectangle area &quot;</span> &lt;&lt; x * y &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Round</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-type">int</span> x, y;<br>  <span class="hljs-built_in">Round</span>(<span class="hljs-type">int</span> a = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">0</span>) &#123;<br>    x = a;<br>    y = b;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> </span>&#123; cout &lt;&lt; <span class="hljs-string">&quot; Rount area &quot;</span> &lt;&lt; <span class="hljs-number">3.14</span> * y &lt;&lt; endl; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  Shape *t;<br>  <span class="hljs-function">Round <span class="hljs-title">r</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</span></span>;<br>  <span class="hljs-function">Rectangle <span class="hljs-title">y</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>  t = &amp;r;  <span class="hljs-comment">//基类指针指向 Round 类r</span><br>  t-&gt;<span class="hljs-built_in">area</span>(); <span class="hljs-comment">//Rount area 6.28</span><br>  t = &amp;y;  <span class="hljs-comment">// 基类指针指向 Rectangle </span><br>  t-&gt;<span class="hljs-built_in">area</span>(); <span class="hljs-comment">// Rectangle area 6</span><br>  <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>基类用 virtual 声明了函数，用基类的指针指向不同的派生类，然后基类的指向的函数也有不同的效果</p><p>那这个的原理是怎样的呢？即虚函数如何实现的？</p><p>如果一个带有虚函数的类的大小他的大小是多大呢？<br><img src="http://imt.rui.vin/202203151407880.png" alt="image-20220314163106660" style="zoom:80%;"></p><p>先不说为什么空类大小为1 ，我们先说带有虚函数的类大小为4,  因为带有虚函数的类有一个<strong>指向函数数组</strong>的指针，而指针是4个字节的，指针指向的数组可以函数，那么能否直接自己直接通过指针来调用虚函数呢？  答案是可以的</p><p><img src="http://imt.rui.vin/202203151448327.png" alt="image-20220315144827997"></p><p>如上图所示，用通过 base 实例化的 b地址 可以调用类中的虚函数，通过偏移值的不同，调用不同的函数 ，可以看出 实例化后的 b是有个指针指向一个指针数组 ，就该base类而言，内存布局如下：</p><p><img src="http://imt.rui.vin/202203151506531.png" alt="image-20220315150631707"></p><p>现在我们知道了虚函数表的如何存在的，那如何通过这个实现多态的呢？</p><p>用一个基类的指针指向派生类时候，如果派生类中有函数重载了父类的虚函数，则会替换虚函数表中对应的函数<br>就是说 ： 假如派生类也有函数 f();  此时 虚表中 f()的函数地址 会被 派生类的 f() 函数替换（也称为动态联编）<br>与基类指针 指向 f() 时，执行的是派生类的 f()</p><p><img src="http://imt.rui.vin/202203151520475.png" alt="image-20220315152052778"></p><p>大致上的原理 就这样，其实还有多细节没有补充，想着通过反汇编来看下动态联编是怎么实现，后续再来吧..</p><p>一些虚函数的问题</p><h4 id="什么函数不能声明为虚函数"><a href="#什么函数不能声明为虚函数" class="headerlink" title="什么函数不能声明为虚函数"></a>什么函数不能声明为虚函数</h4><ol><li><p>构造函数</p><p> 虚表指针的初始化时在构造函数进行的，而虚函数需要放到虚表中。在调用虚函数前，必须首先知道虚表指针，所以不行</p></li><li><p>普通函数</p><p> 虚函数需要在继承多态下使用才有意义</p></li><li><p>静态函数</p><p> 静态函数可以直接调用不需要指针</p></li><li><p>内联函数</p><p> 内联函数属于静态联编，即是编译阶段就确定调用哪个函数了，虚函数是动态联</p></li><li><p>友元函数</p><p> 有元函数不支持继承</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>C++语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reactor模式的介绍</title>
    <link href="/2022/03/12/reactor%E6%A8%A1%E6%8B%9F%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/03/12/reactor%E6%A8%A1%E6%8B%9F%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>说Reactor模式前 我们看下epoll实现的服务器有什么改进的地方</p><p>在上几篇博客有介绍 <a href="http://rui.vin/2022/03/10/%E5%AF%B9io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/">io多用复用</a> 其中主要介绍了epoll，最后 epoll实现了 io多路复用的服务器，我们再捋一捋<br>目前大致情况就是这样，现在是可以用，但是呢？ 还可以优化下吗？因为每次都是要问三次情况,有点冗余了</p><p><img src="http://imt.rui.vin/202203121406752.png" alt="image-20220312140629959"></p><p>客户端有连接也是通过一个fd来管理，也是可读事件，那么讲 客户端连接也纳入 可读事件里</p><p>现在如下图所示： </p><p>可读事件分为两种类型</p><p><img src="http://imt.rui.vin/202203121408096.png" alt="image-20220312140829460"></p><p>确实是比较精简了，现在分为两部分，可读，可写，但实际上，可读里面还是得再分 是客户端连接还是有数据可读，还可不可再改进一点呢？</p><p>现在分为两大类，<strong>一类是 可读io，****一类是可写io</strong>，这些都是对文件描述符进行操作，而且文件描述符都是独一无二的，如果说每个文件描述符都对应一个函数的话，会不会方便很多呢？对应的函数也可以分为三类，可读，可写，建立连接；那可以建立一个结构体，用来保存fd和对应的操作函数，对应的操作函数，还有一个最为关键的是  结构体 epoll_event 不但可以保存fd，和io事件响应类型，其中还有个空指针可以灵活使用。</p><p><img src="http://imt.rui.vin/202203121424505.png" alt="image-20220312142311053"></p><p>每次加入 epoll_event 之前，将 *ptr执行一个结构体，该结构体包含一个  fd 和 一个函数指针<br><img src="http://imt.rui.vin/202203121424851.png" alt="image-20220312142445086"></p><p>现在呢 可是这样来处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nready; i++) &#123;<br>   <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;   <span class="hljs-comment">//可读</span><br>     <span class="hljs-comment">// printf(&quot;sockitem\n&quot;);</span><br>     <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockitem</span> *si = (<span class="hljs-keyword">struct</span> sockitem *)events[i].data.ptr; <span class="hljs-comment">//抽出 events里的保存的结构体</span><br>     si-&gt;<span class="hljs-built_in">callback</span>(si-&gt;sockfd, events[i].events, si); <span class="hljs-comment">// 通过结构体调用对应的函数（回调函数）</span><br>   &#125;<br><br>   <span class="hljs-keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;<br>     <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockitem</span> *si = (<span class="hljs-keyword">struct</span> sockitem *)events[i].data.ptr;<br>     si-&gt;<span class="hljs-built_in">callback</span>(si-&gt;sockfd, events[i].events, si);<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>到了这里 代码模式 转化为 事件驱动  ： 有是三种事件  ，建立连接，读取数据，写入数据，有两种 fd ，listenfd 和 clientfd</p><h2 id="reactor-是什么？"><a href="#reactor-是什么？" class="headerlink" title="reactor 是什么？"></a>reactor 是什么？</h2><p>reactor 有反应堆的意思，这个堆则是 那些已经建立好的回调函数，当有 事件来了，ractor就有相对应的反应<br>这也是reactor中思想，本文中的代码也是朝着这种思想改进；reactor有三种模式</p><ul><li><p>单 Reactor 单进程 &#x2F; 线程；</p><pre><code class="hljs"> 目前现在就是处于这种模式</code></pre><p>  <img src="http://imt.rui.vin/202204062335512.png" alt="image-20220312150155896"><br>  单 Reactor 单进程的方案因为全部工作都在<strong>同一个进程</strong>内完成，所以实现起来比较简单，不需要考虑进程间通信，也不用担心多进程竞争。</p><ul><li>第一个缺点，因为只有一个进程，<strong>无法充分利用 多核 CPU 的性能</strong>；</li><li>第二个缺点，如果读写事件（业务）时间很长，而此时又突然有大量的连接接入，可能会成延迟</li></ul><p>  所以，单 Reactor 单进程的方案<strong>不适用计算机密集型的场景，只适用于业务处理非常快速的场景</strong>。</p></li><li><p>单 Reactor 多线程 &#x2F; 进程；</p><ul><li>单 Reactor 多线程</li></ul><p>  开始时和 单 Reactor 单进程 一样，但在每个事件（业务）中，handle （fd对应的函数）用一个线程来处理这些业务，处理好了返回给handle<img src="http://imt.rui.vin/202203121514636.png" alt="image-20220312151449241"></p><p>  发挥了多核cpu的威力，线程直接通讯比较方便，但是使用多线程必然会产生资源竞争的问题，那要考虑线程锁的问题了</p><ul><li><p>单 Reactor 多进程</p><p>  单 Reactor 多进程 用的比较少，不过还是可以实现，用fork则是可以实现，进程间通讯比较麻烦（共享内存可以做到）…</p></li></ul><p>  「单 Reactor」的模式还有个问题，<strong>因为一个 Reactor 对象承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方</strong>。</p></li><li><p>多 Reactor 多进程 &#x2F; 线程；</p><p>  该模式和前两者相比是把Reactor线程拆分了mainReactor和subReactor两个部分，mainReactor只处理连接事件，读写事件交给subReactor来处理。业务逻辑还是由线程池来处理。</p></li></ul><p><img src="http://imt.rui.vin/202203121528400.png" alt="image-20220312152848304"></p><p>通俗点就是说 ： 一个线程用于接收客户端连接，处理业务的用一个线程池来处理，池里有多少个线程按照多少个cpu的核心数而定。</p><p>待更新…</p>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>char*和char[]的区别</title>
    <link href="/2022/03/11/char-%E5%92%8Cchar-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/03/11/char-%E5%92%8Cchar-%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>关于此类的问题都放在这里了，不另起文章了</p><p>遇到了一道题目：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">fun1</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">char</span> *x = <span class="hljs-string">&quot;abcd&quot;</span>;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">char</span> *<span class="hljs-title">fun2</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">char</span> str[] = <span class="hljs-string">&quot;abcd&quot;</span>;  <span class="hljs-comment">//存放在静态数据区</span><br>  <span class="hljs-keyword">return</span> str;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  cout &lt;&lt; <span class="hljs-built_in">fun1</span>() &lt;&lt; endl;  <span class="hljs-comment">//abcd</span><br>  cout &lt;&lt; <span class="hljs-built_in">fun2</span>() &lt;&lt; endl;  <span class="hljs-comment">// </span><br>  <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个输出是怎样的？<br>第一时间就意识到 函数调用结束后，这些变量不是都被回收了吗，那应该不存在才对  （想到的是栈的特性）</p><p>于是上机一测，发现fun1是有输出的，fun2没有， 哦？ 那这样说明  字符常量不是在栈里分配内存的？</p><p>原来 字符串常量也是存储在<strong>静态存储区</strong>，那这样就是说，char *p 指向的内存没有被回收，嗯，这样就说的通了</p><p>而  char str[] 呢？ 前几天遇到一个题目  strlen(“abcd”)  结果是？ 第一次看到这个 ，有点蒙，“abcd” 也是变量吗？<br>上机一测还真是 4 个字节，尝试下  <strong>cout &lt;&lt; &amp;”abcd” &lt;&lt; endl;</strong>  发现这也是有地址的！！！！ 所以也说的通了，</p><p> char str[] 是个字符数组，字符数组是有占用空间的，  在执行    <strong>char str[] &#x3D; “abcd”</strong>    时候，发生了一次拷贝将<br>内存”abcd”拷贝到str数组中，函数结束运行的时候，str的空间也被回收了，而对于char *p 而言，回收的知识这个<br>p的指针（指针也是变量）</p><p>还有个实验完全可以证明， 字符串常量是在 静态存储区</p><p><img src="http://imt.rui.vin/202203112350024.png" alt="image-20220311235052265"></p><p><strong>尽管fun1结束了，打印“abcd”的地址还是和fun1运行时的一样</strong></p><p>总结 ： fun1 中的 x执行的内存是 是在  静态存储区 不是堆也不是栈<br>             fun2 中的 str保存在栈中</p><hr><p>sizeof  和 strlen的用法区别 小结</p><ul><li><p>sizeof是关键字  获取某个数据类型所占用空间的字节数</p></li><li><p>strlen是函数可以看有多少个字符 以 ‘\0’ 结束</p></li><li><p>典型问题  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;abcdd&quot;</span>;     <span class="hljs-comment">//  abcdd 在一片连续内存中，并且占用了6个字节  最后一个字节是 &#x27;\0&#x27;  注意：str的指针指向这一片 内存地址</span><br> <span class="hljs-type">char</span> strp[] = <span class="hljs-string">&quot;asdfe&quot;</span>;   <span class="hljs-comment">//  上文说过是 asdfe拷贝到strp字符数里面    strp里面有 6个字节大小</span><br> cout &lt;&lt; <span class="hljs-built_in">strlen</span>(str)  &lt;&lt;  endl;  <span class="hljs-comment">//5    遇到最后一个 &#x27;\0&#x27; 就结束了</span><br> cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(str)  &lt;&lt;  endl;  <span class="hljs-comment">//4 对str这个变量的类型大小计算    str是个字符指针   所以是4个字节</span><br> cout &lt;&lt; <span class="hljs-built_in">strlen</span>(strp) &lt;&lt;  endl;  <span class="hljs-comment">//5  遇到最后一个 &#x27;\0&#x27; 就结束了</span><br> cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(strp)  &lt;&lt;  endl;  <span class="hljs-comment">//6 对strp这个变量类型大小计算   strp是个字符数组，计算整个数组的字节数大小</span><br><br><span class="hljs-comment">/*----------*/</span><br><span class="hljs-type">char</span> p[] =  &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>&#125;;<br><span class="hljs-type">char</span> q[] =  &#123;<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;  <span class="hljs-comment">//这种情况下末尾是不带 &#x27;\0&#x27; 的</span><br>cout &lt;&lt; <span class="hljs-built_in">strlen</span>(q) &lt;&lt;  endl;   <span class="hljs-comment">//没有 &#x27;\0&#x27; 结束标志 结果为止</span><br>cout &lt;&lt; <span class="hljs-built_in">strlen</span>(p) &lt;&lt;  endl;  <span class="hljs-comment">//5 有结束标志</span><br><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(q) &lt;&lt;endl;   <span class="hljs-comment">// 5 直接找到数组的大小</span><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(p) &lt;&lt;endl;   <span class="hljs-comment">// 7</span><br><br><br></code></pre></td></tr></table></figure><p>  总结： 这种就是要注意 字符后面有无带  结束标志 ‘\0’ ,  sizeof是统计 对象类型所占的空间  strlen 是遍历内存遇到 ‘\0’ 结束</p>  <img src="http://imt.rui.vin/202203161950232.png" alt="image-20220316195022149" style="zoom: 67%;"></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>基础语法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>epoll中 LT 和 ET 区别</title>
    <link href="/2022/03/11/epoll%E4%B8%AD%20LT%20%E5%92%8C%20ET%20%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/03/11/epoll%E4%B8%AD%20LT%20%E5%92%8C%20ET%20%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>上文解释过epoll 原理，现在梳理下epoll 的用法和 epoll 中两个读取数据的模式</p><p>现在用epoll 实现一个多路复用的服务器(代码在最后)</p><ul><li>LT 水平触发  有数据到来就一直读，直到没有数据可以读取了        </li><li>ET 边缘触发  有到无，读规定的字节数，没读完，下次有事件了再读取</li></ul><p>读取客户端发来的数据时候，只读五个字节，看下ET和LT会有什么不同</p><p><img src="http://imt.rui.vin/202203112222329.png" alt="image-20220311222200962"></p><ul><li>ET模式下 <strong>必须使用非阻塞fd</strong>：</li></ul><p><img src="http://imt.rui.vin/202203112229580.png" alt="image-20220311222904069"></p><p>连接后：</p><p><img src="http://imt.rui.vin/202203112223478.png" alt="image-20220311222323848"></p><p>第一次客户端发了 7 个字节，而服务器只接受五个字节就结束，第二次客户端发送一个字节，客户读取了三个字节，显然还是读取上一次未读取的完的，  所以et模式就是 自己能在缓冲区读多少就读多少，读不完下次还来读</p><ul><li>LT模式下：<br>  如果没有设置，默认的是LT模式<br>  <img src="http://imt.rui.vin/202203112228039.png" alt="image-20220311222834196"></li></ul><p>​<img src="http://imt.rui.vin/202203112232077.png" alt="image-20220311223210774"></p><p>​客户端发送了15个字节，服务器读了三次，也就是说只要缓冲区没读完，就一直有事件响应，  LT   等效于    （一个while + ET）</p><p>​实现原理还有待后续挖掘（待填坑）</p><p>服务端代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/tcp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/epoll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUFFER_LENGTH 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> POLL_SIZE 1024</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EPOLL_SIZE 1024</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Paramter Error\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> port = <span class="hljs-built_in">atoi</span>(argv[<span class="hljs-number">1</span>]);<br><br>  <span class="hljs-type">int</span> sockfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (sockfd &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;socket&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> addr;<br>  <span class="hljs-built_in">memset</span>(&amp;addr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in));<br><br>  addr.sin_family = AF_INET;<br>  addr.sin_port = <span class="hljs-built_in">htons</span>(port);<br>  addr.sin_addr.s_addr = INADDR_ANY;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">bind</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;addr, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in)) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;bind&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listen</span>(sockfd, <span class="hljs-number">5</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;listen&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;<br>  <span class="hljs-comment">//相当于建立一颗  红黑树</span><br>  <span class="hljs-type">int</span> epoll_fd = <span class="hljs-built_in">epoll_create</span>(EPOLL_SIZE);<br>  <span class="hljs-comment">// ev 是保存 fd的结构体</span><br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">epoll_event</span> ev, events[EPOLL_SIZE] = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-comment">//初始化 ev</span><br>  ev.events = EPOLLIN;  <span class="hljs-comment">//事件类型</span><br>  ev.data.fd = sockfd;  <span class="hljs-comment">// sockfd是监听有无用户连接的io</span><br>  <span class="hljs-comment">//向红黑树中插入 节点</span><br>  <span class="hljs-built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, sockfd, &amp;ev);<br>  <span class="hljs-comment">//开始</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// nready 是意思是有几个事件产生，并且会将产生的事件放在 events数组中</span><br>    <span class="hljs-type">int</span> nready = <span class="hljs-built_in">epoll_wait</span>(epoll_fd, events, EPOLL_SIZE, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span> (nready == <span class="hljs-number">-1</span>) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;epoll_wait\n&quot;</span>);<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">//开始遍历</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; nready; i++) &#123;<br>      <span class="hljs-comment">// sockfd有响应说明 有新的客户端来连接了</span><br>      <span class="hljs-keyword">if</span> (events[i].data.fd == sockfd) &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> client_addr;<br>        <span class="hljs-built_in">memset</span>(&amp;client_addr, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in));<br>        <span class="hljs-type">socklen_t</span> client_len = <span class="hljs-built_in">sizeof</span>(client_addr);<br><br>        <span class="hljs-type">int</span> clientfd =<br>            <span class="hljs-built_in">accept</span>(sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_len);<br>        <span class="hljs-keyword">if</span> (clientfd &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-type">char</span> str[INET_ADDRSTRLEN] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;recvived from %s at port %d, sockfd:%d, clientfd:%d\n&quot;</span>,<br>               <span class="hljs-built_in">inet_ntop</span>(AF_INET, &amp;client_addr.sin_addr, str, <span class="hljs-built_in">sizeof</span>(str)),<br>               <span class="hljs-built_in">ntohs</span>(client_addr.sin_port), sockfd, clientfd);<br><br>        ev.events = EPOLLIN;<br>        ev.data.fd = clientfd;<br>        <span class="hljs-built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, clientfd, &amp;ev);<br>      &#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//这种情况是连接得用户有io响应</span><br>        <span class="hljs-type">int</span> clientfd = events[i].data.fd;<br><br>        <span class="hljs-type">char</span> buffer[BUFFER_LENGTH] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-comment">//读取数据</span><br>        <span class="hljs-type">int</span> ret = <span class="hljs-built_in">recv</span>(clientfd, buffer, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read all data&quot;</span>);<br>            <span class="hljs-keyword">continue</span>;<br>          &#125;<br>          <span class="hljs-comment">//释放  fd</span><br>          <span class="hljs-built_in">close</span>(clientfd);<br> <span class="hljs-comment">//设置为  ET模式 </span><br>          ev.events = EPOLLIN | EPOLLET;   <br>          ev.data.fd = clientfd;<br>          <span class="hljs-comment">//从红黑树删除</span><br>          <span class="hljs-built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_DEL, clientfd, &amp;ev);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; disconnect %d\n&quot;</span>, clientfd);<br>          <span class="hljs-comment">// ret == 0;  ret</span><br>          <span class="hljs-built_in">close</span>(clientfd);<br><br>          ev.events = EPOLLIN;<br>          ev.data.fd = clientfd;<br>          <span class="hljs-built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_DEL, clientfd, &amp;ev);<br><br>          <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Recv: %s, %d Bytes\n&quot;</span>, buffer, ret);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-comment">// struct sockaddr_in</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-comment">// inet_addr</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-type">int</span> x;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> <span class="hljs-comment">//信号到来，则执行这个函数，输出超时</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-built_in">close</span>(x);<br>  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-type">int</span> socket_desc;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> server;<br>  <span class="hljs-type">char</span> *message, server_reply[<span class="hljs-number">2000</span>];<br>  <span class="hljs-built_in">signal</span>(SIGINT, handler);<br>  <span class="hljs-comment">// 创建socket</span><br>  socket_desc = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">if</span> (<span class="hljs-number">-1</span> == socket_desc) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;cannot create socket&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  x = socket_desc;<br>  <span class="hljs-comment">// 设置远程服务器的信息</span><br>  server.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>  server.sin_family = AF_INET;<br>  server.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">1234</span>);<br><br>  <span class="hljs-comment">// 连接</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect</span>(socket_desc, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;server, <span class="hljs-built_in">sizeof</span>(server)) &lt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;cannot connect&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-comment">// 发送数据</span><br><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>    std::string str;<br>    std::cin &gt;&gt; str;<br>    str.<span class="hljs-built_in">c_str</span>();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">send</span>(socket_desc, str.<span class="hljs-built_in">c_str</span>(), str.<span class="hljs-built_in">size</span>(), <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;send data error&quot;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect success&quot;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>- </p>]]></content>
    
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对io多路复用的一些理解</title>
    <link href="/2022/03/10/%E5%AF%B9io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <url>/2022/03/10/%E5%AF%B9io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"><h4 id="1-什么是io多路复用"><a href="#1-什么是io多路复用" class="headerlink" title="1.什么是io多路复用"></a>1.什么是io多路复用</h4> <span id="more"></span><p>​    <strong>多路复用是同步的！！！！</strong></p><p>​单个进z程管理多个文件描述符<br>​总的来说就使用单个进程管理（监听）更多的io</p><h4 id="2-io多路复用模型-通俗的解释，如何用，底层原理是什么？"><a href="#2-io多路复用模型-通俗的解释，如何用，底层原理是什么？" class="headerlink" title="2.io多路复用模型 通俗的解释，如何用，底层原理是什么？"></a>2.io多路复用模型 通俗的解释，如何用，底层原理是什么？</h4><ul><li><p>通俗的理解 举个例子：</p><p>  有一家新开的饭店，开始的时候，他是这样安排服务员的：每一桌都安排一个服务员，这个服务员负责这张桌子的点菜，茶水；顾客点完菜，服务员把菜单<strong>送到后厨</strong>， 饭店刚开始只有10几张桌子，后来每天都有百余张桌子，出现了一个问题，有时候后厨一下子塞满了人，出现了拥堵，客人那边长时间没人服务….（<strong>类比多进程管理多个io</strong>）</p><p>  后来饭店老板想到了一个方法，让一个人来专门送菜单都后厨，这个服务员呢会逐个逐个问那些服务员，有没有菜单要送到后厨的，收集完了后然再统一拿到后厨，这样后厨就不会拥堵啦。（类比单进程管理多个io，这个类似select 做法）</p><p>  可还是有问题，一张一张桌去问还是太费时间了，有些顾客点了菜就不在点菜了，有的要点很久，再后来，老板又想到了一个方法，每个桌子都安装一个按钮，顾客点好菜了，嗯按钮，那个专门收集菜单的人就去那张桌子那菜单（epoll ）；</p></li></ul><p>​    以上并不是概念，只是抽象的比喻而已，对io多路复用模型有 三种  ： select ，poll，epoll</p><p>​ select：  虽然效率不高，但可以跨平台；单个进程只能保存1024个fd，轮询访问<br>​</p><p>​      poll:   和select相同，但是使用数组的形式保存fd，无上限，同样也是轮询访问</p><p><img src="http://imt.rui.vin/202203101426837.png" alt="image-20220310132555292"></p><hr><p>​ epoll： 这个比较重要，详细说下<br>​  再来做个比喻，有个小区，一开始小区里的人寄快递都是叫快递员上门取件，或者是去快递店里寄，前者有点费快递员的人力，后者可以有浪费顾客的时间，后来快递公司想到了一个方法， 在小区里建立了一个无人快递收件柜子（蜂巢），顾客把想寄的东西都放在那个柜子了，快递人员到一定的时间带个大袋子，把要寄送的东西带走，这样就省去快递员挨家挨户的收快递，提高了效率；</p><p>​    小区里的人就是 那些文件io，柜子里的装的东西就是 有事件响应的io，这样就不用挨个去遍历了，每次快递员到了时间点了（timeout）就去拿柜子里的快递。<br>​这样也挺容易理解的，但要是问如何实现的呢，前两种还可理解，遍历fd所以时间复杂度为 O(n) ，而epoll是怎么做到  O(1)呢？</p><p>​以前也被问过：epoll怎么实现的，一般都是说红黑树加双向链表实现的，然后就说不下去了….</p><p>​    epoll 使用就不在多说，现在说个话题 为什么 epoll 时间复杂度可以做到O（1） 呢？</p><p>​    我们一般都会说，底层把有事件发生的io放在一个队列里（此时io可以理解为分配给客户端的一个fd），这个对个队列是一个双向链   表，插入的时间复杂为O（1），</p><p>​没错，在用户态 我们遍历队列的时候，可以保证遍历的每个io都是有事件发生，效率肯定是上去了，那么在内核态，底层是如何把有事 件发生的io放到队列呢？ 怎么放我们已经知道了，现在问题是在那么多io里，怎么马上挑出有事件的io呢？难道也是在内核态全部  遍历一次？我一开始也百思不得其解，查阅很多资料知道，原来在更底层有那么一个机制，当一个io有事件发生会产生一个软终端，然 后我想到了 信号，信号的类型有个是  SIGIO（这里的软中断我也不是很确定是不是io中断)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">sigaction</span>(SIGIO, &amp;sigio_action, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>  当io有什么事件发生时候，会马上调用这个对应的回调函数（信号是的使用机智我们也知道），那这样，我并不需要每个io的去问有没有事件发生，内核就每个io都设置一个回调函数，那么io有事件了，马上调用回调函数，那么就准备把这个io装在队列里面里，而红黑树的作用就是管理这些io并设置其回调函数，就好像这个api</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">epoll_ctl</span>(epfd, EPOLL_CTL_ADD, sockfd, &amp;ev);<br></code></pre></td></tr></table></figure><p>把新的io加入到红黑树里面，然后注册一个对应的回调函数，我们都知道红黑树的特性是 增删改查时间复杂度稳定 为 logn，有io退出，  取消对应的回调函数，然后删除这个io</p><p>以上就是当前对epoll底层实现 的初步了解，后续看了源码再来更新</p><p>具体流程如下如下所示  （在知乎看到的）</p><p><img src="http://imt.rui.vin/202203111203054.png" alt="image-20220310135031722"></p><h4 id="3-epoll-和-select-用哪个好"><a href="#3-epoll-和-select-用哪个好" class="headerlink" title="3 .epoll 和  select 用哪个好"></a>3 .epoll 和  select 用哪个好</h4><p>​这也是要结合场景使用，如果 连接数比较少，事件响应比较多的时候用select 性能较好一些。涉及到大并发连接是，任意事件段io并不是很活跃可以使用 epoll</p><hr><h4 id="epoll-是同步还是异步？"><a href="#epoll-是同步还是异步？" class="headerlink" title="epoll 是同步还是异步？"></a>epoll 是同步还是异步？</h4><p>从内核态来看，是异步的，无需一直等待事件的发生，有事件io发生，就把这个io 塞到队列里，这好像也没毛病</p><p>从用户态说：  int nready &#x3D; epoll_wait(epoll_fd, events, EPOLL_SIZE, -1);   如果 nready 返回大于0，说明 events里面有东西，就就去遍历，没有就继续等待，所以说  用户态来说  epoll_wait是同步的</p><p>在知乎看到这样的解释， 对epoll而言 很多操作都放到 内核去做处理，也就是说让操作系统帮我们做一些事情，从 一开始 io阻塞模型 到 io多路复用，随着技术的迭代，在底层操作系统帮我们做的事越来越多了 （ 好像这样说也不是很对，后续再花点时间重新捋一下 五种io模型 ）</p><p><img src="http://imt.rui.vin/202203250002719.png" alt="知乎上截图的"> </p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-动态规划</title>
    <link href="/2022/03/09/leetcode/LeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/2022/03/09/leetcode/LeetCode-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<ul><li><p>自己理解：</p><pre><code class="hljs"> **当前状态是由上一个状态推出来的，那么就会有个动态的过程，就会有一个公式，就是 状态转移公式，对于解题来说，主要的工作 是找到 这个公式，其实也可以说 是找规律（个人理解）**</code></pre></li></ul> <span id="more"></span><h4 id="1-乘积最大子数组"><a href="#1-乘积最大子数组" class="headerlink" title="1. 乘积最大子数组"></a><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">1. 乘积最大子数组</a></h4><p>给你一个整数数组 nums ，请你找出数组中乘积最大的非空<strong>连续子数组</strong>（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。数组中有正负数。</p><p>思路： 有负数就很棘手，数组中若是有两个负数最大值就没那么容易推测了<br>看下dp值有多少中推测的可能性呢？  </p><ol><li>当前的值  </li><li>当前的值 乘以 上一个dp最大值  </li><li>当前的值是负数时候，乘以上一个dp最小的值（负负得正）</li></ol><p>应该还要有一个dp记录最小的值，也许这个最小的值 乘以当前的值  成为正数了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dpmax</span><span class="hljs-params">(len, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">//用来保存dp最大值</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dpmin</span><span class="hljs-params">(len, <span class="hljs-number">0</span>)</span></span>;  <span class="hljs-comment">//用来记录dp最小值</span><br>    dpmin[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    dpmax[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> resMax = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-comment">//最大值有三种推测方法</span><br>        <br>        dpmax[i] = <span class="hljs-built_in">max</span>(nums[i],<span class="hljs-built_in">max</span>(dpmax[i<span class="hljs-number">-1</span>]*nums[i],dpmin[i<span class="hljs-number">-1</span>]*nums[i]));<br>        <span class="hljs-comment">//最小值也有三种推测方法</span><br>        dpmin[i] = <span class="hljs-built_in">min</span>(nums[i]*dpmin[i<span class="hljs-number">-1</span>],<span class="hljs-built_in">min</span>(nums[i],dpmax[i<span class="hljs-number">-1</span>]*nums[i]));<br>        <span class="hljs-comment">//都看当前dp值是哪个比较大</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">max</span>(dpmax[i],dpmin[i]);<br>        resMax = <span class="hljs-built_in">max</span>(resMax,res);<br>    &#125;<br>        <span class="hljs-keyword">return</span> resMax;<br>    &#125;<br></code></pre></td></tr></table></figure><p>总结： 当前的转态是由前面转态推出来的，但是这个退的过程有时候是由条件限制的，这个要考虑清楚一些</p><h4 id="2-最大子数组和"><a href="#2-最大子数组和" class="headerlink" title="2. 最大子数组和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/">2. 最大子数组和</a></h4><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p>这题和上个题目一样 ，相对于来说更简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(nums.size())</span></span>;<br>        dp[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> res = dp[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            dp[i] = <span class="hljs-built_in">max</span>(nums[i],dp[i<span class="hljs-number">-1</span>]+nums[i]);  <span class="hljs-comment">//当前知道dp值可以是上一个dp加上当前nums值或者是当前的nums</span><br>            res = <span class="hljs-built_in">max</span>(dp[i],res);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="3-斐波那契数"><a href="#3-斐波那契数" class="headerlink" title="3. 斐波那契数"></a><a href="https://leetcode-cn.com/problems/fibonacci-number/">3. 斐波那契数</a></h4><p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><p>$$<br>F(0) &#x3D; 0，F(1) &#x3D; 1<br>F(n) &#x3D; F(n - 1) + F(n - 2)，其中 n &gt; 1<br>$$<br>给定 n ，请计算 F(n) 。</p><p> 用个递归可以推出来，但这个用动态解决<br>思路：    当前状态是由上一个状态推出来的，所以要找出这个转态方程是最为关键的</p><p>当前的数是由上两个数推出来的   所以：  转态方程   dp[i] &#x3D; dp[i - 1] + dp[i - 2]</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c#"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">fib</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span>&#123;<br><span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> n;<br><span class="hljs-built_in">int</span> dp[n + <span class="hljs-number">1</span>];<br>dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>&#123;<br>dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-爬楼梯"><a href="#3-爬楼梯" class="headerlink" title="3. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/">3. 爬楼梯</a></h4><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>思路：  假如有3阶楼梯 ，如何求呢？</p><ul><li><p>有3阶楼，我从第二阶楼梯上第三节楼梯只有一种方法 – 走一步</p></li><li><p>现在问题转变了 上到第二阶楼梯需要多少步？  如果我知道上第一阶楼梯是不是也可以求出第二阶楼梯了？</p><p>  所以可以推出转态方程 ：</p><p>  dp[i] &#x3D; dp[i - 1] + dp[i - 2]   </p><p>  其实 和 斐波那契数一样</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> n;<br><span class="hljs-type">int</span> dp[n + <span class="hljs-number">1</span>];<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span>; i &lt;= n; i++)<br>&#123;<br>dp[i] = dp[i - <span class="hljs-number">1</span>] + dp[i - <span class="hljs-number">2</span>];<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br>   &#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-回溯</title>
    <link href="/2022/03/08/leetcode/LeetCode-%E5%9B%9E%E6%BA%AF/"/>
    <url>/2022/03/08/leetcode/LeetCode-%E5%9B%9E%E6%BA%AF/</url>
    
    <content type="html"><![CDATA[<p>​回溯   -》 穷举</p><span id="more"></span><ul><li><p>回溯函数模板返回值以及参数</p></li><li><p>回溯函数终止条件</p></li><li><p>回溯搜索的遍历过程</p>  <figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">backtracking</span>(参数) &#123;<br>    if (终止条件) &#123;<br>        存放结果;<br>        return;<br>    &#125;<br><br>    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;<br>        处理节点;<br>        <span class="hljs-built_in">backtracking</span>(路径，选择列表); <span class="hljs-comment">// 递归</span><br>        回溯，撤销处理结果<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-组合"><a href="#1-组合" class="headerlink" title="1. 组合"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/">1. 组合</a></h4><p>  给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>  你可以按 <strong>任何顺序</strong> 返回答案。</p><p>  思路： 数字中有多少中组合，k为2的话，两个for可以解决，k为为100 就不能这么做了</p><p>  首先 ：</p><ul><li><p>回溯函数的模版是怎样的 </p><p> ​不需要返回值，参数需要 知道哪里开始，哪里结束，截止需要的条件</p></li><li><p>终止条件</p><p>  ​回溯拿到k个数的时候即停止</p></li><li><p>就改题而言过程是要遍历每个数，即一for循环加上回溯函数</p></li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;  <span class="hljs-comment">//最终结果保存的地方</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;  <span class="hljs-comment">//每一轮回溯结果保存的地方</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">back</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> index)</span></span>&#123; <span class="hljs-comment">//n 哪里结束，k 截止需要的条件，index 其实的地方</span><br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;    <span class="hljs-comment">//当path 满足 k 个时候就可以保存到 res中</span><br>            res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt;= n ;i++)&#123;   <span class="hljs-comment">// 遍历每个数  每个数都可能做为第一个数</span><br>            path.<span class="hljs-built_in">push_back</span>(i);            <span class="hljs-comment">//保存</span><br>            <span class="hljs-built_in">back</span>(n,k,i+<span class="hljs-number">1</span>);   <span class="hljs-comment">// i+1 意思是下一轮从下一个数开始</span><br>            path.<span class="hljs-built_in">pop_back</span>();              <span class="hljs-comment">//满足条件了，就出栈，腾出空间给下个数</span><br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-built_in">back</span>(n,k,<span class="hljs-number">1</span>); <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-组合总和-III"><a href="#2-组合总和-III" class="headerlink" title="2. 组合总和 III"></a><a href="https://leetcode-cn.com/problems/combination-sum-iii/">2. 组合总和 III</a></h4><p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p><p>只使用数字1到9<br>每个数字 最多使用一次<br>返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p><ul><li>和上题差不多，1到9的数字总，k个组合的数之和为n</li></ul><p>还是来三部曲：</p><ul><li><p>回溯函数的参数  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">back</span>(<span class="hljs-type">int</span> target,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> sum) <span class="hljs-comment">//k 为组合个数，target 组合之和，index 起始的地方，sum 记录总和</span><br></code></pre></td></tr></table></figure></li><li><p>终止条件</p><p>  组合个数位k，并且呢 组合之和为 target</p></li><li><p>搜索过程</p><p>  还是遍历，就是遍历计数时 还要记录总和sum</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;  <span class="hljs-comment">//最终结果保存的地方</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;  <span class="hljs-comment">//每一轮回溯结果保存的地方</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">back</span><span class="hljs-params">(<span class="hljs-type">int</span> target,<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> sum)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>() == k)&#123;    <span class="hljs-comment">//当path 满足 k 个时，sum 等于 target</span><br>            <span class="hljs-keyword">if</span>(sum == target)<br>                res.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = index; i &lt;= <span class="hljs-number">9</span> ;i++)&#123;   <span class="hljs-comment">// 遍历每个数  每个数都可能做为第一个数</span><br>            path.<span class="hljs-built_in">push_back</span>(i);            <span class="hljs-comment">//保存</span><br>            sum = sum + i;<span class="hljs-comment">//这里计算总和</span><br>            <span class="hljs-built_in">back</span>(target,k,i+<span class="hljs-number">1</span>,sum);  <br>            path.<span class="hljs-built_in">pop_back</span>();              <span class="hljs-comment">//出栈了，总和也要</span><br>            sum = sum -i;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum3</span>(<span class="hljs-type">int</span> k, <span class="hljs-type">int</span> n) &#123;<br>        <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">back</span>(n,k,<span class="hljs-number">1</span>,sum);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-堆栈问题</title>
    <link href="/2022/03/07/leetcode/LeetCode-%E5%A0%86%E6%A0%88%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/07/leetcode/LeetCode-%E5%A0%86%E6%A0%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="1-有效的括号"><a href="#1-有效的括号" class="headerlink" title="1. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/">1. 有效的括号</a></h4><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p> <span id="more"></span><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><p>思路： 频率比较高的，遍历字符，遇到左括号入栈对应右括号，直到 遇到右括号则出栈，出栈的字符是否和当前遍历的右括号相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>  map&lt;<span class="hljs-type">char</span>,<span class="hljs-type">char</span>&gt; m &#123;&#123;<span class="hljs-string">&#x27;)&#x27;</span>,<span class="hljs-string">&#x27;(&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;]&#x27;</span>,<span class="hljs-string">&#x27;[&#x27;</span>&#125;,&#123;<span class="hljs-string">&#x27;&#125;&#x27;</span>,<span class="hljs-string">&#x27;&#123;&#x27;</span>&#125;&#125;;<br>      stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>      <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s)<br>&#123;<br><span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">count</span>(ch)) <span class="hljs-comment">//判断插入的是不是右括号</span><br>&#123;<br><span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>() || stk.<span class="hljs-built_in">top</span>() != m[ch])  <span class="hljs-comment">//如果是空的 又插入右括号， 或者顶部的括号和插入的不匹配</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>stk.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">//如果匹配 出栈</span><br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>stk.<span class="hljs-built_in">push</span>(ch);  <span class="hljs-comment">//入栈左括号</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//如果为空返回1k</span><br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="2-栈模拟队列"><a href="#2-栈模拟队列" class="headerlink" title="2 . 栈模拟队列"></a>2 . 栈模拟队列</h4><p>思路： 可以使用两个栈模拟队列，一个栈用装进入队列的元素，另一个用于出队列</p><p><img src="http://imt.rui.vin/202203071749015.png" alt="image-20220307174940369"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; stIn;<br>    stack&lt;<span class="hljs-type">int</span>&gt; stOut;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br><br>    &#125;<br>    <span class="hljs-comment">/** Push element x to the back of queue. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        stIn.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br><br>    <span class="hljs-comment">/** Removes the element from in front of queue and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）</span><br>        <span class="hljs-keyword">if</span> (stOut.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-comment">// 从stIn导入数据直到stIn为空</span><br>            <span class="hljs-keyword">while</span>(!stIn.<span class="hljs-built_in">empty</span>()) &#123;<br>                stOut.<span class="hljs-built_in">push</span>(stIn.<span class="hljs-built_in">top</span>());<br>                stIn.<span class="hljs-built_in">pop</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> result = stOut.<span class="hljs-built_in">top</span>();<br>        stOut.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/** Get the front element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// 直接使用已有的pop函数</span><br>        stOut.<span class="hljs-built_in">push</span>(res); <span class="hljs-comment">// 因为pop函数弹出了元素res，所以再添加回去</span><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns whether the queue is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stIn.<span class="hljs-built_in">empty</span>() &amp;&amp; stOut.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="3-队列模拟栈"><a href="#3-队列模拟栈" class="headerlink" title="3 . 队列模拟栈"></a>3 . 队列模拟栈</h4><p>思路： 一个队列而模拟栈，入栈和入队列一样，但是出的时候是最早进来的那个数，栈则是最后进来那个，每次模拟出栈的时候都应该出去的队列中最后一个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    <span class="hljs-comment">/** Initialize your data structure here. */</span><br>    <span class="hljs-built_in">MyStack</span>() &#123;<br><br>    &#125;<br>    <span class="hljs-comment">/** Push element x onto stack. */</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        que.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <span class="hljs-comment">/** Removes the element on top of the stack and returns that element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>();<br>        size--;<br>        <span class="hljs-comment">// 队列pop元素，只剩下一个的时候则是栈应出的元素，而pop的元素又重新进入队列</span><br>        <span class="hljs-keyword">while</span> (size--) &#123; <span class="hljs-comment">// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部</span><br>            que.<span class="hljs-built_in">push</span>(que.<span class="hljs-built_in">front</span>());<br>            que.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> result = que.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">// 此时弹出的元素顺序就是栈的顺序了</span><br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/** Get the top element. */</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">back</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/** Returns whether the stack is empty. */</span><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4-最小栈"><a href="#4-最小栈" class="headerlink" title="4 . 最小栈"></a>4 . 最小栈</h4><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>思路：</p><p>​1.  用一个辅助栈，一保存入栈的数，另一个栈保存每个数（每个栈层对应的最小值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; x_stack;<br>    stack&lt;<span class="hljs-type">int</span>&gt; min_stack;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>        min_stack.<span class="hljs-built_in">push</span>(INT_MAX);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        x_stack.<span class="hljs-built_in">push</span>(x);<br>        min_stack.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">min</span>(min_stack.<span class="hljs-built_in">top</span>(), x));<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        x_stack.<span class="hljs-built_in">pop</span>();<br>        min_stack.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x_stack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> min_stack.<span class="hljs-built_in">top</span>();<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>​2. 不用辅助栈，每次入栈的值为两个，一个是入栈的值，一个是当前的内的最小值 （思想还是和辅助栈一样）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-built_in">MinStack</span>() &#123;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>            st.<span class="hljs-built_in">push</span>(&#123;x, x&#125;);  <span class="hljs-comment">//第一次入栈 ，最小值和本身相同</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            st.<span class="hljs-built_in">push</span>(&#123;x, <span class="hljs-built_in">min</span>(x, st.<span class="hljs-built_in">top</span>().second)&#125;);  <span class="hljs-comment">//待入栈的值， 和 当前的最下值</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        st.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>().first; <br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>().second;  <span class="hljs-comment">//最小值是 当前栈顶的第二个值</span><br>    &#125;<br><span class="hljs-keyword">private</span>:<br>    stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; st;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h4 id="4-滑动窗口最大值"><a href="#4-滑动窗口最大值" class="headerlink" title="4. 滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">4. 滑动窗口最大值</a></h4><p>给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</p><p>返回 滑动窗口中的最大值 。</p><p>输入：nums &#x3D; [1,3,-1,-3,5,3,6,7], k &#x3D; 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值</p><hr><blockquote><p>[1  3  -1] -3  5  3  6  7       3<br> 1 [3  -1  -3] 5  3  6  7       3<br> 1  3 [-1  -3  5] 3  6  7       5<br> 1  3  -1 [-3  5  3] 6  7       5<br> 1  3  -1  -3 [5  3  6] 7       6<br> 1  3  -1  -3  5 [3  6  7]      7</p></blockquote><p>每次移动窗口，找到窗口中最大的数<br>可以自己设计一个队列，大的数总是在最前面，每次进入入栈的时候，如果入栈的数大于队列最后的数，则该最后的数pop出来，这样一来可以保持队列单调递增</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  deque&lt;<span class="hljs-type">int</span>&gt; que;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>   <span class="hljs-comment">//入队列原则   入列的数若是大于 队列最后一个数则先pop出最后的数在入列 保持单调递增</span><br>    <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; val &gt; que.<span class="hljs-built_in">back</span>()) &#123;<br>      que.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    que.<span class="hljs-built_in">push_back</span>(val);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-comment">//如果队列满足了k个数，出队列的数是否等于队列最前面的数</span><br>    <span class="hljs-keyword">if</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; val == que.<span class="hljs-built_in">front</span>()) &#123;<br>      que.<span class="hljs-built_in">pop_front</span>();<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getfron</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">front</span>(); &#125;<br>  <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-comment">//把k 个数先入队列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span>  i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>      <span class="hljs-built_in">push</span>(nums[i]); <span class="hljs-comment">//用编写好的push入栈</span><br>    &#125;<br>    res.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">front</span>()); <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>     <span class="hljs-comment">// nums[i - k] 看下 k个数之前入队列的数是不是现在队列最起前面的</span><br>     <span class="hljs-comment">//如果是 pop出去，因为如果是的话说明队列元素已经达到</span><br>      <span class="hljs-built_in">pop</span>(nums[i - k]);<br>      <span class="hljs-built_in">push</span>(nums[i]);<br>      res.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">getfron</span>());<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="5-删除字符串中的所有相邻重复项"><a href="#5-删除字符串中的所有相邻重复项" class="headerlink" title="5. 删除字符串中的所有相邻重复项"></a><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/">5. 删除字符串中的所有相邻重复项</a></h4><p>难度简单345收藏分享切换为英文接收动态反馈</p><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。</p><p>在 S 上反复执行重复项删除操作，直到无法继续删除。</p><p>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。</p><p>思路： 字符串逐个入栈， 先入一个，入下一个的时候和栈顶的比较，如果相同，说明这两个是相邻且相同的，此时将 栈顶pop出去,遍历完字符后就是最后的结果了，此时还要反转字符串</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string S)</span> </span>&#123;<br>  stack&lt;<span class="hljs-type">char</span>&gt; st;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> s : S) &#123;<br>    <span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>() || s != st.<span class="hljs-built_in">top</span>()) &#123;<br>      st.<span class="hljs-built_in">push</span>(s);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">// s 与 st.top()相等的情况</span><br>    &#125;<br>  &#125;<br>  string result = <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123; <span class="hljs-comment">// 将栈中元素放到result字符串汇总</span><br>    result += st.<span class="hljs-built_in">top</span>();<br>    st.<span class="hljs-built_in">pop</span>();<br>  &#125;<br>  <span class="hljs-built_in">reverse</span>(result.<span class="hljs-built_in">begin</span>(), result.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 此时字符串需要反转一下</span><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>堆栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-树</title>
    <link href="/2022/03/07/LeetCode-%E6%A0%91/"/>
    <url>/2022/03/07/LeetCode-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h4 id="1-恢复二叉搜索树"><a href="#1-恢复二叉搜索树" class="headerlink" title="1. 恢复二叉搜索树"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/">1. 恢复二叉搜索树</a></h4><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的 <strong>恰好</strong> 两个节点的值被错误地交换。<em>请在不改变其结构的情况下，恢复这棵树</em> 。<br><img src="http://imt.rui.vin/202203181122619.png" alt="image-20220318111605261"> </p><p>思路： 二叉搜索树 中序排序是升序的，中序遍历时 记录前一个节点， 比较当前节点和上个节点，正常的树是当前节点要大于上一节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  TreeNode *t = <span class="hljs-literal">nullptr</span>;<br>  TreeNode *a = <span class="hljs-literal">nullptr</span>;<br>  TreeNode *b = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTree</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root-&gt;left != <span class="hljs-literal">nullptr</span>)<br>      <span class="hljs-built_in">backTree</span>(root-&gt;left);<br>    <span class="hljs-comment">//当前的值要大于上一个  二叉搜索数中序遍历是递增的</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">nullptr</span> &amp;&amp; t-&gt;val &gt; root-&gt;val) &#123;<br>      <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">//保存上一个节点</span><br>        a = t;<br>      &#125;<br>      b = root;  <span class="hljs-comment">//和当前的节点</span><br>    &#125;<br>    t = root;<br>    <span class="hljs-comment">// cout &lt;&lt; root-&gt;val;</span><br>    <span class="hljs-keyword">if</span> (root-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-built_in">backTree</span>(root-&gt;right);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>     <span class="hljs-built_in">backTree</span>(root); <span class="hljs-comment">//按照正常的中序遍历来处理</span><br>     <span class="hljs-built_in">swap</span>(a-&gt;val,b-&gt;val);   <span class="hljs-comment">//两个节点交换</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-树的前中后序-遍历"><a href="#2-树的前中后序-遍历" class="headerlink" title="2 .树的前中后序 遍历"></a>2 .树的前中后序 遍历</h4><p>递归排序： 相对于递归比较简单，总体公式就是</p><ol><li>确定递归的参数，返回值</li><li>递归终止的条件</li><li>递归的逻辑  （前中还是先后）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">//以下是 中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中  </span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>&#125;<br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p> 递归可以的，用迭代一般都可以都可以:<br>    使用一个栈来辅助</p><ul><li>前序遍历：  遍历第一个数进栈，然后出栈，出栈前，先看下他有无左右子树，有的话先进右节点，后进左节点，为什么呢？因为前序是先忘左边遍历的后面才往右边遍历</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; st;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        st.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">//先进栈</span><br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">//不为空</span><br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();                          <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//出栈</span><br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">//保存结果</span><br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);           <span class="hljs-comment">// 右（空节点不入栈）</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);             <span class="hljs-comment">// 左（空节点不入栈）</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>中序遍历： 对于中序，有点特殊，遍历的结果是左右都没有节点的时候才是我们想要的节点，思路还是一样先一直往左走，走一个压栈一个，遇到没有左子节点的时候，看下有无右节点，没有则出栈（左中右），看其右边有无子节点</li></ul><p>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 指针来访问节点，访问到最底层</span><br>                st.<span class="hljs-built_in">push</span>(cur); <span class="hljs-comment">// 将访问的节点放进栈</span><br>                cur = cur-&gt;left;                <span class="hljs-comment">// 左</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);     <span class="hljs-comment">// 中</span><br>                cur = cur-&gt;right;               <span class="hljs-comment">// 右</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>后序遍历： 前序遍历时是 中左右  ，当然我们也可以中右左(改变遍历顺序)，将这个结果倒序排一遍就是后序遍历了…</p><h4 id="3-二叉树的层序遍历"><a href="#3-二叉树的层序遍历" class="headerlink" title="3 .二叉树的层序遍历"></a>3 .<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></h4><p>​给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><pre><code class="hljs"> ![image-20220321120854055](http://imt.rui.vin/202203211218012.png) </code></pre><p>​思路： 会这题可以解决很多树的问题！</p><ul><li>利用队列的性质，第一次进3，出队列，然后3的左右子树依次进队，此时 队列里有9,10，让后重复出一个节点，然后该节点的左右节点分别进入，同理，10 节点也是一样</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>   vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>queue&lt;TreeNode *&gt; que;<br><span class="hljs-keyword">if</span>(root != <span class="hljs-literal">nullptr</span>)<br>    que.<span class="hljs-built_in">push</span>(root);<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>vector&lt;<span class="hljs-type">int</span>&gt; num;<br><span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">//队列不为空则说明 还没遍历完</span><br><span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//这里 记录当前要出队列的元素个数，出的时候也有进入，要先规定好出多少个</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            TreeNode* node = que.<span class="hljs-built_in">front</span>(); <br>            que.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//出一个</span><br>            num.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-comment">//出队列的左右子树入队列</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left); <br>            <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>&#125;<br>res.<span class="hljs-built_in">push_back</span>(num);<br>num.<span class="hljs-built_in">clear</span>();<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>层次遍历可以解决    二叉树的层数也是可以解决，加一个变量记录进入for的次数，而且还可以记录出最小的高度，即节点的左右子节点都为空的时候</li></ul><h4 id="4-从前序与中序遍历序列构造二叉树"><a href="#4-从前序与中序遍历序列构造二叉树" class="headerlink" title="4. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">4. 从前序与中序遍历序列构造二叉树</a></h4><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p><img src="http://imt.rui.vin/202204112356438.png" alt="image-20220411235555155"></p><p>已知前序和中序 推后序，很基础的题，但是用代码 实现就有点困难了，应该是用递归，不知怎么递归，以及边界的 处理</p><p>前序的 每个数都将中序分为两部分，通过中序左右两部分个数 又可以将前序分为两部分 </p><p><img src="http://imt.rui.vin/202204120001854.png" alt="简单的划分">·   </p><p>通过前序的值 可以找到中序的下标索引  然后 在开始划分，<strong>左子树 递归</strong>   和  <strong>右子树 递归</strong></p><p>为了方便通过前序值马上找到中序的下标，可以先用 map来索引</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; nodemap; <span class="hljs-comment">//方便找 中序下标</span><br>    <span class="hljs-comment">//每次递归 的参数包含  前序的起始坐标， 和 中序的起始坐标</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">drawback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder,<span class="hljs-type">int</span> Pleft,<span class="hljs-type">int</span> Pright,<span class="hljs-type">int</span> Ileft,<span class="hljs-type">int</span> Iright)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Pleft &gt; Pright)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> preroot = preorder[Pleft]; <span class="hljs-comment">// 每次去前序的第一个值</span><br>        <span class="hljs-type">int</span> inroot = nodemap[preroot]; <span class="hljs-comment">//通过 map 找到 中序的索引</span><br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preroot);  <span class="hljs-comment">// 当前 前序的值就头结点 </span><br><br>        <span class="hljs-type">int</span> size_left_node = inroot - Ileft;   <span class="hljs-comment">//要划分 前序 的左右部分， 通过中序可以知道前序的左部分多少个数，即可求出前序的分界值</span><br>        <span class="hljs-comment">//左子树</span><br>        root-&gt;left = <span class="hljs-built_in">drawback</span>(preorder,inorder,Pleft+<span class="hljs-number">1</span>,Pleft+size_left_node,Ileft,inroot<span class="hljs-number">-1</span>);<br><span class="hljs-comment">//右子树</span><br>        root-&gt;right = <span class="hljs-built_in">drawback</span>(preorder,inorder,Pleft+size_left_node+<span class="hljs-number">1</span>,Pright,inroot+<span class="hljs-number">1</span>,Iright);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!preorder.<span class="hljs-built_in">size</span>() || !inorder.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.<span class="hljs-built_in">size</span>();i++ )&#123;<br>            nodemap[inorder[i]] = i;<br>        &#125;<br><br>      <span class="hljs-keyword">return</span>  <span class="hljs-built_in">drawback</span>(preorder,inorder,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="5-二叉树中的最大路径和"><a href="#5-二叉树中的最大路径和" class="headerlink" title="5. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">5. 二叉树中的最大路径和</a></h4><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><p><img src="http://imt.rui.vin/202204140058877.png" alt="image-20220414005821681"></p><p>树的问题往往都是 用递归来解决，这次递归麻烦</p><p>如上图，  路径是 15 - 20 - 7  的值最大，不需要打印出路劲节点，只需求最大值，把问题细分下去  对于每一个节点都可以看做是一个根节点</p><p><img src="http://imt.rui.vin/202204140112710.png" alt="image-20220414010238591" style="zoom:33%;">对于一个小树，有几种可能呢，一种是 路劲都走完有最大值，还有一种是 三个节点中取一个节点作为最大值</p><p><img src="http://imt.rui.vin/202204140112161.png" alt="image-20220414010455332" style="zoom:33%;">同理，对于根节点为10 的树（他的全部节点 抽象成左右两个节点），同理也是有两种取法</p><p>现在 问题就可以推倒  求一个子树的最大路径值，路劲都是 左中右，中序遍历</p><p>递归的参数是 每个叶子节点</p><p>递归的出口是  叶子结点为空</p><p>递归的逻辑是 左到右</p><p>做一个全局变量，用于取最大值  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> maxsum = INT_MIN;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(TreeNode *root)</span></span>&#123;<br><span class="hljs-comment">//递归出口</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//递归左边子树 ，返回最后一左节点值</span><br>        <span class="hljs-type">int</span> lval = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getMax</span>(root-&gt;left),<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//同上</span><br>        <span class="hljs-type">int</span> rval = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getMax</span>(root-&gt;right),<span class="hljs-number">0</span>);<br>   <span class="hljs-comment">//第一种路径选择  从左到右，逐个走，用全局变量记录 </span><br>        maxsum = <span class="hljs-built_in">max</span>(root-&gt;val + lval + rval,maxsum);<br>   <span class="hljs-comment">//第二种 根节点加上 左右两个节点最大哪个</span><br>        <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">max</span>(lval,rval);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">getMax</span>(root);<br>        <span class="hljs-keyword">return</span> maxsum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-树</title>
    <link href="/2022/03/07/leetcode/LeetCode-%E6%A0%91/"/>
    <url>/2022/03/07/leetcode/LeetCode-%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h4 id="1-恢复二叉搜索树"><a href="#1-恢复二叉搜索树" class="headerlink" title="1. 恢复二叉搜索树"></a><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/">1. 恢复二叉搜索树</a></h4><p>给你二叉搜索树的根节点 <code>root</code> ，该树中的 <strong>恰好</strong> 两个节点的值被错误地交换。<em>请在不改变其结构的情况下，恢复这棵树</em> 。<br><img src="http://imt.rui.vin/202203181122619.png" alt="image-20220318111605261"> </p><p>思路： 二叉搜索树 中序排序是升序的，中序遍历时 记录前一个节点， 比较当前节点和上个节点，正常的树是当前节点要大于上一节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  TreeNode *t = <span class="hljs-literal">nullptr</span>;<br>  TreeNode *a = <span class="hljs-literal">nullptr</span>;<br>  TreeNode *b = <span class="hljs-literal">nullptr</span>;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">backTree</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root-&gt;left != <span class="hljs-literal">nullptr</span>)<br>      <span class="hljs-built_in">backTree</span>(root-&gt;left);<br>    <span class="hljs-comment">//当前的值要大于上一个  二叉搜索数中序遍历是递增的</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">nullptr</span> &amp;&amp; t-&gt;val &gt; root-&gt;val) &#123;<br>      <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">nullptr</span>) &#123; <span class="hljs-comment">//保存上一个节点</span><br>        a = t;<br>      &#125;<br>      b = root;  <span class="hljs-comment">//和当前的节点</span><br>    &#125;<br>    t = root;<br>    <span class="hljs-comment">// cout &lt;&lt; root-&gt;val;</span><br>    <span class="hljs-keyword">if</span> (root-&gt;right != <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-built_in">backTree</span>(root-&gt;right);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">recoverTree</span><span class="hljs-params">(TreeNode *root)</span> </span>&#123;<br>     <span class="hljs-built_in">backTree</span>(root); <span class="hljs-comment">//按照正常的中序遍历来处理</span><br>     <span class="hljs-built_in">swap</span>(a-&gt;val,b-&gt;val);   <span class="hljs-comment">//两个节点交换</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-树的前中后序-遍历"><a href="#2-树的前中后序-遍历" class="headerlink" title="2 .树的前中后序 遍历"></a>2 .树的前中后序 遍历</h4><p>递归排序： 相对于递归比较简单，总体公式就是</p><ol><li>确定递归的参数，返回值</li><li>递归终止的条件</li><li>递归的逻辑  （前中还是先后）</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-comment">//以下是 中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中  </span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>&#125;<br><span class="hljs-comment">//后序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec);  <span class="hljs-comment">// 左</span><br>    <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <span class="hljs-comment">// 右</span><br>    vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);    <span class="hljs-comment">// 中</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p> 递归可以的，用迭代一般都可以都可以:<br>    使用一个栈来辅助</p><ul><li>前序遍历：  遍历第一个数进栈，然后出栈，出栈前，先看下他有无左右子树，有的话先进右节点，后进左节点，为什么呢？因为前序是先忘左边遍历的后面才往右边遍历</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; st;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> result;<br>        st.<span class="hljs-built_in">push</span>(root); <span class="hljs-comment">//先进栈</span><br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">//不为空</span><br>            TreeNode* node = st.<span class="hljs-built_in">top</span>();                          <span class="hljs-comment">// 中</span><br>            st.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//出栈</span><br>            result.<span class="hljs-built_in">push_back</span>(node-&gt;val); <span class="hljs-comment">//保存结果</span><br>            <span class="hljs-keyword">if</span> (node-&gt;right) st.<span class="hljs-built_in">push</span>(node-&gt;right);           <span class="hljs-comment">// 右（空节点不入栈）</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) st.<span class="hljs-built_in">push</span>(node-&gt;left);             <span class="hljs-comment">// 左（空节点不入栈）</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>中序遍历： 对于中序，有点特殊，遍历的结果是左右都没有节点的时候才是我们想要的节点，思路还是一样先一直往左走，走一个压栈一个，遇到没有左子节点的时候，看下有无右节点，没有则出栈（左中右），看其右边有无子节点</li></ul><p>​</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        stack&lt;TreeNode*&gt; st;<br>        TreeNode* cur = root;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">NULL</span> || !st.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (cur != <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 指针来访问节点，访问到最底层</span><br>                st.<span class="hljs-built_in">push</span>(cur); <span class="hljs-comment">// 将访问的节点放进栈</span><br>                cur = cur-&gt;left;                <span class="hljs-comment">// 左</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                cur = st.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// 从栈里弹出的数据，就是要处理的数据（放进result数组里的数据）</span><br>                st.<span class="hljs-built_in">pop</span>();<br>                result.<span class="hljs-built_in">push_back</span>(cur-&gt;val);     <span class="hljs-comment">// 中</span><br>                cur = cur-&gt;right;               <span class="hljs-comment">// 右</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>后序遍历： 前序遍历时是 中左右  ，当然我们也可以中右左(改变遍历顺序)，将这个结果倒序排一遍就是后序遍历了…</p><h4 id="3-二叉树的层序遍历"><a href="#3-二叉树的层序遍历" class="headerlink" title="3 .二叉树的层序遍历"></a>3 .<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">二叉树的层序遍历</a></h4><p>​给你二叉树的根节点 <code>root</code> ，返回其节点值的 <strong>层序遍历</strong> 。 （即逐层地，从左到右访问所有节点）。</p><pre><code class="hljs"> ![image-20220321120854055](http://imt.rui.vin/202203211218012.png) </code></pre><p>​思路： 会这题可以解决很多树的问题！</p><ul><li>利用队列的性质，第一次进3，出队列，然后3的左右子树依次进队，此时 队列里有9,10，让后重复出一个节点，然后该节点的左右节点分别进入，同理，10 节点也是一样</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>   vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>queue&lt;TreeNode *&gt; que;<br><span class="hljs-keyword">if</span>(root != <span class="hljs-literal">nullptr</span>)<br>    que.<span class="hljs-built_in">push</span>(root);<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>vector&lt;<span class="hljs-type">int</span>&gt; num;<br><span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>()) &#123;  <span class="hljs-comment">//队列不为空则说明 还没遍历完</span><br><span class="hljs-type">int</span> size = que.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">//这里 记录当前要出队列的元素个数，出的时候也有进入，要先规定好出多少个</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            TreeNode* node = que.<span class="hljs-built_in">front</span>(); <br>            que.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//出一个</span><br>            num.<span class="hljs-built_in">push_back</span>(node-&gt;val);<br>            <span class="hljs-comment">//出队列的左右子树入队列</span><br>            <span class="hljs-keyword">if</span> (node-&gt;left) que.<span class="hljs-built_in">push</span>(node-&gt;left); <br>            <span class="hljs-keyword">if</span> (node-&gt;right) que.<span class="hljs-built_in">push</span>(node-&gt;right);<br>&#125;<br>res.<span class="hljs-built_in">push_back</span>(num);<br>num.<span class="hljs-built_in">clear</span>();<br>&#125;<br><span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>层次遍历可以解决    二叉树的层数也是可以解决，加一个变量记录进入for的次数，而且还可以记录出最小的高度，即节点的左右子节点都为空的时候</li></ul><h4 id="4-从前序与中序遍历序列构造二叉树"><a href="#4-从前序与中序遍历序列构造二叉树" class="headerlink" title="4. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">4. 从前序与中序遍历序列构造二叉树</a></h4><p>给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。</p><p><img src="http://imt.rui.vin/202204112356438.png" alt="image-20220411235555155"></p><p>已知前序和中序 推后序，很基础的题，但是用代码 实现就有点困难了，应该是用递归，不知怎么递归，以及边界的 处理</p><p>前序的 每个数都将中序分为两部分，通过中序左右两部分个数 又可以将前序分为两部分 </p><p><img src="http://imt.rui.vin/202204120001854.png" alt="简单的划分">·   </p><p>通过前序的值 可以找到中序的下标索引  然后 在开始划分，<strong>左子树 递归</strong>   和  <strong>右子树 递归</strong></p><p>为了方便通过前序值马上找到中序的下标，可以先用 map来索引</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; nodemap; <span class="hljs-comment">//方便找 中序下标</span><br>    <span class="hljs-comment">//每次递归 的参数包含  前序的起始坐标， 和 中序的起始坐标</span><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">drawback</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder,<span class="hljs-type">int</span> Pleft,<span class="hljs-type">int</span> Pright,<span class="hljs-type">int</span> Ileft,<span class="hljs-type">int</span> Iright)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(Pleft &gt; Pright)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-type">int</span> preroot = preorder[Pleft]; <span class="hljs-comment">// 每次去前序的第一个值</span><br>        <span class="hljs-type">int</span> inroot = nodemap[preroot]; <span class="hljs-comment">//通过 map 找到 中序的索引</span><br>        TreeNode *root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preroot);  <span class="hljs-comment">// 当前 前序的值就头结点 </span><br><br>        <span class="hljs-type">int</span> size_left_node = inroot - Ileft;   <span class="hljs-comment">//要划分 前序 的左右部分， 通过中序可以知道前序的左部分多少个数，即可求出前序的分界值</span><br>        <span class="hljs-comment">//左子树</span><br>        root-&gt;left = <span class="hljs-built_in">drawback</span>(preorder,inorder,Pleft+<span class="hljs-number">1</span>,Pleft+size_left_node,Ileft,inroot<span class="hljs-number">-1</span>);<br><span class="hljs-comment">//右子树</span><br>        root-&gt;right = <span class="hljs-built_in">drawback</span>(preorder,inorder,Pleft+size_left_node+<span class="hljs-number">1</span>,Pright,inroot+<span class="hljs-number">1</span>,Iright);<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-type">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!preorder.<span class="hljs-built_in">size</span>() || !inorder.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.<span class="hljs-built_in">size</span>();i++ )&#123;<br>            nodemap[inorder[i]] = i;<br>        &#125;<br><br>      <span class="hljs-keyword">return</span>  <span class="hljs-built_in">drawback</span>(preorder,inorder,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,inorder.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="5-二叉树中的最大路径和"><a href="#5-二叉树中的最大路径和" class="headerlink" title="5. 二叉树中的最大路径和"></a><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">5. 二叉树中的最大路径和</a></h4><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><p><img src="http://imt.rui.vin/202204140058877.png" alt="image-20220414005821681"></p><p>树的问题往往都是 用递归来解决，这次递归麻烦</p><p>如上图，  路径是 15 - 20 - 7  的值最大，不需要打印出路劲节点，只需求最大值，把问题细分下去  对于每一个节点都可以看做是一个根节点</p><p><img src="http://imt.rui.vin/202204140112710.png" alt="image-20220414010238591" style="zoom:33%;">对于一个小树，有几种可能呢，一种是 路劲都走完有最大值，还有一种是 三个节点中取一个节点作为最大值</p><p><img src="http://imt.rui.vin/202204140112161.png" alt="image-20220414010455332" style="zoom:33%;">同理，对于根节点为10 的树（他的全部节点 抽象成左右两个节点），同理也是有两种取法</p><p>现在 问题就可以推倒  求一个子树的最大路径值，路劲都是 左中右，中序遍历</p><p>递归的参数是 每个叶子节点</p><p>递归的出口是  叶子结点为空</p><p>递归的逻辑是 左到右</p><p>做一个全局变量，用于取最大值  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> maxsum = INT_MIN;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(TreeNode *root)</span></span>&#123;<br><span class="hljs-comment">//递归出口</span><br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-comment">//递归左边子树 ，返回最后一左节点值</span><br>        <span class="hljs-type">int</span> lval = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getMax</span>(root-&gt;left),<span class="hljs-number">0</span>);<br>        <span class="hljs-comment">//同上</span><br>        <span class="hljs-type">int</span> rval = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">getMax</span>(root-&gt;right),<span class="hljs-number">0</span>);<br>   <span class="hljs-comment">//第一种路径选择  从左到右，逐个走，用全局变量记录 </span><br>        maxsum = <span class="hljs-built_in">max</span>(root-&gt;val + lval + rval,maxsum);<br>   <span class="hljs-comment">//第二种 根节点加上 左右两个节点最大哪个</span><br>        <span class="hljs-keyword">return</span> root-&gt;val + <span class="hljs-built_in">max</span>(lval,rval);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-built_in">getMax</span>(root);<br>        <span class="hljs-keyword">return</span> maxsum;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-双指针问题</title>
    <link href="/2022/03/06/leetcode/LeetCode-%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/06/leetcode/LeetCode-%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="1-移除元素"><a href="#1-移除元素" class="headerlink" title="1 移除元素"></a>1 移除元素</h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p> <span id="more"></span><p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p>思路一： </p><p>​找到一个元素删掉，把后面的往前推，复杂度太多 O(n^2)</p><p>思路二：</p><p>​双指针法   ： 也是需要找个每个元素，然后把后一个元素上去，使用快慢指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement1</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>    <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> fast;<br>    <span class="hljs-keyword">for</span> (fast = <span class="hljs-number">0</span>; fast &lt; nums.<span class="hljs-built_in">size</span>(); fast++) &#123;  <span class="hljs-comment">//fast 遍历数组</span><br>      <span class="hljs-keyword">if</span> (nums[fast] != val) &#123;    <span class="hljs-comment">//如果 这个值不等于 val  </span><br>        nums[slow++] = nums[fast];  <span class="hljs-comment">// fast 覆盖 slow  ，注意 如果没找到 slow 和 fast是相等的 </span><br>           <span class="hljs-comment">// 如果找到了， 跳过if   slow 没增加， fast+1 ，</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;  <span class="hljs-comment">//最后slow指针指向</span><br>  &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-移除元素-（升序）"><a href="#2-移除元素-（升序）" class="headerlink" title="2 移除元素 （升序）"></a>2 移除元素 （升序）</h3><p>给你一个 <strong>升序排列</strong> 的数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。</p><p>依然采用双指针的方法，快指针遍历数组全部数据，慢指针停留在下一个不同元素的位置，为快指针覆盖表明位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span>(nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>   <span class="hljs-keyword">return</span>* <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> slow = <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> fast;<br>  <span class="hljs-keyword">for</span>(fast = <span class="hljs-number">0</span>; fast &lt; nums.<span class="hljs-built_in">size</span>(); fast++) &#123;<br>   <span class="hljs-keyword">if</span> (nums[slow] != nums[fast]) &#123;<br>    nums[++slow] = nums[fast];  <span class="hljs-comment">//如果相等</span><br>   &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> slow+<span class="hljs-number">1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="3-有序数组的平方"><a href="#3-有序数组的平方" class="headerlink" title="3.有序数组的平方"></a>3.有序数组的平方</h3><p>#给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1： 输入：nums &#x3D; [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p><p>示例 2： 输入：nums &#x3D; [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p><p>思路：<strong>很典型 的 双指针解法</strong>，两个指针分别指向首尾，平方后相比较，大的指针不动，小的移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;nums[<span class="hljs-number">0</span>] * nums[<span class="hljs-number">0</span>]&#125;;<br>  &#125;<br>  <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; <br>  <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>  vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-keyword">if</span> (nums[right] * nums[right] &gt;= nums[left] * nums[left]) &#123;  <span class="hljs-comment">//前后数值结果 比较，如果大取出来，移动指针  </span><br>      ret.<span class="hljs-built_in">push_back</span>(nums[right] * nums[right]);<br>      right--;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ret.<span class="hljs-built_in">push_back</span>(nums[left] * nums[left]); <span class="hljs-comment">//同理</span><br>      left++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-替换空格"><a href="#4-替换空格" class="headerlink" title="4.替换空格"></a>4.<a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">替换空格</a></h3><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p><p>思路：找出有多少个空格，然后扩容， 一个指针指向原来的末端，新的指针指向新的末端，将字符移动到最后端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s) &#123;<br>      <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27; &#x27;</span>) count++;<br>    &#125;<br>    <span class="hljs-type">int</span> oldsize = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> s;<br>    s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>() + count * <span class="hljs-number">2</span>);<br>    <span class="hljs-type">int</span> newsize = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = newsize - <span class="hljs-number">1</span>, j = oldsize - <span class="hljs-number">1</span>; j &lt; i; i--, j--) &#123;<br>      <span class="hljs-keyword">if</span> (s[j] != <span class="hljs-string">&#x27; &#x27;</span>)<br>        <span class="hljs-built_in">swap</span>(s[j], s[i]);<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[j] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>        s[i--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>        s[i--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>        s[i] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="5-无重复字符的最长子串"><a href="#5-无重复字符的最长子串" class="headerlink" title="5. 无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">5. 无重复字符的最长子串</a></h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p>思路： 模拟一个滑动窗口，窗口右边界一直向右探索，知道探索的下一个字符，在窗口中已存在，若已存在则左边界收缩，现在问题是如何快速确定字符在窗口中已存在，可以利用 有hash特性的 unorderset ，快速查找字符是否存在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>   unordered_set&lt;<span class="hljs-type">char</span>&gt; win; <span class="hljs-comment">//建立一个集合</span><br>   <span class="hljs-type">int</span> right = <span class="hljs-number">-1</span>;         <span class="hljs-comment">//初始右边界</span><br>   <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>       <span class="hljs-comment">//第一次走到这不用剔除，接下来每一次走到这都说明遇到了相同的字符</span><br>       <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;<br>        win.<span class="hljs-built_in">erase</span>(s[i - <span class="hljs-number">1</span>]); <span class="hljs-comment">//剔除窗口 的值</span><br>    &#125;<br><span class="hljs-comment">// 不断 扩展右边界 先试探下一个是否存在，所以right 初始化为-1</span><br>   <span class="hljs-keyword">while</span> (right + <span class="hljs-number">1</span> &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; !win.<span class="hljs-built_in">count</span>(s[right + <span class="hljs-number">1</span>])) &#123;<br>     win.<span class="hljs-built_in">insert</span>(s[right + <span class="hljs-number">1</span>]);<br>     right++;  <br>   &#125;<br>   <span class="hljs-comment">//通过下标推出长度</span><br>   ans = <span class="hljs-built_in">max</span>(ans, right - i + <span class="hljs-number">1</span>);<br> &#125;<br> <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针 滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux socket 网络编程简单步骤（）</title>
    <link href="/2022/03/05/Linux%20socket%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/03/05/Linux%20socket%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>socket是什么？</p><h3 id="Linux下tcp服务器创建的步骤"><a href="#Linux下tcp服务器创建的步骤" class="headerlink" title="Linux下tcp服务器创建的步骤"></a>Linux下tcp服务器创建的步骤</h3><span id="more"></span><p>对应TCP：</p><ul><li><p>服务端</p><p>  socket()  建立套接字返回一个文件描述符  fd<br>  bind()   将fd 和 服务器信息（五元组）绑定在一起<br>  listen()  设置连接到服务端的最大连接数<br>  accep()  等待客户端 的连接，连接成功返回一个 fd （一个客户端一个fd）<br>  最后就是对这个fd 读写操作了，操作完需要 close(fd)  文件描述符是有限的</p></li><li><p>客户端</p><p>  socket()  建立套接字返回一个文件描述符 fd<br>  connect( )  连接成功返回一个 fd<br>  最后就是对这个fd 读写操作了，操作完需要 close(fd)  文件描述符是有限的</p></li></ul><p>简单的代码实现：</p><p>第一版：  服务器可以收到客户端的数据并有的回应</p><p>带填坑。。。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-哈希问题</title>
    <link href="/2022/03/02/leetcode/LeetCode-%E5%93%88%E5%B8%8C%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/02/leetcode/LeetCode-%E5%93%88%E5%B8%8C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>这里先填个坑 ： set  map 容器底层的原理 </p><h4 id="1-有效的字母异位词"><a href="#1-有效的字母异位词" class="headerlink" title="1. 有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/">1. 有效的字母异位词</a></h4><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p>注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。</p><ul><li><code>s</code> 和 <code>t</code> 仅包含小写字母</li></ul><p>思路： 统计s中字符出现的次数，然后再统计 t 中字符出现的次数看是否匹配 ，s和 t 仅仅包含小写字母，所以一小写字母作为key值，出现次数作为 value，出现过的value肯定大于0；再次统计t的，t中出现过的字符对value减一，如果两个字符串出现次数样的话，则map中任何一个value都应为0才对；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">isAnagram</span><span class="hljs-params">(<span class="hljs-built_in">string</span> s, <span class="hljs-built_in">string</span> t)</span> &#123;<br>    <span class="hljs-type">int</span> strmap[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;  <span class="hljs-comment">//这里我用了一个数组来模拟map</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s) &#123;<br>      strmap[ch - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : t) &#123;<br>      strmap[ch - <span class="hljs-string">&#x27;a&#x27;</span>]--;<br>    &#125;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">25</span>; i++) &#123;<br>      <span class="hljs-keyword">if</span> (strmap[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="2-两个数组的交集"><a href="#2-两个数组的交集" class="headerlink" title="2. 两个数组的交集"></a>2.<a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/"> 两个数组的交集</a></h4><p>如题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums1, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums2)</span> </span>&#123;<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; num;<br>    unordered_set&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">if</span> (nums1.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span> || nums2.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n:nums1)&#123;<br>      num.<span class="hljs-built_in">insert</span>(n);<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> n:nums2)&#123;<br>      <span class="hljs-keyword">if</span>(num.<span class="hljs-built_in">find</span>(n) != num.<span class="hljs-built_in">end</span>())&#123;<br>        res.<span class="hljs-built_in">insert</span>(n);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>  &#125;<br></code></pre></td></tr></table></figure><h4 id="3-两数之和"><a href="#3-两数之和" class="headerlink" title="3 .两数之和"></a>3 .两数之和</h4><p>  给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p>思路： 遍历数组 ，查找 target-nums[i] 值有无在数组中（因为数组元素是唯一的），在数组中查找有无匹配的可以使用map</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>  unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; numsmap;   <br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;  <br>    <span class="hljs-keyword">auto</span> iter = numsmap.<span class="hljs-built_in">find</span>(target-nums[i]);   <span class="hljs-comment">//要查找的目标</span><br>    <span class="hljs-keyword">if</span>(iter == numsmap.<span class="hljs-built_in">end</span>())&#123; <span class="hljs-comment">//没有在map中找到</span><br>      numsmap.<span class="hljs-built_in">insert</span>(nums[i],i);  <span class="hljs-comment">//则向map中插入元素</span><br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>      <span class="hljs-keyword">return</span> &#123;iter-&gt;second,i&#125;;   <span class="hljs-comment">//找到了 则返回坐标</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-三数之和"><a href="#3-三数之和" class="headerlink" title="3 .三数之和"></a>3 .<a href="https://leetcode-cn.com/problems/3sum/">三数之和</a></h4><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><p>思路： 排序 +  双指针       三数之和为 0  ，遍历每一个数，从剩下的数找到符合条件的两位数 ， 题目要求需要去重</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">threeSum</span>(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums) &#123;<br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; res;<br>  <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>   <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">//排序</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123; <span class="hljs-comment">//遍历数组每个元素</span><br>    <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">//因为排序是升序   所以当前数大于0 了，剩下的数也不符合条件了</span><br>      <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) &#123;  <span class="hljs-comment">//去重 不是第一元素的时候， 看当前的数和前一个数是相同</span><br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    <span class="hljs-comment">// 现在已经用了一个数，接下要找到剩下的两位数， 从头和尾各自开始找</span><br>    left = i + <span class="hljs-number">1</span>;   <br>    right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (right &gt; left) &#123;<br>       <span class="hljs-comment">//找头和尾的数 看大了还是小了，大了尾往左缩，小了往右缩</span><br>      <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">//符合条件 则加入res中</span><br>          <br>        res.<span class="hljs-built_in">push_back</span>(vector&lt;<span class="hljs-type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);<br>        <span class="hljs-comment">//此时还去重，如果说两个指针缩短了后，下个数还是一样的，那会有重复的结果</span><br>        <span class="hljs-comment">//首尾都需要去重</span><br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) &#123;<br>          right--;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) &#123;<br>          left++;<br>        &#125;<br>        right--;<br>        left++; <br>      &#125;<br>      <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) &#123;<br>        right--;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &lt; <span class="hljs-number">0</span>) &#123;<br>        left++;<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-四数之和"><a href="#3-四数之和" class="headerlink" title="3 .四数之和"></a>3 .四数之和</h4>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-链表问题</title>
    <link href="/2022/02/26/leetcode/LeetCode-%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/26/leetcode/LeetCode-%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p> <img src="http://imt.rui.vin/202202271318039.png" alt="image-20220227131753050"></p><span id="more"></span><h2 id="1-移除链表元素"><a href="#1-移除链表元素" class="headerlink" title="1.移除链表元素"></a>1.<a href="https://leetcode-cn.com/problems/remove-linked-list-elements/">移除链表元素</a></h2><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><p>  这次删除的是链表，链表删除元素比较方便，但要注意元素边界</p><p>思路： 先提出剔除 链表前部分符合条件元素，找真正的起点<br>            从起点开开始遍历，查看下一个元素是否符合，符合跳过，更改指针方向</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode *<span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode *head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>   <span class="hljs-keyword">while</span> (head-&gt;next != <span class="hljs-literal">nullptr</span> &amp;&amp; head-&gt;val == val) &#123;  <span class="hljs-comment">//看前部分是否符合条件</span><br>     head = head-&gt;next;<br>   &#125;<br>   ListNode *cur = head;  <span class="hljs-comment">//真正的head， 用cur去操作，head是我们要的结果</span><br>   <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">nullptr</span> &amp;&amp; head-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>     <span class="hljs-keyword">if</span> (cur-&gt;next-&gt;val == val) &#123;    <span class="hljs-comment">//如果符合 跳过指向下下个</span><br>       cur-&gt;next = cur-&gt;next-&gt;next;  <br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       cur = cur-&gt;next;   <span class="hljs-comment">//不符合，直接下一个i</span><br>     &#125;<br>  <span class="hljs-keyword">return</span> head;  <span class="hljs-comment">//返回的是head，cur 是用来操作链表的</span><br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h2 id="2-反转链表"><a href="#2-反转链表" class="headerlink" title="2. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">2. 反转链表</a></h2><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表   (经典题目了)</p><p>思路1： 建一个虚拟的头节点，然后遍历链表，改变元素指针指向（指向虚拟节点）</p><p>思路2： 用栈的特性，遍历链表入栈，出栈一个一个链接起来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode *<span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>ListNode * vhead = <span class="hljs-literal">nullptr</span>;<br>ListNode *cur = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">while</span> (head != <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">//遍历链表</span><br>&#123;<br>cur = head;        <span class="hljs-comment">//cur 指向当前元素</span><br>head = head -&gt;next; <span class="hljs-comment">// head 指向下一个元素，为下一次遍历做准备</span><br>cur-&gt;next = vhead; <span class="hljs-comment">// 当前元素指向虚拟节点</span><br>vhead = cur;       <span class="hljs-comment">//更新虚拟节点的位置，保证下次 元素指向的还是头节点</span><br>&#125;<br><span class="hljs-keyword">return</span> vhead;    <span class="hljs-comment">// 遍历结束  最后 执行代码是  vhead = cur; 所以vhead执行最后一个也是反转后第一个</span><br> &#125;<br></code></pre></td></tr></table></figure><h2 id="3-两两交换链表中的节点"><a href="#3-两两交换链表中的节点" class="headerlink" title="3. 两两交换链表中的节点"></a><strong><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">3. 两两交换链表中的节点</a></strong></h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><p> 思路： 因为两两交换，所以每次都选两个节点，开始的时候用一个虚拟的节点作为头结点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    ListNode *dyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>); <br>    dyHead-&gt;next = head;<br>    ListNode *cur = dyHead; <span class="hljs-comment">//到了这里  cur和dyhead控制着的相同的节点，并且该节点指向链表头部</span><br>    <span class="hljs-comment">// 下个节点和 下下个节点是否存在</span><br>    <span class="hljs-keyword">while</span> (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;next) &#123;  <br>      ListNode *t1 = cur-&gt;next;  <span class="hljs-comment">//下个节点   t1 对应 a </span><br>      ListNode *t2 =cur-&gt;next-&gt;next; <span class="hljs-comment">//下下个节点   t2 对应 b</span><br>      <span class="hljs-comment">//改变节点指向 如下图所示 </span><br>      t1-&gt;next = t2-&gt;next;  <span class="hljs-comment">//3   </span><br>      t2-&gt;next = t1;   <span class="hljs-comment">// 2</span><br>      cur-&gt;next= t2;   <span class="hljs-comment">// 1</span><br>      cur = cur-&gt;next-&gt;next;  <span class="hljs-comment">//为下次交换节点做为准备</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> dyHead-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><img src="http://imt.rui.vin/202202281532419.png" alt="image-20220228153050186" style="zoom:67%;"><h2 id="4-链表相交"><a href="#4-链表相交" class="headerlink" title="4.链表相交 "></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/">4.链表相交 </a></h2><p>给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。</p><p>图示两个链表在节点 c1 开始相交：</p><p><img src="http://imt.rui.vin/202203011232466.png" alt="img"></p><p>思路： A 和 B 都同时走</p><p>​若相交，链表A： a+c, 链表B : b+c<br>​a+c+b+c &#x3D; b+c+a+c 。则会在公共处c起点相遇。<br>​若不相交，a+b &#x3D; b+a 。因此相遇处是NULL      </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>ListNode *fast = headA;<br>ListNode *slow = headB;<br><span class="hljs-keyword">while</span> (fast != slow) &#123;<br>  fast = (fast != <span class="hljs-literal">nullptr</span> ? fast-&gt;next : headB);<br>  slow = (slow != <span class="hljs-literal">nullptr</span> ? slow-&gt;next : headA);<br>&#125;<br><span class="hljs-keyword">return</span> fast;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-反转链表-II"><a href="#5-反转链表-II" class="headerlink" title="5. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">5. 反转链表 II</a></h2><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p><p><img src="http://imt.rui.vin/202203261516515.jpeg" alt="img"> </p><p>反转链表升级版</p><p>思路： 遍历链表到到 left的位置 以left 上一个节点为头结点，接下来遍历节点，以头插法的方式插入头结点上（此时问题 又转换到而来 反转链表 I 的问题，不同的是并不是遍历到尾）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-function">ListNode *<span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode *head, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(head-&gt;next == <span class="hljs-literal">nullptr</span>)<br>        <span class="hljs-keyword">return</span> head;<br>    ListNode *vHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>    vHead -&gt;next = head;<br>    ListNode *p  = vHead;<br>    ListNode *q  = vHead-&gt;next;<br> <span class="hljs-comment">//第一次for 循环走到 定位到 left 的位置，p和q</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; left<span class="hljs-number">-1</span>; i++) &#123;<br>      p = p-&gt;next;<br>      q = q-&gt;next;<br>    &#125;<br><span class="hljs-comment">//  第二次 for 开始反转需要的节点     </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; right - left; i++) &#123;<br>      <span class="hljs-comment">//保留下一个节点</span><br>      ListNode *temp = q-&gt;next;<br>      <span class="hljs-comment">// 为下一个反转做好准备</span><br>      q-&gt;next = q-&gt;next-&gt;next;<br>     <span class="hljs-comment">//  头插法，查到  p 的后面</span><br>      temp-&gt;next = p-&gt;next;<br>      <span class="hljs-comment">// 更新 p的位置 ，为 p做好准备</span><br>      p-&gt;next = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> vHead-&gt;next;<br>  &#125;<br></code></pre></td></tr></table></figure><p><img src="http://imt.rui.vin/202203261522218.png" alt="image-20220326152225259"> </p><h2 id="K-个一组翻转链表"><a href="#K-个一组翻转链表" class="headerlink" title="K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></h2><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p><img src="/C:/Users/hrp/AppData/Roaming/Typora/typora-user-images/image-20220407144530921.png" alt="image-20220407144530921"></p><p>思路： 每k个节点反转， 可以把问题拆分到  每组 k个节点的反转，最后将每组拼接起来，对于反转 一个链表比较容易，这次反转有指定得的范围，k个几点</p><p>​利用递归可以将每组拼接起来</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//反转 k个节点的链表</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head,ListNode* tail)</span> </span>&#123;<br>     ListNode *vhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>     ListNode *v = vhead-&gt;next;<br>     <span class="hljs-keyword">while</span>(head != tail)&#123;<br>        ListNode *t = head-&gt;next;<br>        head-&gt;next = v;<br>        v = head;<br>        head = t; <br>     &#125;<br>     <span class="hljs-keyword">return</span> v;<br>    &#125;<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        ListNode *node = head;<br>        <span class="hljs-comment">//遍历k个节点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; k; i++)&#123;<br>            <span class="hljs-keyword">if</span>(node == <span class="hljs-literal">nullptr</span>)<br>                <span class="hljs-keyword">return</span> head;<br>            node = node-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">//  传入首尾节点</span><br>        ListNode *res = <span class="hljs-built_in">reverseList</span>(head,node);<br>        <span class="hljs-comment">//  递归  此时head已经是尾节点</span><br>        head-&gt;next =<span class="hljs-built_in">reverseKGroup</span>(node,k);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode-滑动窗口</title>
    <link href="/2022/02/16/leetcode/Leetcode-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    <url>/2022/02/16/leetcode/Leetcode-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="1-给定一个含有-n-个正整数的数组和一个正整数-target-。"><a href="#1-给定一个含有-n-个正整数的数组和一个正整数-target-。" class="headerlink" title="1 .给定一个含有 n 个正整数的数组和一个正整数 target 。"></a>1 .给定一个含有 n 个正整数的数组和一个正整数 target 。</h3><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>最小的 连续子数组 : eg , [1,2,3,4,4]    连续数组   [1,2]   [2,3,4];    但是  [1,4,4] ， 下标连续</p><span id="more"></span><p>还是需要双指针，构成滑动窗口，用这窗口遍历全部数据 ，窗口结合条件是可变的，窗口大小则是我们呢的答案<br>滑动窗口： 窗口起点终点，和控制窗口大小的条件（本题约束窗口大小的条件是 窗口内的值总和应大于target，如果小往右扩大窗口，大了左边缩小窗口）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] == target ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ret = len;<br>    <span class="hljs-keyword">while</span> (right &lt; len) &#123;<br>      sum = sum + nums[right];<br>      <span class="hljs-keyword">while</span> (sum &gt;= target) &#123;  <span class="hljs-comment">//窗口内的总和符合条件，则左边收缩</span><br>        ret = <span class="hljs-built_in">min</span>(ret, right - left + <span class="hljs-number">1</span>);<br>        sum = sum - nums[left];<br>        left++;<br>      &#125;<br>      right++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ret==INT_MAX?<span class="hljs-number">0</span>:ret;<br>  &#125;<br></code></pre></td></tr></table></figure><p>2 . 摘水果问题 （其实套了一层皮：  窗口内只能存在两种数字，窗口最大值）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">totalFruit</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;tree)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 水果编号到数量的映射</span><br>    unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; veg2cnt;<br>    <span class="hljs-type">int</span> n = tree.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 窗口左边界</span><br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 窗口右边界</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>      ++veg2cnt[tree[i]];<br>      <span class="hljs-comment">// 一旦发现超过大小，则不断收缩窗口</span><br>      <span class="hljs-keyword">while</span> (veg2cnt.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-type">int</span> currTree = tree[l];<br>        --veg2cnt[currTree];<br>        <span class="hljs-keyword">if</span> (veg2cnt[currTree] == <span class="hljs-number">0</span>) &#123;<br>          veg2cnt.<span class="hljs-built_in">erase</span>(currTree);<br>        &#125;<br>        ++l;<br>      &#125;<br>      <span class="hljs-comment">// 记录最大的窗口大小</span><br>      res = <span class="hljs-built_in">max</span>(res, i - l + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-有序数组的平方</title>
    <link href="/2022/02/15/leetcode/LeetCode-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"/>
    <url>/2022/02/15/leetcode/LeetCode-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="1-有序数组的平方"><a href="#1-有序数组的平方" class="headerlink" title="1.有序数组的平方"></a>1.有序数组的平方</h2><p>#给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1： 输入：nums &#x3D; [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p><p>示例 2： 输入：nums &#x3D; [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p><p>思路：<strong>很典型 的 双指针解法</strong>，两个指针分别指向首尾，平方后相比较，大的指针不动，小的移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;nums)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;nums[<span class="hljs-number">0</span>] * nums[<span class="hljs-number">0</span>]&#125;;<br>  &#125;<br>  <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>; <br>  <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>  vector&lt;<span class="hljs-type">int</span>&gt; ret;<br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    <span class="hljs-keyword">if</span> (nums[right] * nums[right] &gt;= nums[left] * nums[left]) &#123;  <span class="hljs-comment">//前后数值结果 比较，如果大取出来，移动指针  </span><br>      ret.<span class="hljs-built_in">push_back</span>(nums[right] * nums[right]);<br>      right--;<br><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      ret.<span class="hljs-built_in">push_back</span>(nums[left] * nums[left]); <span class="hljs-comment">//同理</span><br>      left++;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 刷题</title>
    <link href="/2022/02/13/leetcode/LeetCode%20%E5%88%B7%E9%A2%98/"/>
    <url>/2022/02/13/leetcode/LeetCode%20%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-刷题"><a href="#LeetCode-刷题" class="headerlink" title="LeetCode 刷题"></a>LeetCode 刷题</h1><p>（以前刷的）</p> <span id="more"></span><h3 id="1-链表反转"><a href="#1-链表反转" class="headerlink" title="1.链表反转"></a>1.链表反转</h3><ul><li>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</li></ul><p>​<strong>示例:</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br></code></pre></td></tr></table></figure><p><strong>限制：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">0 &lt;= 节点个数 &lt;= 5000<br></code></pre></td></tr></table></figure><p>解法一  暴力：</p><p>​遍历链表的每个节点，每遍历个节点就用头插法插入一个新的链表里</p><p>​时间复杂度为 T(n^2)   空间复杂度为O(n)</p><p>解法二：  迭代</p><p>​不生成新的链表，把链表的指向的方向反过来</p><p>假设链表为 1 -&gt;2  -&gt; 3 -&gt;∅     1→2→3→∅，我们想要把它改成  ∅←1←2←3。</p><p>在遍历链表时，将当前节点的指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p><p><img src="/C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1621751662409.png" alt="1621751662409"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>    ListNode* cur = head;<br>        <span class="hljs-keyword">while</span> (cur)<br>    &#123;<br>    ListNode* T = cur-&gt;next;<br>            cur-&gt;next =pre;<br>            pre =cur;<br>            cur = T;<br>    &#125;  <span class="hljs-comment">//画图解决</span><br>        <span class="hljs-keyword">return</span> pre;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="2-删除倒数第k个结点"><a href="#2-删除倒数第k个结点" class="headerlink" title="2.删除倒数第k个结点"></a>2.删除倒数第k个结点</h3><p>​ 给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p><img src="http://imt.rui.vin/202202151920602.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">输入：head = [1,2,3,4,5], n = 2<br>输出：[1,2,3,5]<br></code></pre></td></tr></table></figure><p><strong>解法一</strong> ： 遍历整个链表后，算出结点数，反推正序第几个 O(N) N 为链表的长度 ，T（N)</p><p><strong>解法二</strong> ：双指针，一个前指针一个指针，前指针先走n步，然后 后指针和前指针一起走，前指针走到尾后，后指针指向待删除节点的前一部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//设置一个虚拟的前置结点</span><br>pre-&gt;next = head;<br>ListNode* h1 = pre; <span class="hljs-comment">//前指针</span><br>ListNode* h2 = pre; <span class="hljs-comment">//后指针</span><br>        ListNode* temp = <span class="hljs-literal">nullptr</span>; <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n+<span class="hljs-number">1</span>; ++i)<br>h1 = h1-&gt;next;<br><span class="hljs-keyword">while</span> (h1)<br>&#123;<br>h1 = h1-&gt;next;<br>h2 = h2-&gt;next;<br>&#125;<br>    temp = h2-&gt;next;<br>h2-&gt;next = h2-&gt;next-&gt;next;<br>    <span class="hljs-keyword">delete</span> temp;<br>    head = pre-&gt;next;<br>    <span class="hljs-keyword">delete</span> pre;<br><span class="hljs-keyword">return</span> head;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr><h3 id="3-盛最多水的容器（双指针）"><a href="#3-盛最多水的容器（双指针）" class="headerlink" title="3.盛最多水的容器（双指针）"></a>3.<a href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器（双指针）</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br></code></pre></td></tr></table></figure><p><img src="http://imt.rui.vin/202202151920242.jpeg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">输入：[1,8,6,2,5,4,8,3,7]<br>输出：49 <br>解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。<br></code></pre></td></tr></table></figure><p>解法一：暴力求解</p><p>​遍历每一个容器， 时间复杂度O（n^2)</p><p>解法二：  <strong>双指针</strong> </p><ul><li><p>一个指针在头，一个指针在后，分别向中间靠拢，如何移动呢（移动的条件）？</p></li><li><p>那个指针指向的值比较小就先移动那个.</p></li><li><p>容器的大小<br>min（头，尾） * （头到尾直接的距离）<br>为啥移动小的呢？<br>容器的大小取决于最小的那个板，移动最大的那个板子，容器只会变得最小或者不变（板子可能变大，容器大小不变，板子变小若是比原来较小的那个板子还小，容器则会变得更小）移动较大的那个板子则是可能变大，会不会错过同个长度的其他搭配呢？其实我也没琢磨透…</p></li><li><p>代码</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; height)</span> </span>&#123;<br><span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = height.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<span class="hljs-comment">//减一是要换成逻辑地址下标</span><br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">while</span> (l&lt;r)<br>&#123;<br><span class="hljs-type">int</span> area = <span class="hljs-built_in">min</span>(height[l], height[r]) * (r - l);<br>ans = <span class="hljs-built_in">max</span>(ans, area);<br><span class="hljs-keyword">if</span> (height[l] &lt; height[r])<br>l++;<br><span class="hljs-keyword">else</span><br>r--;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-冒泡排序"><a href="#4-冒泡排序" class="headerlink" title="4.冒泡排序"></a>4.冒泡排序</h3><p>​今天去面试，笔试要写个冒泡排序，这题应该信手拈来的，可我还推了那么久！！不行啊！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maopao</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; x)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i, y;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; x.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> ( y = <span class="hljs-number">0</span>; y &lt; x.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span> - i; y++)<br>&#123;<br><span class="hljs-keyword">if</span> (x[y] &gt; x[y + <span class="hljs-number">1</span>])<br>&#123;<br><span class="hljs-built_in">swap</span>(x[y], x[y + <span class="hljs-number">1</span>]);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>时间复杂度为O( n^2）  两遍循环</p><hr><h3 id="5数组中重复的数字"><a href="#5数组中重复的数字" class="headerlink" title="5数组中重复的数字"></a>5数组中重复的数字</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">找出数组中重复的数字。<br><br><br>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">示例 1：<br><br>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 <br><br><br></code></pre></td></tr></table></figure><p>解法1 :  用set容器（该容器没有重复的数字），遍历vector ，遍历一个插入一个，插入失败则是重复的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br> <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>()); <br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; x &lt; nums.<span class="hljs-built_in">size</span>(); x++) <br><span class="hljs-keyword">if</span> (nums[x] == nums[x + <span class="hljs-number">1</span>]) <br><span class="hljs-keyword">return</span> nums[x + <span class="hljs-number">1</span>]; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;; <br></code></pre></td></tr></table></figure><p>解法2： 原地交换，有0- n-1个数字， 每个数都对应一个下标 i，当然 下标 i 不一定等于  nums[i],</p><p>若是等于的话，则有可能一个下标对应很多个数，</p><p><img src="/C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1622255058092.png" alt="1622255058092"></p><p>遍历每一个数，将其数值作为下标，即</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">nums[nums[i]] = nums[i];<br></code></pre></td></tr></table></figure><p>这样一来就做到  数值就是其索引值</p><p>继续遍历 ，若是发现  交换时   索引值对应的数值已经存在了，则说明有重复的了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">if (nums[nums[i]]== nums[i])<br>return nums[i];<br></code></pre></td></tr></table></figure><p>看代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findRepeatNumber</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>      <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i&lt;nums.<span class="hljs-built_in">size</span>())  <span class="hljs-comment">//遍历</span><br>&#123;<br><span class="hljs-keyword">if</span> (nums[i] == i)  <span class="hljs-comment">//判断索引值和当前的值是否对应</span><br>&#123;<br>i++;<span class="hljs-comment">//是，则继续遍历下一个</span><br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (nums[nums[i]] == nums[i])  <span class="hljs-comment">//核心： 判断是否有重复</span><br>               <span class="hljs-comment">//判断当前的值 和以当前值为索引的所对应的值是否相等</span><br><span class="hljs-keyword">return</span> nums[i];<br><span class="hljs-built_in">swap</span>(nums[i], nums[nums[i]]);<span class="hljs-comment">//不相等，则交换</span><br>i++;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><h3 id="6-二叉树的三种遍历"><a href="#6-二叉树的三种遍历" class="headerlink" title="6.二叉树的三种遍历"></a>6.二叉树的三种遍历</h3><h4 id="递归-和迭代的方法"><a href="#递归-和迭代的方法" class="headerlink" title="递归 和迭代的方法"></a><strong>递归</strong> 和迭代的方法</h4><h4 id="前序-（根左右）"><a href="#前序-（根左右）" class="headerlink" title="前序  （根左右）"></a>前序  （根左右）</h4><p>递归：先往左边一直遍历，遍历一个抽一个，，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">forn_tree</span><span class="hljs-params">(TreeNode* root,vector&lt;<span class="hljs-type">int</span>&gt;&amp; res)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (root = <span class="hljs-literal">NULL</span>)    <span class="hljs-comment">//递归出口 该节点不存在</span><br><span class="hljs-keyword">return</span> ;  <span class="hljs-comment">//遍历每一个元素都是根节点</span><br>res.<span class="hljs-built_in">push_back</span>(root-&gt;val);  <span class="hljs-comment">//遍历每一个元素都是根节点</span><br>forn_tree(root-&gt;left, res);<br>forn_tree(root-&gt;right, res);<br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br>forn_tree(root, res);  <span class="hljs-comment">//递归函数</span><br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>利用栈来完成递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br>stack&lt;TreeNode*&gt; s;<br><span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() || root)<br>&#123;<br><span class="hljs-keyword">if</span> (root)<br>&#123;<br>res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>s.<span class="hljs-built_in">push</span>(root);<br>root = root-&gt;left;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>root = s.<span class="hljs-built_in">top</span>();<br>s.<span class="hljs-built_in">pop</span>();<br>    root = root-&gt;right;<br>&#125;<br>&#125;<br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="中序-（左根右）"><a href="#中序-（左根右）" class="headerlink" title="中序  （左根右）"></a>中序  （左根右）</h4><p>同上，递归遍历，问题是何时打印出来该节点  总结：跟在哪里就先打印哪里，如中序  根在左右节点中间</p><p>所以， 先遍历左边，一直往左遍历，到最左边的时候打印节点，然后往右遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br><span class="hljs-built_in">inorderTraversal_tree</span>(root, res);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">inorderTraversal_tree</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br><span class="hljs-keyword">return</span> ;<br><span class="hljs-built_in">inorderTraversal_tree</span>(root-&gt;left, res);<br>res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br><span class="hljs-built_in">inorderTraversal_tree</span>(root-&gt;right, res);<br><br>&#125;<br></code></pre></td></tr></table></figure><p>使用栈来递归：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">inorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br>stack&lt;TreeNode*&gt; s;<br><span class="hljs-keyword">while</span> (!s.<span class="hljs-built_in">empty</span>() || root)<br>&#123;<br><span class="hljs-keyword">if</span> (root)<br>&#123;<br>s.<span class="hljs-built_in">push</span>(root);<br>root = root-&gt;left;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>root = s.<span class="hljs-built_in">top</span>();<br>s.<span class="hljs-built_in">pop</span>();<br>res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>root = root-&gt;right;<br>&#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="后续-（左右根）"><a href="#后续-（左右根）" class="headerlink" title="后续 （左右根）"></a>后续 （左右根）</h4><p>原理同上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">postorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; res;<br><span class="hljs-built_in">inorderTraversal_tree</span>(root, res);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">postorderTraversal_tree</span><span class="hljs-params">(TreeNode* root, vector&lt;<span class="hljs-type">int</span>&gt; &amp;res)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>)<br><span class="hljs-keyword">return</span> ;<br><span class="hljs-built_in">postorderTraversal_tree</span>(root-&gt;left, res);<br><br><span class="hljs-built_in">postorderTraversal_tree</span>(root-&gt;right, res);<br>        res.<span class="hljs-built_in">push_back</span>(root-&gt;val);<br>&#125;<br></code></pre></td></tr></table></figure><p>使用栈来递归：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">vector&lt;int&gt; postorderTraversal(TreeNode* root) <br>&#123;<br>vector&lt;int&gt; res;<br>inorderTraversal_tree(root, res);<br>return res;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-合并两个有序链表"><a href="#7-合并两个有序链表" class="headerlink" title="7. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">7. 合并两个有序链表</a></h3><p>将两个升序链表合并为一个新的 <strong>升序</strong>  链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p>思路：</p><p>​两个链表，建立一个新的头结点，每次比较两个链表当x较大小，那个小则头结点指向那个（尾插法），当前节点值小的链表则指向下一个节点，空间复杂度为O（1），没有用到额外的空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本"> class Solution &#123;<br><br>public:<br><br>  ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;<br><br>    ListNode* preHead = new ListNode(-1);<br>    ListNode* prev = preHead;<br>while (l1 != nullptr &amp;&amp; l2 != nullptr) &#123;<br>if (l1-&gt;val &lt; l2-&gt;val) &#123;<br> prev-&gt;next = l1;<br>     l1 = l1-&gt;next;<br>    &#125; else &#123;<br>    prev-&gt;next = l2;<br>    l2 = l2-&gt;next;<br>   &#125;<br>    prev = prev-&gt;next; //尾插法<br>  &#125;<br>   // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可<br>   prev-&gt;next = (l1 == nullptr ? l2 : l1);<br>    return preHead-&gt;next;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="8-合并K个升序链表"><a href="#8-合并K个升序链表" class="headerlink" title="8.合并K个升序链表"></a>8.合并K个升序链表</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本"> 输入：lists = [[1,4,5],[1,3,4],[2,6]]<br>输出：[1,1,2,3,4,4,5,6]<br>解释：链表数组如下：<br>[<br>  1-&gt;4-&gt;5,<br>  1-&gt;3-&gt;4,<br>  2-&gt;6<br>]<br>将它们合并到一个有序链表中得到。<br>1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6<br></code></pre></td></tr></table></figure><p>多个链表升序，也才用合并两个链表的思路来，用一个临时链表ans来保存两个链表合并后的结果，然后遍历每一个有序链表</p><p>没有用到额外的空间，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++">  <span class="hljs-function">ListNode* <span class="hljs-title">twoLists1</span><span class="hljs-params">(ListNode* l1, ListNode* l2)</span> </span>&#123;<br>ListNode* preHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>ListNode* prev = preHead;<br><span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">nullptr</span> &amp;&amp; l2 != <span class="hljs-literal">nullptr</span>) &#123;<br><span class="hljs-keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;<br>prev-&gt;next = l1;<br>l1 = l1-&gt;next;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>prev-&gt;next = l2;<br>l2 = l2-&gt;next;<br>&#125;<br>prev = prev-&gt;next; <span class="hljs-comment">//尾插法</span><br>&#125;<br><span class="hljs-comment">// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可</span><br>prev-&gt;next = l1 == <span class="hljs-literal">nullptr</span> ? l2 : l1; <span class="hljs-comment">//三则表达式   如果l1为空了，则l2还有</span><br><span class="hljs-keyword">return</span> preHead-&gt;next;<br>&#125;<br><span class="hljs-function">ListNode* <span class="hljs-title">mergeKLists</span><span class="hljs-params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;<br>  ListNode *ans = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">int</span> len = lists.<span class="hljs-built_in">size</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)&#123;<br>ans = <span class="hljs-built_in">twoLists1</span>(ans, lists[i]); <span class="hljs-comment">//遍历每一个链表</span><br>&#125;<br><span class="hljs-keyword">return</span> ans;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-有效的括号"><a href="#9-有效的括号" class="headerlink" title="9.有效的括号"></a>9.<a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">给定一个只包括 <span class="hljs-string">&#x27;(&#x27;</span>，<span class="hljs-string">&#x27;)&#x27;</span>，<span class="hljs-string">&#x27;&#123;&#x27;</span>，<span class="hljs-string">&#x27;&#125;&#x27;</span>，<span class="hljs-string">&#x27;[&#x27;</span>，<span class="hljs-string">&#x27;]&#x27;</span> 的字符串 s ，判断字符串是否有效。<br><br>有效字符串需满足：<br><br>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br><br></code></pre></td></tr></table></figure><p>思路：</p><p>​利用堆栈的特性（FIFO） ，遍历字符串每一个元素时，逐个入栈，一定是左括号的先入栈</p><p>遍历到右括号则检查栈的顶部是否匹配，匹配则出栈，为了方便建立对应 哈希表 方便判断出 左右括号是否匹配，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br> <br><span class="hljs-keyword">public</span>:<br><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, z = <span class="hljs-number">0</span>, d = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();   <br>    <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) <span class="hljs-comment">//括号肯定为偶数</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      <span class="hljs-comment">//建立无序表 逐一做匹配</span><br>    unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">char</span>&gt; pairs = &#123;<br>    &#123;<span class="hljs-string">&#x27;)&#x27;</span>, <span class="hljs-string">&#x27;(&#x27;</span>&#125;,<br>    &#123;<span class="hljs-string">&#x27;]&#x27;</span>, <span class="hljs-string">&#x27;[&#x27;</span>&#125;,<br>     &#123;<span class="hljs-string">&#x27;&#125;&#x27;</span>, <span class="hljs-string">&#x27;&#123;&#x27;</span>&#125;<br>    &#125;;<br>    stack&lt;<span class="hljs-type">char</span>&gt; stk;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s) <span class="hljs-comment">//遍历字符串元素</span><br>    &#123;<br>      <span class="hljs-keyword">if</span> (pairs.<span class="hljs-built_in">count</span>(ch))  <span class="hljs-comment">//判断改字符是否为右括号</span><br>      &#123;<br>       <span class="hljs-keyword">if</span> (stk.<span class="hljs-built_in">empty</span>() || stk.<span class="hljs-built_in">top</span>() != pairs[ch])  <span class="hljs-comment">//若果栈空了或者栈顶的右括号和刚遍历的左括号不匹配则返回false</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        stk.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//匹配成功则把出栈，把栈顶匹配完成的元素去掉</span><br>      &#125;<br>     <span class="hljs-keyword">else</span> &#123;<br>        stk.<span class="hljs-built_in">push</span>(ch);<span class="hljs-comment">//没有遍历到右括号则出栈</span><br>      &#125;<br>    &#125;  <br>   <span class="hljs-keyword">return</span> stk.<span class="hljs-built_in">empty</span>();<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="10-斐波那契数列"><a href="#10-斐波那契数列" class="headerlink" title=" 10. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/"> 10. 斐波那契数列</a></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：<br><br>F(0) = 0,   F(1) = 1<br>F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.<br>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。<br></code></pre></td></tr></table></figure><p>递归的接法：</p><p>​将大问题分解成若干个小问题</p><p>​F(5)&#x3D; F(4)+F(3);</p><p>​F(4)&#x3D;F(3)+F(2)…..</p><p>​以此类推</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>非递归的接法（从下往上，求出每个数 ,时间复杂度 O(n)）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib_1</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> arr[<span class="hljs-number">2</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-type">int</span> pre = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> now = <span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> next = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i =<span class="hljs-number">2</span>; i &lt;= n; ++i)<br>&#123;<br>next = pre + now;   <span class="hljs-comment">//用next 保留两个数相加的和</span><br>pre = now;<span class="hljs-comment">//pre 和 now 变量向前推进</span><br>now = next;<br>&#125; <br><span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以用以下的方法（和上面的思路一样，只是采用了数组的形式，很妙！）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>arr[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;;<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>     arr[i &amp; <span class="hljs-number">1</span>] = (arr[<span class="hljs-number">0</span>] + arr[<span class="hljs-number">1</span>]) % (<span class="hljs-type">int</span>)(<span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>);<br>   &#125;<br>   <span class="hljs-keyword">return</span> arr[n &amp; <span class="hljs-number">1</span>];  <span class="hljs-comment">//n &amp;1 的用意是： 定位到数组的小标 ， n&amp;1 的值只能为 0 或 1</span><br> &#125;<br><br><br></code></pre></td></tr></table></figure><p>11.青蛙跳台阶（和斐波那契数列一样）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。<br><br>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。<br><br></code></pre></td></tr></table></figure><p>青蛙可以跳一步或者两步  顶一个函数  f（n）  n表示台阶</p><p>​跳第一个台阶的时候，有一种选择 f(1)，跳第二台阶的时候 f(2) ，有两种选择，跳第三个的时候，第二台阶到第三个台阶只有一种选择–跳一个；第一个台阶到第三台阶跳两个，需要考虑的是当前阶梯数 n 和 n -2 和n与n-2之间的的数目  f（n） &#x3D; f（n-1） +f ( n -2 )</p><p>f(3) &#x3D; f(2)+f(1)  这样就是斐波那契数列啦，可以用递归，但重复计算很多</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本"> int numWays(int n) &#123;<br>  if(n ==0)<br>   return 1;<br>  else if(n ==1)<br>    return 1;<br>  else if(n ==2)<br>    return 2;<br>  int pre = 1;<br>  int now = 2;<br>  int next = 0;<br>  for (int i =3; i &lt;= n; ++i)<br>  &#123;<br>      next = (pre + now)%(int(1e9+7));  //用next 保留两个数相加的和<br>   pre = now%(int(1e9+7));     //pre 和 now 变量向前推进<br>      now = next%(int(1e9+7));<br>  &#125;    <br>  return next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="11-二分查找"><a href="#11-二分查找" class="headerlink" title="11.二分查找"></a>11.二分查找</h3><p>二分查找是针对<strong>有序数列</strong> 的，对无序数列是无效的，在有序序列中使用二分查找能大大提高查找效率，通常能将时间按复杂度从       <strong>O(n)降至O(logn)</strong> </p><p>eg:</p><p>在一个有序数组中查找某个元素的位置</p><ul><li>递归</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_gui</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> right = r;<br><span class="hljs-type">int</span> left = l;<br><span class="hljs-type">int</span> mid  = left + (right - left) / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (right &lt; left)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">if</span> (nums[mid] &lt; target)<br><span class="hljs-built_in">se_gui</span>(nums, target,mid + <span class="hljs-number">1</span>,r);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target)<br><span class="hljs-built_in">se_gui</span>(nums, target, l, mid- <span class="hljs-number">1</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] == target)<br><span class="hljs-keyword">return</span> mid;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>非递归</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">- <br>int search1(vector&lt;int&gt;&amp; nums, int target) &#123;<br>int len = nums.size() - 1;<br>int left = 0, right = len;<br>int mid;<br>while (left &lt; right)<br>&#123;<br>mid = left + (right - left) / 2;<br>if (nums[mid] &lt; target)<br>left = mid + 1;<br>else if (nums[mid] &gt; target)<br>right = mid - 1;<br>else<br>return mid;<br>&#125;<br>return -1;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>相关题目：</p><p>​在升序的序列中找到指定数字出现的次数</p><h3 id="12-查找两个链表的相同节点（）"><a href="#12-查找两个链表的相同节点（）" class="headerlink" title="12.查找两个链表的相同节点（）"></a>12.查找两个链表的相同节点（）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) &#123;<br>ListNode* At = headA;<br>ListNode* Bt = headB;<br>while (At!=Bt)<br>&#123;<br>if (At != nullptr)<br>At = At-&gt;next;<br>else<br>        At =headB;<br>        <br>if (Bt == nullptr)<br>Bt = Bt-&gt;next;<br>else<br>Bt = headA;<br>&#125;<br>return Bt;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-排序大总结"><a href="#13-排序大总结" class="headerlink" title="13.排序大总结"></a>13.排序大总结</h3><p>快排（被问了好几次…）</p><p>复杂度是O（nlogn）</p><p>思路是：</p><p>​    每一次的遍历把首元素放到他应该在的位置</p><p>如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">5，1 ，4，3<br></code></pre></td></tr></table></figure><p>​        5 的位置应该是  在四位的，第一轮目标就时要包5 放在第四位，其他的不用管</p><p>其它的数字 经过一轮的排序后，会以选定数字的为轴，大的右边，小的在左边；</p><p>​      以定位好的数字为轴，对左边的数字在重复一次以上的操作，对右边的也是，这就是用到递归了;</p><p>递归的层数越多是时间复杂度也越大，   平均的时间复杂度是 nO(logn)</p><p>n 代表层数，  logn带边每层遍历的次数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本">vector&lt;int&gt; sortArray_1(vector&lt;int&gt;&amp; nums) &#123;<br>int high = nums.size() - 1;<br>QSort(nums, 0, high);<br>return nums;<br>&#125;<br>void QSort(vector&lt;int&gt; &amp;nums,int low,int high)<br>&#123;<br>int mid;<br>if (low &lt; high)  <br>&#123;<br>mid = Partition(nums, low, high);<br>QSort(nums, low, mid - 1); //递归左边的<br>QSort(nums, mid + 1,high); //递归右边的<br>&#125;<br>&#125;<br>int Partition(vector&lt;int&gt;&amp; nums,int low,int high)<br>&#123;<br>int r = high;<br>int l = low;<br>int std = nums[l]; //选定需要定位的目标数<br>while (l &lt; r)  //首尾各自开始向中心靠齐<br>&#123;<br>//要从后面开始，判断数字是否大于目标数，知道遇到大于的<br>while (l &lt; r &amp;&amp; nums[r] &gt;= std)  <br>&#123;<br>r--;<br>&#125;<br>//然后交换数字<br>swap(nums[l], nums[r]);<br>//然后在来左边 <br>while (l &lt; r &amp;&amp; nums[l] &lt;= std)<br>&#123;<br>l++;<br>&#125;//同理<br>swap(nums[l], nums[r]);<br>&#125;<br><br>return l;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="14-2n-1个数字，找出一个不对的数字"><a href="#14-2n-1个数字，找出一个不对的数字" class="headerlink" title="14. 2n+1个数字，找出一个不对的数字"></a>14. 2n+1个数字，找出一个不对的数字</h3><h3 id="15-1000瓶药水有一瓶毒药，怎么快速检测出来（可用小白鼠）"><a href="#15-1000瓶药水有一瓶毒药，怎么快速检测出来（可用小白鼠）" class="headerlink" title="15.1000瓶药水有一瓶毒药，怎么快速检测出来（可用小白鼠）"></a>15.1000瓶药水有一瓶毒药，怎么快速检测出来（可用小白鼠）</h3><p>讲一千瓶药水用二进制排序，2的10次方 为1024 故需要10位</p><p>00000 00000    1</p><p>00000 00001    2</p><p>00000 00010    3</p><p>…..</p><p>1111101000    1000</p><p>有10 位，我们用10只老鼠（每个老鼠都有编号 0-9）来检测，    瓶子序号中，第n位为1（n的取值为（0~9）） ，就用给对应编号为 n 的老鼠喝 如：</p><p>00001 00001       第0 位和第5位为1 ，则用调 编号 为 0 和 5的老去和药水</p><p>最后看是那些老鼠死了，死老鼠的序号，对应二进制的第几位，如 编号 二 和 三老鼠死了，  则二进制  为 0110  ，该编号对应的药水的编号，就是有毒的了</p><h3 id="16-接雨水"><a href="#16-接雨水" class="headerlink" title="16.接雨水"></a>16.接雨水</h3><p>给定 <em>n</em>  个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p>思路：</p><ul><li>暴力解法<br>判断每个柱子能否装水，得看柱子左右两边的柱子 ，水的高度取决于最短的<br>并且中间的柱子也有高度，所以也要减去当前柱子（即中间的柱子）的高度<br>每一个柱子 装水量为<br>​ s &#x3D;  min（left，right） - mid<br>总结： 遍历每一个柱子，取柱子左边最高的柱子，柱子右边最高的柱子，然后以左右两边最低的为标准来计算</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs 纯文本"> class Solution &#123;<br>public:<br>  int trap(vector&lt;int&gt;&amp; height) &#123;<br>  int n = height.size();<br>  int ans = 0;<br>  //遍历每一个柱子<br>  for (int i = 1; i &lt; n - 1; i++) &#123;<br>   int l_max = 0, r_max = 0;<br>    // 找右边最高的柱子<br>   for (int j = i; j &lt; n; j++)<br>    r_max = max(r_max, height[j]);<br>    // 找左边最高的柱子<br>    for (int j = i; j &gt;= 0; j--)<br>    l_max = max(l_max, height[j]);<br>    // 如果自己就是最高的话，<br>    // l_max == r_max == height[i]<br>    ans += min(l_max, r_max) - height[i];<br>  &#125;<br>  return ans;<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>刷题合集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_Lab2 内存</title>
    <link href="/2022/02/08/OS_Lab%202%20%E5%86%85%E5%AD%98/"/>
    <url>/2022/02/08/OS_Lab%202%20%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p>在 jos中 BIOS程序先写好了，qemu已启动直接跳到了 0x7c00处 开始执行程序，在设模式下内存布局如图</p><p><img src="http://imt.rui.vin/202202161604341.jpeg" alt="preview"></p><span id="more"></span><p>注意：  在 lab1中 作者已经帮我们手动映射了 4 MB的内存</p><p>所以0XF0100000开始的内存映射到了0x0100000的位置上，物理地址加上0XF0000000就是虚拟地址</p><p><strong>物理地址直接通过MMU模块转换成了虚拟地址！</strong></p><p>到目前为止，内核已经写进了了内存，</p><p>​如图</p><p><img src="http://imt.rui.vin/202202171701110.png" alt="image-20220217161035639"></p><p>将一个已经映射好的页表的地址放在指定的地方，开业分页模式后，cpu会自动查找到这个并且通过MMU模块转换层虚拟地址</p><hr><h1 id="开始-lab2-！"><a href="#开始-lab2-！" class="headerlink" title="开始 lab2 ！"></a>开始 lab2 ！</h1><p>本章主要内容 是内存管理  虚拟内存  -&gt; 映射到物理内存</p><p>目前的内存布局如下 </p><p><img src="http://imt.rui.vin/202202172030021.png" alt="image-20220217203020565"></p><p>在写入完内核后，我们知道j接下来的任务建立页表，  我们要从哪里开始建立页表呢？很明显是在内核之后，而我们不知道内核的具体到小，而内核的大小是不固定的，在那个地址结束呢？在 kernel文件生成时，BSS段我们设置一个变量 end，作为内核结束的标志，所以我们可以在其他文件extend 引用这个变量，就可以知道 内核结束的位置在哪里！</p><p><img src="http://imt.rui.vin/202202171958263.png" alt="image-20220217195848698"></p><hr><h3 id="Exercise-1-完善函数"><a href="#Exercise-1-完善函数" class="headerlink" title="Exercise 1.   完善函数"></a><strong>Exercise 1.</strong>   完善函数</h3><p> In the file <code>kern/pmap.c</code>, you must implement code for the following functions (probably in the order given).</p><blockquote><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs isbl">&gt;<span class="hljs-function"><span class="hljs-title">boot_alloc</span>()</span><br>&gt;<span class="hljs-function"><span class="hljs-title">mem_init</span>() (<span class="hljs-variable">only</span> <span class="hljs-variable">up</span> <span class="hljs-variable">to</span> <span class="hljs-variable">the</span> <span class="hljs-variable">call</span> <span class="hljs-variable">to</span> <span class="hljs-title">check_page_free_list</span>(<span class="hljs-number">1</span>)`)</span><br>&gt;<span class="hljs-function"><span class="hljs-title">page_init</span>()</span><br>&gt;<span class="hljs-function"><span class="hljs-title">page_alloc</span>()</span><br>&gt;<span class="hljs-function"><span class="hljs-title">page_free</span>()</span><br></code></pre></td></tr></table></figure><p><code>check_page_free_list()</code> and <code>check_page_alloc()</code> test your physical page allocator. You should boot JOS and see whether <code>check_page_alloc()</code> reports success. Fix your code so that it passes. You may find it helpful to add your own <code>assert()</code>s to verify that your assumptions are correct.</p></blockquote><p>第一个函数： boot_alloc()<br>最基本的分配内存方式（目前没有malloc，所以我们自己实现一个）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">boot_alloc(<span class="hljs-type">uint32_t</span> n)<br>&#123;<br>   <span class="hljs-type">static</span> <span class="hljs-type">char</span> *nextfree;<span class="hljs-comment">// virtual address of next byte of free memory</span><br>   <span class="hljs-type">char</span> *result;<br>        <span class="hljs-keyword">if</span> (!nextfree) &#123;<br>          <span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> end[];<br>          nextfree = ROUNDUP((<span class="hljs-type">char</span> *)end, PGSIZE);<br>        &#125;<br>        cprintf(<span class="hljs-string">&quot;boot_alloc memory at %x\n&quot;</span>, nextfree);<br>        cprintf(<span class="hljs-string">&quot;Next memory at %x\n&quot;</span>, ROUNDUP((<span class="hljs-type">char</span> *)(nextfree + n), PGSIZE));<br>        <span class="hljs-keyword">if</span> (n != <span class="hljs-number">0</span>) &#123;                                                                                               <br>          <span class="hljs-type">char</span> *next = nextfree;<br>          nextfree = ROUNDUP((<span class="hljs-type">char</span> *)(nextfree + n), PGSIZE);<br>          <span class="hljs-keyword">return</span> next;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>          <span class="hljs-keyword">return</span> nextfree;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有了基本的内存分配方式就可以随心分配内存了</p><p>先分配<strong>页目录表</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">kern_pgdir = (<span class="hljs-type">pde_t</span> *)boot_alloc(PGSIZE);<br><span class="hljs-built_in">memset</span>(kern_pgdir, <span class="hljs-number">0</span>, PGSIZE);<br></code></pre></td></tr></table></figure><p>随后我们继续分配<strong>页表</strong></p><p>每个页表项都是个结构体，这个结构体用途是管理内存，这里的每个结构体都管理这个一个4k大小的内存！！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>pages = (<span class="hljs-keyword">struct</span> PageInfo*)boot_alloc(<span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> PageInfo)*npages);  <span class="hljs-comment">//调用boot_alloc()函数找到空闲空间起点，并且大小n= PageInfo结构大小*npages</span><br><span class="hljs-built_in">memset</span>(pages,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> (<span class="hljs-keyword">struct</span> PageInfo)*npages);<br></code></pre></td></tr></table></figure><p><img src="http://imt.rui.vin/202202172123327.png"></p><p><strong>第二个函数page_init()</strong></p><p>初始化页表：</p><p>pages并没有内容<br>按要求来  </p><p>第一个物理页标记为被使用，有几个区间是不可以用的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span><br><span class="hljs-title function_">page_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">size_t</span> i;<br><span class="hljs-type">size_t</span> io_hole_start_page = (<span class="hljs-type">size_t</span>)IOPHYSMEM / PGSIZE;<br><span class="hljs-type">size_t</span> kernel_end_page = PADDR(boot_alloc(<span class="hljs-number">0</span>)) / PGSIZE;  <span class="hljs-comment">//注意boot_alloc()返回虚拟地址</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; npages; i++) &#123;<br>    <span class="hljs-keyword">if</span>(i==<span class="hljs-number">0</span>) <span class="hljs-comment">//如上面要求1</span><br>    &#123;<br>        pages[i].pp_ref = <span class="hljs-number">1</span>;<br>pages[i].pp_link = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i &gt;= io_hole_start_page &amp;&amp; i &lt;= kernel_end_page)   <span class="hljs-comment">//这区域内是已经被使用的了</span><br>    &#123;<br>        pages[i].pp_ref = <span class="hljs-number">1</span>;<br>pages[i].pp_link = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span>  <span class="hljs-comment">//而这段 才是真正 我么可以操控的内存</span><br>    &#123;<br>pages[i].pp_ref = <span class="hljs-number">0</span>;<br>pages[i].pp_link = page_free_list; <span class="hljs-comment">//  头插法形成一个链表</span><br>page_free_list = &amp;pages[i];<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第三个函数 page_alloc()</strong>   </p><p>  page_init 生成了页表，但是页表项并没有管理空间，  page_alloc 函数可以申请一个空间，并用一个PageInfo来管理</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">struct</span> PageInfo *<br><span class="hljs-title function_">page_alloc</span><span class="hljs-params">(<span class="hljs-type">int</span> alloc_flags)</span><br>&#123;<br><span class="hljs-comment">// Fill this function in ///  page_free_list是指向页表项的结构体指针 （链表）</span><br>        <span class="hljs-keyword">if</span> (page_free_list == <span class="hljs-literal">NULL</span>) &#123;   <br>          cprintf(<span class="hljs-string">&quot;out of free memory&quot;</span>);<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PageInfo</span> *<span class="hljs-title">addr</span> =</span> page_free_list;<br>        page_free_list = page_free_list-&gt;pp_link;  <span class="hljs-comment">//需要使用一个页表项 ，防止丢失，指向下一个页表项</span><br>        addr-&gt;pp_link = <span class="hljs-literal">NULL</span>;  <br>        <span class="hljs-keyword">if</span> (alloc_flags &amp; ALLOC_ZERO) &#123;  <span class="hljs-comment">//看 传入的参数， 如果为 1 ，则申请一个 4k的内存 </span><br>          <span class="hljs-built_in">memset</span>(page2kva(addr), <span class="hljs-number">0</span>, PGSIZE);  <span class="hljs-comment">//</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> addr;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里说下 page2kva(addr)  这个函数；<br>memset扩充内存，操作的虚拟是虚拟内存 （实际物理地址加 0xf00000）<br>现在 的addr 只是这个页表项的地址，如果直接按这个地址扩展的话肯定是会覆盖其他页表项的，所以呢，我们的根据这个页表项设计出在那分配内存</p><p>page2pa ：    pages是页表项的初始地址   pp-pages 可以得出 是第几个页表项 ； 而 左移则是   乘以4096 ，那么这个结果是 物理页的偏移量，我们可以算出在哪里开始分配内存</p><p>KADDR ： 刚才得出的是物理内存，我们还得把这个转换成虚拟地址 ，这个宏就可以将物理地址转换成虚拟地址</p><p><img src="http://imt.rui.vin/202202182223638.png" alt="image-20220218222302556"></p><hr><h3 id="Exercise-4-完善函数"><a href="#Exercise-4-完善函数" class="headerlink" title="Exercise 4   完善函数"></a><strong>Exercise 4</strong>   完善函数</h3><blockquote><p><strong>Exercise 4.</strong> In the file <code>kern/pmap.c</code>, you must implement code for the following functions.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">pgdir_walk()<br>boot_map_region()<br>page_lookup()<br>page_remove()<br>page_insert()<br></code></pre></td></tr></table></figure><p><code>check_page()</code>, called from <code>mem_init()</code>, tests your page table management routines. You should make sure it reports success before proceeding.</p></blockquote><p>​pgdir_walk(pde_t *pgdir, const void *va, int create)<br>​给一个虚拟地址，页目录表入口，返回该虚拟地址所在的页表项</p><p><img src="http://imt.rui.vin/202202201548004.png" alt="image-20220220154819450"></p><p>大致看完 lab2 ，先回答几个问题</p><p>在 lab1 完成后，此时 OS的布局是怎么的？</p><p>解释下 虚拟内存 ，物理内存， 两者是如何映射的？</p><p>kernel 存放在哪个位值？ （分派内存是以防覆盖） （提示 ： bss）</p><p>内存权限问题</p><p>开启分页模式后，物理地址 默认都会转换为 虚拟地址（ cr3 寄存器 可以设置 ）</p><p><img src="http://imt.rui.vin/202202171647087.png" alt="image-20220217164716439"></p><p><img src="http://imt.rui.vin/202202171647673.png" alt="image-20220217164746773"></p><p><img src="http://imt.rui.vin/202202152318490.png" alt="img"></p><p><img src="http://imt.rui.vin/202202092233782.png" alt="image-20220209223329957"></p><p><img src="http://imt.rui.vin/202202111132647.png" alt="image-20220211105409966"></p><p><img src="http://imt.rui.vin/202202111132406.png" alt="image-20220211113225003"></p><p><img src="http://imt.rui.vin/202202152325037.png" alt="img"></p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS_Lab 1 Booting a PC</title>
    <link href="/2022/02/06/OS_Lab%201%20Booting%20a%20PC/"/>
    <url>/2022/02/06/OS_Lab%201%20Booting%20a%20PC/</url>
    
    <content type="html"><![CDATA[<p><img src="http://imt.rui.vin/image-20220206112414457-16441195534711.png" alt="image-20220206112414457"></p> <span id="more"></span><h3 id="step5-是课程导论，介绍该课程的安排以及Unix的使用"><a href="#step5-是课程导论，介绍该课程的安排以及Unix的使用" class="headerlink" title="step5 是课程导论，介绍该课程的安排以及Unix的使用"></a>step5 是课程导论，介绍该课程的安排以及Unix的使用</h3><p>这次作业是  介绍汇编和一些工具的使用</p><p><img src="http://imt.rui.vin/image-20220206113644102-16441195589572.png" alt="image-20220206113644102"></p><p>现在开始：</p><h3 id="Software-Setup"><a href="#Software-Setup" class="headerlink" title="Software Setup"></a>Software Setup</h3><p>先把源码 该章节的源码 clone下来  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://pdos.csail.mit.edu/6.828/2018/jos.git<br></code></pre></td></tr></table></figure><p><img src="http://imt.rui.vin/image-20220206113212423.png" alt="image-20220206113212423"></p><p>这两部分是 clone源码和该怎么用 git交作业的 不必细说</p><p><img src="http://imt.rui.vin/image-20220206113411035.png" alt="image-20220206113411035"></p><h3 id="Part-1-PC-Bootstrap"><a href="#Part-1-PC-Bootstrap" class="headerlink" title="Part 1: PC Bootstrap"></a>Part 1: PC Bootstrap</h3><h4 id="1-Getting-Started-with-x86-assembly"><a href="#1-Getting-Started-with-x86-assembly" class="headerlink" title="1. Getting Started with x86 assembly"></a>1. Getting Started with x86 assembly</h4><p>​这里申明了 该os是采用 <em>AT&amp;T</em> 风格 的汇编（我接触比较多的是 Intel 风格） 这部分是 让我们熟悉汇编语言，接下来的课程 打好基础，（我会另起一章专门写汇编）</p><h4 id="2-Simulating-the-x86"><a href="#2-Simulating-the-x86" class="headerlink" title="2. Simulating the x86"></a>2. Simulating the x86</h4><p>进入目录  make </p><p><img src="http://imt.rui.vin/202202061510375.png" alt="image-20220206145945011"></p><p>可能会有这个报错！ 这是 一个整数是 64位除以 一个数位32位的时候  ，官方说安装 <strong>gcc-multilib</strong><br>但没什么用，我直接把这个函数参数成32位了…先这样再说吧（这个是打印数字的 函数）</p><p><img src="http://imt.rui.vin/202202061509929.png" alt="image-20220206145349817"></p><p>运行 qemu  （关于的qemu的安装，网上有很多）</p><p><img src="http://imt.rui.vin/202202061510571.png" alt="image-20220206150545992"></p><h4 id="The-PC’s-Physical-Address-Space"><a href="#The-PC’s-Physical-Address-Space" class="headerlink" title="The PC’s Physical Address Space"></a>The PC’s Physical Address Space</h4><p>下图是 内存的布局（4gb），早期的内存只有 1Mb，为了兼容以前的所以还是保留下来，这1Mb 接下来我们会使用到！</p><p><img src="http://imt.rui.vin/202202062055555.png" alt="image-20220206205505422"></p><h3 id="Part-2-The-Boot-Loader"><a href="#Part-2-The-Boot-Loader" class="headerlink" title="Part 2: The Boot Loader"></a>Part 2: The Boot Loader</h3><p>part2 是引导程序  BootLoader 的介绍， 这个是什么呢？</p><p>​电脑启动是时候 会有个<br>​一句话来表达就是  系统运作之前 所运行的程序，当我们按了开机键，首先是 运行这个程序，<strong>现在的大多数电脑 这个程序都 写死在主板里</strong>（GRUB？）。</p><ul><li>这个程序有什么用？</li></ul><ol><li>硬件自检，如显卡 ，声卡那些…</li><li>这个并不是真正的操作系统，所以这个程序的作用是 找到 OS，并把这个OS程序加载到内存中 （OS 也是一个程序！），随后转让控制权。</li></ol><ul><li>这个 BootLoader 程序 cpu怎么找到的呢？<br>  开机的时候，就开是扫描 硬盘，硬盘被划分为512字节的区域，称为扇区，一个硬盘有很多扇区，扫一次 就一个扇区，如果找到了（如何判定？ 如果这个扇区的最后两个字节内容是0x55和0xAA 则就是要找的 ）  将这个 512 字节扇区加载到内存地址为 0x7c00（为什么是这个，这个是有来源的 ，大家可以找下），加载完成后 ，执行 cpu 就跳到 0x7c00 处开始执行程序，</li></ul><h4 id="Exercise-3"><a href="#Exercise-3" class="headerlink" title="Exercise 3"></a><strong>Exercise 3</strong></h4><p>看 os启动的流程 ，gdb调试 ，启动主要有两个文件  boot&#x2F;main.c  和  boot.s </p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs diff">Exercise 3.   Take a look at the [lab tools guide](https://pdos.csail.mit.edu/6.828/2018/labguide.html), especially the section on GDB commands. Even if you&#x27;re familiar with GDB, this includes some esoteric GDB commands that are useful for OS work.<br><br>Set a breakpoint at address 0x7c00, which is where the boot sector will be loaded. Continue execution until that breakpoint. Trace through the code in `boot/boot.S`, using the source code and the disassembly file `obj/boot/boot.asm` to keep track of where you are. Also use the `x/i` command in GDB to disassemble sequences of instructions in the boot loader, and compare the original boot loader source code with both the disassembly in `obj/boot/boot.asm` and GDB.<br><br>Trace into `bootmain()` in `boot/main.c`, and then into `readsect()`. Identify the exact assembly instructions that correspond to each of the statements in `readsect()`. Trace through the rest of `readsect()` and back out into `bootmain()`, and identify the begin and end of the `for` loop that reads the remaining sectors of the kernel from the disk. Find out what code will run when the loop is finished, set a breakpoint there, and continue to that breakpoint. Then step through the remainder of the boot loader.<br></code></pre></td></tr></table></figure><p>开始gdb调试</p><p>一个窗口运行  make qemu-gdb   （开启了个端口）<br>再开一个窗口运行  make gdb  （运行行了一个gdb脚本，远程调试）</p><p><img src="http://imt.rui.vin/202202071248330.png" alt="image-20220207124829335"></p><p>现在我们开始 打断点  教材里有说说到是 从 0x7c00 开始的，断点设到 0x7c00 ，b -》 break </p><p><img src="http://imt.rui.vin/202202071251934.png" alt="image-20220207125156235"></p><p>c 一直执行知道遇到断点<br>si 意为 执行下一步汇编<br>x&#x2F;N  ADDR   为看这个地址的汇编指令  N为查看几条指令<br>info register ： 查看 寄存器的值 </p><p><img src="http://imt.rui.vin/202202071255688.png" alt="image-20220207125543005"></p><p>按照教材意思 比对 boot反汇编的代码和  gdb调试的代码</p><p>boot返汇编的代码在这，比对了下 objdump 反汇编的出的风格还是 Intel的， 和gdb 调试也差多少 ，从 0x7c00开始一步一看吧</p><p><img src="/C:/Users/hrp/AppData/Roaming/Typora/typora-user-images/image-20220207131053481.png" alt="image-20220207131053481"></p><p>boot.o 反汇编的代码  </p><p><img src="http://imt.rui.vin/202202071312659.png" alt="image-20220207131245606"></p><p>当调试到 这一步时  地址为 0x7c2d时候  ，提示现在处于 i386状态（32位下）<br><img src="http://imt.rui.vin/202202071712150.png" alt="image-20220207171214490"></p><p>在反汇编的代码中 也可以看出 7c2d 后有 伪指令 .code32  意为切换到32位模式<br><img src="http://imt.rui.vin/202202071714386.png" alt="image-20220207171406343"></p><p> 关于  elf  得新开一个章节  来描述 </p><p>这里加载从磁盘里加载内核 ，怎么加载呢？结合elf 头 的信息，看要读多少<br><img src="http://imt.rui.vin/202202072048503.png" alt="image-20220207204857874"></p><p>这里是 把内核 读到  内存里并执行<br>首先有个问题是怎么读？  （这里涉及到elf 的内容，elf  详细内容不在该章节细说）<br>elf 头 我们已经从 磁盘中读到内存了，目前只是elf 的头部读到内存了，但是 elf 所包含的程序段 没有读到内存里，所以呢，</p><p><img src="http://imt.rui.vin/202202072222329.png" alt="image-20220207222201306"></p><h4 id="Exercise-4"><a href="#Exercise-4" class="headerlink" title="Exercise 4."></a><strong>Exercise 4.</strong></h4><p>​检查下你的对指针的运用，就是指针运用基础，注意下 不同类型的<strong>指针的步长</strong></p><h4 id="Exercise-5，6"><a href="#Exercise-5，6" class="headerlink" title="Exercise 5，6"></a><strong>Exercise 5，6</strong></h4><p>debug 查看从 boot 加载 kernel 的过程，这些可以对照boot.o 反汇编的文件和  kernel的反汇编文件逐步调试对照，就可以清楚的知道了</p><h3 id="Part-3-The-Kernel"><a href="#Part-3-The-Kernel" class="headerlink" title="Part 3: The Kernel"></a>Part 3: The Kernel</h3><p>这部分开始讲 虚拟内存，开始之前再重新 把前面的内容捋一遍！</p><p>qemu启动，执行 从boot 代码段执行，<br>从内存地址  0x7c00 处开始执行代码<br>关闭中断，开启 A20线， 开起gdt<br>调用  bootmain 函数<br>加载 内核文件 到内存里<br>    首先是  加载 elf头<br>    根据elf 头提供的信息，把elf文件中的 程序段加载到对应的内存中<br>（不是很详细，后续再补充 ）</p><p>​跳到  elf 的入口函数 entry<br><img src="http://imt.rui.vin/202202081115742.png" alt="image-20220208111501673"></p><hr><p>Part3 讲的是虚拟内存 和 物理内存的映射，在这把那些细节 描述的很清楚，给了个结论，让我们去验证下， </p><h4 id="Exercise-7"><a href="#Exercise-7" class="headerlink" title="Exercise 7"></a><strong>Exercise 7</strong></h4><p>验证     物理地址转换虚拟地址</p><p>执行 movl %eax, %cr0  后就开启了 分页  ，可以看到地址不同</p><p><img src="/C:/Users/hrp/AppData/Roaming/Typora/typora-user-images/image-20220208112758744.png" alt="image-20220208112758744"></p><p><img src="http://imt.rui.vin/202202081130876.png" alt="image-20220208113037678"></p><p>执行  <code>movl %eax, %cr0</code> 前  0xf0100000 内存都是空的<br><img src="http://imt.rui.vin/202202081138946.png" alt="image-20220208113823730"></p><p>执行后   0x 100000 映射到了 0xf0100000<br><img src="http://imt.rui.vin/202202081138735.png" alt="image-20220208113835668"></p><h4 id="Formatted-Printing-to-the-Console"><a href="#Formatted-Printing-to-the-Console" class="headerlink" title="Formatted Printing to the Console"></a>Formatted Printing to the Console</h4><p>Read through <code>kern/printf.c</code>, <code>lib/printfmt.c</code>, and <code>kern/console.c</code>, and make sure you understand their relationship. It will become clear in later labs why <code>printfmt.c</code> is located in the separate <code>lib</code> directory.<br>看这些 源码，print 实现也大同小异，相对于  《JamesM’s kernel development tutorials 》 ，我觉的后者 print实现 比较容易理解！可以去参考下</p><p><strong>Exercise 8</strong><br>    print 有个 %o 没实现，就是  数字按照 8进制打印出来 ，下图仿照 %x 输出 写了个，就是换个参数..</p><p><img src="http://imt.rui.vin/202202081331383.png" alt="image-20220208133154527"></p><p>os 最开始的运行时，有打印一个<br><img src="http://imt.rui.vin/202202081334699.png" alt="image-20220208133403998"></p><p>没修过前是 输出 </p><p><img src="http://imt.rui.vin/202202081335987.png" alt="image-20220208133514813"></p><p>添加 %o 输出后   15254 是 8进制，转成 10 进制 6828</p><p><img src="http://imt.rui.vin/202202081336048.png" alt="image-20220208133607963"></p><p>很多细节，先放下，后续再补…</p><h3 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h3><h4 id="Exercise-9"><a href="#Exercise-9" class="headerlink" title="Exercise 9"></a><strong>Exercise 9</strong></h4><p>看 栈的初始地址 在哪里</p><p><img src="http://imt.rui.vin/202202081530984.png" alt="image-20220208153047528"></p><p>从以上 代码可以看到  初始化了esp 和 edp，这函数调用的深入下也可以写很多东西，先挖个坑吧….<br>初始化后  看下两个寄存器的 值<br><img src="http://imt.rui.vin/202202081651635.png" alt="image-20220208165110291"></p><p>可以得出 栈的地址是冲 0xf0110000 开始的</p><p>esp 指向了栈的指针 ， bootstacktop 的定义我们可以看下 （合理  运用 ide ，我是用 vscode全局查的）</p><p><img src="/C:/Users/hrp/AppData/Roaming/Typora/typora-user-images/image-20220208165822004.png" alt="image-20220208165822004">  </p><p>可以的出 栈的大小为    8 * 4096  字节  （SPACE申请一片内存空间）…..</p><p>带更新,,,</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS实现-其实</title>
    <link href="/2022/02/05/OS%E5%AE%9E%E7%8E%B0-%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
    <url>/2022/02/05/OS%E5%AE%9E%E7%8E%B0-%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p><img src="http://imt.rui.vin/image-20220205193221144.png" alt="image-20220205193221144"></p><p>好久前就有所了解这个 mit6.828 ，但只是走马观花 看了下，趁着毕设（无可奈何），高强度把这个拿下！</p><p>毕设选的题目是  内核设计，实现一个内核，开始 看了 很多关于os书籍，主要看的是  操作系统真相还原，开头引人入胜，后面  …举步维艰..   于是转战     《JamesM’s kernel development tutorials》 这个确实比较适合入门, 好像有点开窍，<br>可能有前面的基础，如此再回来 看mit6.868 ，又是不一样的感觉！</p><p>接下来按照 这个来课表  的顺序来 的顺序来   <a href="https://pdos.csail.mit.edu/6.828/2018/schedule.html">课程表</a>  </p><p>总之现在以 官网的教材来一步一步走（当然也要参考网上的）</p><p>教材看了后  我会我我自己的理解 重新表达一遍，当然不是纯粹的翻译，所以可能会有多偏差，也希望大家多多指正！  </p><hr>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mit6.828</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go 引用mod后 import报错问题</title>
    <link href="/2022/01/28/import%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/28/import%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>期初 在我的分支 项目一直使用 gopath  后面 pull主分支了之后（多人协作），就无法 import了，主分支使用mod管理包的，由于对 mod不了解，也折腾了好久…</p> <span id="more"></span><h3 id="解决的方案"><a href="#解决的方案" class="headerlink" title="解决的方案 :"></a>解决的方案 :</h3><ol><li><p>清空 gopath 路径</p></li><li><p>在项目目录中  用命令  go mod tidy   （同步 模块代码），但总是获取失败，应该是 服务器在国外，于是切换镜像</p></li><li><p>export GOPROXY&#x3D;<a href="https://mirrors.aliyun.com/goproxy/">https://mirrors.aliyun.com/goproxy/</a></p></li></ol><p><img src="/import%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/image-20220128112531481.png" alt="image-20220128112531481"></p>]]></content>
    
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git使用</title>
    <link href="/2022/01/16/git%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/01/16/git%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>遇到   giithub.com port 443 after 21076 ms: Timed out  无法push代码  </p><p>重置全局代理</p>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些面试题目（待填坑）</title>
    <link href="/2022/01/16/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <url>/2022/01/16/%E4%B8%80%E4%BA%9B%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="一、C-基础知识面试题总结"><a href="#一、C-基础知识面试题总结" class="headerlink" title="一、C++基础知识面试题总结"></a>一、C++基础知识面试题总结</h2><h3 id="1、多态的实现"><a href="#1、多态的实现" class="headerlink" title="1、多态的实现"></a>1、多态的实现</h3><p>​我自己的理解：<br>​多态即多种状态，主要用途在于经由一个共同的接口来影响类型的封装，接口通常被定义一个抽象的基类中，共享的接口通过虚函数的机制，可以在对象执行的时候根据对象的类型解析出到底是哪个函数实例调用的<br>​动态多态是 通过虚函数实现的<br>​静态多态是 通过函数重载和 函数模板实现</p><p>2、说说C&#x2F;C++的区别<br>     c： 面向过程<br>     c++ : 面向对象  -&gt;  OOP语言  -&gt; 设计模式 </p><pre><code class="hljs"> 动态内存分配上：new malloc</code></pre><p>​扩展名</p><p>3、const关键字</p><p>​</p><p>4、说说malloc&#x2F;free 和 new&#x2F;delete区别</p><p>​new的几种方式</p><p>​ new : 普通的new操作，一旦内存分配失败，直接抛出一个异常，需要用catch来处理这种异常信息。</p><p>​new(nothrow) : 不抛出异常的new操作， 一旦内存分配失败，禁止抛出异常，而是返回一个NULL,可以通过判断指针是不是NULL来处理这种异常。</p><p>​placement new : <strong>直接复用已经分配好内存的指针的new操</strong>作，该操作只是会调用构造函数，将这部分内存重新做初始化操作。</p><p>作者：灰常出色<br>链接：<a href="https://www.jianshu.com/p/9b57e769c3cb">https://www.jianshu.com/p/9b57e769c3cb</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>5、指针和引用的区别</p><p>6、C++中堆和栈的区别</p><p>7、关键字static</p><p>8、在C++程序中调用被C语言修饰的函数，为什么要加extern “C”</p><p>9、如何防止头文件被重复包含</p><p>​用#ifdefine<br>​#end</p><p>10、什么是内存泄漏？什么是野指针？什么是内存越界？如何避免？</p><p>11、描述一下封装、继承、多态</p><p>12、堆栈缓存方式的区别</p><p>13、STL容器有哪些，常用的算法</p><p>14、什么是面向对象</p><p>15、用过的设计模式，简单举几个例子</p><p>16、如何理解智能指针,什么时候改变引用计数</p><p>17、share_ptr与weak_ptr的区别与联系</p><p>18、表述下string的Copy-On-Write技术，写时copy</p><p>19、描述下C++的浅copy，深copy，写时copy和引用计数的copy</p><p>20、C++构造函数是否可以抛出异常</p><p>21、是否在析构函数抛出异常</p><p>22、构造函数中，成员变量一定要通过初始化列表来初始化的</p><p>23、volatile的作用</p><p>24、构造函数和析构函数可以调用虚函数吗</p><p>25、内存对齐的原则</p><p>26、内联函数有什么优点？内联函数和宏定义的区别</p><p>27、数组与指针的区别与联系，函数指针，指针函数，指针数组，数组指针</p><p>28、STL set 和 map都是基于什么实现的</p><ul><li><p>set ：  只有value 没有 key  ，基于红黑树，具有<strong>自动排序的功能</strong>，因此map内部所有的数据，在任何时候，都是有序的</p></li><li><p>unordered_set ： 基于哈希表，数据插入和查找的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存，<strong>无自动排序功能</strong></p></li><li><p>unordered_map:  内部实现了一个哈希表，排列顺序是无序的</p></li><li><p>map：  key 和 value   红黑树</p></li></ul><p>​</p><p>29、常见的内存错误及其对策</p><p>30、三种内存对象的比较</p><p>​堆对象，栈对象以及静态对象</p><p>31、C++内存泄露及检测工具</p><p>32、什么时候要用虚析构函数</p><p>33、#include&lt;a.h&gt; 与#include”a.h”的区别</p><p>34、什么是RTTI (Run-time type identification)</p><p>35、引用作为函数参数有哪些特点</p><p>36、在什么时候需要使用常引用</p><p>37、将引用作为函数返回值类型的格式、好处和需要遵守的规则</p><p>38、结构体和联合体的区别</p><p>39、重载和重写的区别</p><p>40、栈内存与文字常量区</p><p>41、struct和class的区别</p><p>42、如何判断浮点数是否相等，LONG呢</p><p>43、不允许重载的5个运算符</p><p>44、拷贝构造函数在哪几种情况下会被调用</p><p>45、什么时候必须重写拷贝构造函数</p><p>46、静态成员函数存在的意义</p><p>47、流运算符为什么不能通过类的成员函数重载</p><p>48、当一个类中没有任何成员变量和成员函数，这时sizeof(A)的A值是多少，</p><p>49、如果不是零，请解释一下编译器为什么没有让他为零</p><p>50、多态的作用</p><p>51、什么函数不能声明为虚函数</p><ol><li><p>构造函数</p><p> 虚表指针的初始化时在构造函数进行的，而虚函数需要放到虚表中。在调用虚函数前，必须首先知道虚表指针，所以不行</p></li><li><p>普通函数</p><p> 虚函数需要在继承多态下使用才有意义</p></li><li><p>静态函数</p><p> 静态函数可以直接调用不需要指针</p></li><li><p>内联函数</p><p> 内联函数属于静态联编，即是编译阶段就确定调用哪个函数了，虚函数是动态联</p></li><li><p>友元函数</p><p> 有元函数不支持继承</p></li></ol><p>52、系统会自动和关闭的3个标准的文件是</p><p>53、说出字符常量和字符串常量的区别，并使用sizeof 计算有什么不同</p><p>54、Windows消息系统由哪几部分构成</p><p>55、assert()的作用</p><p>56、Windows的消息机制</p><p>57、SendMessage和PostMessage的区别</p><p>58、Dll和lib的区别</p><p>59、多线程如何实现通讯，如何进行同步</p><p>60、stl实现了那些排序算法</p><p>61、一元、二元仿函数的区别和使用背景</p><p>62、智能指针可以放到容器中么</p><p>63、请简述Windows内存管理的方式</p><p>64、strcpy和memcpy使用时的注意事项，strncpy、memncpy的区别</p><p>65、const和static能同时修饰成员函数吗</p><p>66、何时编译器会自动生成默认构造函数</p><p>67、何时编译器会自动生成拷贝构造函数</p><p>68、动态链接库和静态链接库的区别</p><p>69、描述一下函数调用的整个过程</p><p>70、C++ STL vector的实现机制</p><p>71、面向对象是一种思想，如何使用C语言来实现</p><p>72、C++有哪些数据类型，为什么long和int都是4字节</p><p>73、Java和C++的区别是什么，分别用在什么场景比较好</p><p>74、函数调用类型_cedecl,_stdcall,_fastcall</p><p>75、什么是序列化和反序列化</p><p>76、用预处理指令声美一个常数，用以表明1年终有多少秒</p><p>77、strtok函数在使用上要注意什么问题</p><p>78、char * const p ,char const * p,  char const * const p区别</p><p>79、介绍一下右值引用和移动语义和完美转发</p><p>80、说说你使用的C++11的特性</p><p>81、如何区分左值和右值</p><p>82、为什么C++访问虚函数比访问普通函数慢</p><p>83、为什么需要纯虚函数</p><p><del>84、内联函数、构造函数、静态成员函数可以是虚函数么</del></p><p>85、析构函数可以调用虚函数，构造函数为什么不可以调用虚函数</p><p>86、析构函数可以是纯虚的么</p><p>87、为什么需要虚继承，虚继承的实现原理</p><p>88、迭代器和普通自指针有什么区别</p><p>89、C++4种类型转换</p><p>90、如何定义一个只能在堆上创建的类，如何定义一个只能在栈上创建的类</p><p>91、标准库函数和系统调用的区别</p><p>92、如何区分一段代码是C++还是C代码编写的</p><p>93、什么是回调函数，回调函数的使用场景</p><p>94、临时对象在什么时候会产生</p><p>95、说一下C++的返回值优化</p><p>96、protected,public,private在继承中的可见性</p><p>97、C++中为什么用模板类</p><p>98、子类不能继承父类的函数有哪些</p><p>99、虚函数的内存结构，菱形继承的虚函数内存结构</p><p>100、谈谈stl标准库的线程安全性</p><p>101、成员函数里memset(this,0,sizeof(*this))会发生什么</p><p>102、share_ptr的线程安全性</p><p>103、vector资源释放</p><h2 id="二、线程进程面试题总结"><a href="#二、线程进程面试题总结" class="headerlink" title="二、线程进程面试题总结"></a><strong>二、线程进程面试题总结</strong></h2><p>1、程序什么时候应该使用线程，什么时候单线程效率高</p><p>2、惊群现象</p><p>3、C++函数内的静态变量初始化以及线程安全问题</p><p>4、C++线程安全的单例类</p><p>5、多线程环境带有状态的对象的讨论</p><p>6、C++多线程加volatile的错误认识</p><p>7、并行编程中多进程和多线程，什么情况下多进程能解决的多线程无法解决</p><p>8、如何证明一个数据结构是线程安全的</p><p>9、lock-free的实现方式</p><p>10、锁的实现方式</p><p>11、多线程编程的时候，使用无锁结构会不会比有锁结构更加快</p><p>12、linux线程是如何进行切换的</p><p>13、Linux 开发，使用多线程还是用 IO 复用 select&#x2F;epoll</p><p>14、异步，多线程和并行的区别</p><p>15、Linux 下多线程和多进程程序的优缺点，各自适合什么样的业务场景</p><p>16、开发多线程的程序应该注意哪些问题</p><p>17、如何测试线程池的性能</p><p>18、死锁的原因和避免</p><p>19、如何理解互斥锁，条件锁，读写锁以及自旋锁</p><p>20、互斥锁，同步锁，临界区，互斥量，信号量，自旋锁之间联系是什么</p><p>21、pthread_cond_wait 为什么需要传递 mutex 参数</p><p>22、多线程网络编程中如何合理地选择线程数</p><p>23、malloc和free是线程安全的吗，在多线程开发时用这两个函数应该注意什么</p><p>24、僵尸进程和孤儿进程有什么区别、如何处理</p><p>25、Linux系统中 进程 、线程 、时间片的关系</p><p>26、在Linux系统中，对于用户创建的进程(线程)来说，CPU分配时间片的单位是线程还是进程</p><p>27、内核级调度和用户级调度</p><p>28、Linux中进程具有父子层次结构，Windows中没有进程层次，这两种设计各有什么优劣</p><p>29、linux用户级进程跟内核线程（进程）有什么差别</p><p>30、为什么要区分用户态和内核态</p><p>31、从用户空间到内核空间有以下触发手段</p><p>32、进程的内存空间布局</p><p>33、进程间通信（IPC）方式</p><p>34、进程空间和内核空间对内存的管理不同</p><p>35、虚拟内存的作用</p><p>36、虚拟内存的实现</p><p>37、Linux的slab层</p><p>38、fork与vfork区别</p><p>39、exit()与_exit()区别</p><p>40、Linux是如何避免内存碎片的</p><p>41、共享内存的实现原理</p><p>42、银行家算法</p><p>43、linux中断响应机制</p><p>44、如何实现守护进程 </p><p>45、32位系统一个进程最多有多少堆内存</p><p>46、线程安全和不安全的讨论</p><p>47、可重入函数与线程安全的区别与联系</p><p>48、双重检查锁定模式(DCLP)的风险</p><p>49、内存屏障详解</p><p>50、原子操作原理</p><p>51、Linux有内核级线程么</p><p>52、使用线程是如何防止出现大的波峰</p><p>53、操作系统中进程调度策略有哪几种</p><p>54、线程与进程的区别和联系 线程是否具有相同的堆栈 dll是否有独立的堆栈</p><p>55、读者-写者问题</p><p>56、哲学家进餐问题</p><p>57、进程状态的切换图</p><h2 id="三、TCP-x2F-IP网络编程面试题总结"><a href="#三、TCP-x2F-IP网络编程面试题总结" class="headerlink" title="三、TCP&#x2F;IP网络编程面试题总结"></a><strong>三、TCP&#x2F;IP网络编程面试题总结</strong></h2><p>1、网络体系结构</p><p>2、TCP和UDP有什么区别</p><p>3、编写socket套接字的步骤</p><p>4、TCP三次握手和四次挥手，以及各个状态的作用</p><p>5、Http协议和TCP的区别</p><p>6、同步IO和异步IO的区别</p><p>7、什么是IOCP</p><p>8、什么是网络套接字(Socket)?流套接字(SOCK_STREAM)基于什么协议</p><p>9、IP首部、TCP首部、UDP首部、以太网首部</p><p>10、TCP和UDP的应用场景</p><p>11、如何实现可靠的UDP</p><p>12、详细说明TCP状态迁移过程</p><p>13、2MSL是什么状态？作用是什么</p><p>14、三次握手为什么不是两次或者四次</p><p>15、TCP重发机制</p><p>16、说说Nagle算法</p><p>17、TCP拥塞控制</p><p>18、TCP的滑动窗口</p><p>19、域名解析的过程</p><p>20、ARP的机制</p><p>21、RARP的实现</p><p>22、http&#x2F;https 1.0 1.1 2.0的特点和区别</p><p>23、Get&#x2F;post的区别</p><p>24、Http返回状态码</p><p>25、Http协议相关头</p><p>26、浏览器中输入一个URL发生什么，用到那些协议</p><p>27、五种IO模型</p><p>28、select,poll,epoll的区别</p><p>29、UDP中一个包的大小最大能多大</p><p>30、Time_wait,close_wait状态产生的原因，keeplive</p><p>31、列举你所知道的TCP选项</p><p>32、Connect会阻塞检测及防止，socket什么情况下可读 </p><p>33、如果select返回可读，结果只读到0字节，什么情况</p><p>34、socket什么情况下可读</p><p>35、Keepalive是什么东西，如何使用</p><p>36、UDP使用connect的好处</p><p>37、各层对应的网络设备（路由器、交换机、网关、网桥、集线器等），各层对应的协议</p><p>38、数据链路层的CSMA&#x2F;CD协议</p><p>39、IP地址的分类，子网划分</p><p>40、TCP精髓问题：停止等待协议、连续ARQ协议 </p><p>41、HTTP缓存机制（cache-control、Expires之类的一系列请求与相应的报头字段</p><p>42、session和cookied 区别，禁用cookie后怎么办</p><p>43、常用协议的端口</p><p>44、三层交换机和路由器的区别</p><p>45、什么是TCP的自连接，如何解决</p><p>46、单播、多播（组播）和广播的区别</p><p>47、当应用程序调用Send之后怎么判断对方是否成功接收</p><p>48、静态路由和动态路由各自的优缺点</p><p>49、路由器和交换机的不同之处有哪些</p><p>50、为什么有时ping服务器第一包丢失</p><p>51、tcp 阻塞socket send recv需要注意的操作</p><p>52、TCP封包和拆包</p><p>53、怎样理解阻塞非阻塞与同步异步的区别</p><p>54、epoll：EPOLLLT和EPOLLET的区别</p><p>55、epoll事件驱动框架使用注意事项</p><p>56、Linux-socket的close和shutdown区别及应用场景</p><p>57、TCP带外数据</p><p>58、网桥的作用</p><p>59、防火墙的端口防护</p><p>60、有哪些私有保留地址</p><p>61、Ping命令使用的那种报文</p><p>62、两台笔记本电脑连起来后ping不通，你觉得有哪些问题造成的</p><p>63、Vlan的特点</p><p>64、ICMP是属于什么协议，处于那一层</p><p>65、IP组播有什么好处</p><p>66、DNS欺骗的方式</p><p>67、reactor和proactor的区别</p><p>68、两台机器A-B进行TCP通讯，进程崩溃会怎么样进程死锁会怎么样进程或机器过载，反应变慢会怎么样进程死循环，拼命发消息会怎么样机器重启会怎么样机器死机会怎么样机器网卡抽风，丢包严重会怎么样交换机或路由器坏了或过载会怎么样路由器过热重启会怎么样A和B之间的带宽被别的服务占用了会怎么样如何诊断以上这些情况。如果A和B之间有防火墙，还会出哪些情况。</p><p>69、Linux 中每个 TCP 连接最少占用多少内存</p><p>70、TCP 能否发送0字节的数据包</p><p>71、tcp 协议中为什么syn会消耗一个序号</p><p>72、tcp&#x2F;ip数据包在互联网传输过程中，有哪些头会保持不变</p><p>73、linux&#x2F;unix socket编程并发时什么时候用进程（fork），什么时候用线程（池）</p><p>74、如何测量网络发送速度</p><p>75、如果将同一个listening socket加入多个epoll， 是不是一种合理的设计？</p><p>76、Tcp客户端的正确关闭方式</p><p>77、对一个已经关闭了的socket 的Server 调用write操作</p><p>78、怎样实时判断socket链接状态</p><p>79、socket套接字在多线程发送数据时要加锁吗</p><p>80、TCP中已有SO_KEEPALIVE选项，为什么还要在应用层加入心跳包机制</p><p>81、TCP 协议下 socket 有可能丢包吗</p><p>82、如何理解 TCP&#x2F;IP, SPDY, WebSocket 三者之间的关系</p><p>83、为什么每台电脑都要设置子网掩码</p><p>84、为什么以太网无法接收大于1500字节的数据包</p><p>85、OSI七层模型中，每一层的数据包都是谁生成和解包的</p><p>86、为什么网关与主机可以不在同一个网段</p><p>87、NAT和DHCP 的区别是什么</p><p>88、OSI模型中，一个协议应该属于哪一层是以什么为标准划分的</p><p>101、TCP三次握手的过程，seq的变化是一直都是加1吗</p><p>102、使用Linuxepoll模型，水平触发模式；当socket可写时，会不停的触发socket可写的事件，如何处理</p><p><strong>四、Linux操作面试题</strong></p><p>1、与CPU、内存、磁盘相关的命令（top free df fdisk）</p><p>2、与网络相关的命令netstat , tcpdump等</p><p>3、sek，awk,grep三个强大的命名，分别用与格式化修改，统计，和正则查找</p><p>4、ipcs和ipcrm命令</p><p>5、查找当前目录以及字母下以.c结尾的文件，且文件中包含”hello world”的文件的路径</p><p>6、创建定时任务</p><p>7、gdb用法</p><p>8、linux的内存管理机制</p><p>9、&#x2F;proc存在哪里</p><p>10、Linux状态分析：CPU（top）、内存（top和free，注意buffer和cache区别）、磁盘（fdisk和df）、IO（iostat）等</p><p>11、shell脚本</p><p>12、Linux目录结构</p><p>13、linux中断响应机制</p><p>14、linux文件系统结构和启动流程</p><p>15、防火墙iptables</p><p>16、轮询任务调度和抢占式任务调度的区别</p><p>17、查看进程ps ps aux</p><p>18、删除进程kill -9</p><p>19、查看进程树pstree</p><p>20、查看占用端口的进程netstat netstat -anp | grep port</p><p>21、正则表达式grep printf awk</p><p>22、管线指令 ls -al &#x2F;etc | less</p><p>23、sort 进行排序</p><p>24、双向输出重定向</p><p>25、打包压缩</p><p>26、目录的 inode 与 block</p><p>27、实体链接与符号链接</p><p>28、文件系统的组成</p><p>29、文件与目录的基本操作</p><p>30、文件属性以及权限的修改</p><p>31、分区</p><p>32、内核模块的位置在哪里</p><p>33、SMTP, DNS, FTP, DHCP, SSH 和 squid 使用的默认端口号是哪些</p><p>34、Linux中不同的网络绑定模式有哪些</p><p>35、如何检查默认路由以及路由表</p><p>36、在Linux 中什么是平均负载</p><p>37、请描述Linux系统优化的12个步骤</p><p>38、描述Linux下软链接和硬链接的区别</p><p>39、描述Linux下文件删除的原理</p><p>40、给出正确的关机和重启服务器的命令</p><p>41、请简述修改&#x2F;etc&#x2F;sudoers配置文件的注意事项</p><p>42、如果一台办公室内主机无法上网（打不开网站），请给出你的排查步骤</p><p>43、请简述Linux启动过程中几个重要配置文件的执行过程</p><p>44、请输出你知道的20 个LINUX 命令及作用</p><p>45、企业中Linux服务器系统分区标准是什么</p><p>46、某一天突然发现Linux系统文件只读，该怎么办呢？完整操作步骤</p><p>47、某一天误操作，执行了rm-rf* ，会有哪些情况发生？请举例</p><p>48、一般可以使用什么软件远程linux服务器？通过什么上传文件和下载文件</p><p>49、Linux内核引导时，从哪个文件中读取要加载的文件系统</p><p>50、Linux文件系统中每个文件用 i节点 来标识</p><p>51、简述网络文件系统NFS，并说明其作用</p><p>52、简述DNS进行域名解析的过程</p><p>53、简述Linux文件系统通过i节点把文件的逻辑结构和物理结构转换的工作过程</p><p>54、nfs 协议用于实现Unix（&#x2F;linux）主机之间的文件系统共享</p><p>55、欲发送10个分组报文测试与主机abc.tuu.edu.cn的连通性，应使用的命令和参数</p><p>56、进程的运行有两种方式，即独立运行和使用父进程运行</p><p>57、vi编辑器具有两种工作模式命令模式和输入模式</p><p>58、vi的使用</p><p>59、内核分为进程管理系统内存管理系统I&#x2F;O管理系统和文件管理系统等四个子系统</p><p>60、安装Linux系统对硬盘分区时，必须有两种分区类型：文件系统分区和交换分区</p><p><strong>五、数据结构与算法</strong></p><p>1、单链表的逆置</p><p>2、常见排序算法和稳定性，效率分析</p><p>3、静态链接和动态链表的区别</p><p>4、海量数据处理的知识点</p><p>5、AVL树和R-B树的查找，插入，删除的效率,区别  &#x2F;&#x2F;数据结构的内容</p><p>​AVL 是二叉查找查找树的升级版，自带平衡算法，左右子树高度不超过1 ，红黑树就是AVL树，但是红黑树 附带了几条规则</p><p>6、判断一个链表是否存在循环</p><p>7、寻找最大的K个数</p><p>8、统计数组中出现最多的数</p><p>9、字符串匹配</p><p>10、二分查找</p><p>11、实现Strcpy</p><p>12、实现快速排序</p><p>13、建堆，建堆的时间复杂度</p><p>14、HASH策略常见的有哪些</p><p>15、HASH表实现</p><p>16、二叉树结构，二叉查找树的实现</p><p>17、二叉树的六种遍历</p><p>18、二叉树的按层遍历</p><p>19、编写简单的String类</p><p>20、编写strcpy、strcat、strcmp、memcpy、memmove</p><p>21、求二叉树的深度</p><p>22、判断一棵二叉树是否是平衡二叉树</p><p>23、求二叉树第K层节点个数</p><p>24、求二叉树中两个节点的最大距离</p><p>25、判断一棵二叉树是否为完全二叉树</p><p>26、重建二叉树，依据前序遍历结果和中序遍历结果</p><p>27、实现简单的智能指针</p><p>28、实现stl::string的写时copy</p><p>29、什么是大小端模式，编写代码区分大小端</p><p>30、链表的插入删除、单向链表、双向链表</p><p>31、反向打印链表</p><p>32、打印倒数第K个节点</p><p>33、链表是否有环</p><p>34、冒泡、选择、插入、快速、归并、堆排序、希尔、桶</p><p>35、背包问题</p><p>36、深度优先、广度优先、单源最小路径、任意两点最小路径</p><p>37、最大堆、最小堆、堆如何调整</p><p>38、两个有序数组求中位数</p><p>39、最长上升子序列</p><p>40、海量数据排序</p><p>41、链表翻转</p><p>42、最长公共子序列</p><p>43、海量数据topk问题</p><p>44、蓄水池抽样算法</p><p>45、排序算法性能比较，时间复杂度、稳定性、比较</p><p>46、1-100之间所有素数之和</p><p>47、队列的实现</p><p>48、字符串匹配</p><p>49、数组存储超大数</p><p>50、回文字符串</p><p>51、判断两个数组是否有相同的数字</p><p>52、大数据中找中位数</p><p>53、B树、B+树、红黑树、AVL树</p><p>54、单链表排序</p><p>55、查找链表中间节点</p><p>56、删除无头非尾节点</p><p>57、约瑟夫环</p><p>58、如何从100万个数中找出最大的前100个数</p><p>59、找出数组中重复的数字</p><p>60、计算斐波那契数列</p><p>61、滑动窗口的最大值</p><p>62、0~n-1 中缺失的数字</p><p>63、连续子数组的最大和</p><p>64、删除链表中重复的节点</p><p>65、矩阵中的路径</p><p>66、调整数组顺序使奇数位于偶数前面</p><p>67、最长不重复子串</p><p>68、天平不平衡找假币问题</p><p>69、栈的逆序</p><p>70、数组的逆序对</p><p>71、二叉搜索树的第K个节点</p><p>72、树上最远距离</p><p>73、折纸问题</p><p>74、根据前序和中序遍历求后序</p><p>75、完全二叉树判断、平衡二叉树判断、二叉查找树判断</p><p>76、荷兰国旗问题</p><p>77、字符串-全排列问题</p><p>78、无环链表判断相交</p><p>79、用两个栈实现队列</p><p>80、最大连续数列和</p><p>81、矩阵取值问题</p><p>82、最大和子矩阵</p><p>83、最长公共子序列和最长递增子序列</p><p>84、最小编辑代价</p><p>85、动态规划和递归-魔术索引</p><p>86、确定字符串互异</p><p>87、基本字符压缩</p><p>88、空格替换</p><p>89、确定两个字符串乱序同构</p><p>90、A+B问题</p><p>91、尾部的零</p><p>92、第K大元素</p><p>93、有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序，来求出一共有多少种走法。</p><p>94、一个有getMin功能的栈</p><p>95、从上往下打印二叉树的每个节点，同层节点从左到右</p><p>96、最长单词（Lintcode）</p><p>97、单例（Lintcode）</p><p>98、Fizz Buzz问题（LintCode）</p><p>99、二分查找</p><p>100、N皇后问题</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vector扩容</title>
    <link href="/2022/01/16/vector%E6%89%A9%E5%AE%B9/"/>
    <url>/2022/01/16/vector%E6%89%A9%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
