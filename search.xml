<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>go</title>
    <url>/2022/01/03/go/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/12/25/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>postName</title>
    <url>/2021/12/26/postName/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>hexo的用法记录</title>
    <url>/2022/01/03/hexo%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<ol>
<li><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2></li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>postName1</title>
    <url>/2021/12/26/postName1/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>postName4</title>
    <url>/2021/12/26/postName4/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>postName3</title>
    <url>/2021/12/26/postName3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>如何在hexo上创建一篇文章</title>
    <url>/2021/12/26/%E5%A6%82%E4%BD%95%E5%9C%A8hexo%E4%B8%8A%E5%88%9B%E5%BB%BA%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h3 id="1-链表反转"><a href="#1-链表反转" class="headerlink" title="1.链表反转"></a>1.链表反转</h3><span id="more"></span> 

<ul>
<li>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</li>
</ul>
<p>​    <strong>示例:</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>


<p><strong>限制：</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 &lt;= 节点个数 &lt;= 5000</span><br></pre></td></tr></table></figure>


<p>解法一  暴力：</p>
<p>​            遍历链表的每个节点，每遍历个节点就用头插法插入一个新的链表里</p>
<p>​            时间复杂度为 T(n^2)   空间复杂度为O(n)</p>
<p>解法二：  迭代</p>
<p>​    不生成新的链表，把链表的指向的方向反过来</p>
<p>假设链表为 1 -&gt;2  -&gt; 3 -&gt;∅     1→2→3→∅，我们想要把它改成  ∅←1←2←3。</p>
<p>在遍历链表时，将当前节点的指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p>
<p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1621751662409.png" alt="1621751662409"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;	</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">    	ListNode* cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">    	&#123;</span><br><span class="line">    		ListNode* T = cur-&gt;next;</span><br><span class="line">            cur-&gt;next =pre;</span><br><span class="line">            pre =cur;</span><br><span class="line">            cur = T;</span><br><span class="line">    	&#125;  <span class="comment">//画图解决</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<hr>
<h3 id="2-删除倒数第k个结点"><a href="#2-删除倒数第k个结点" class="headerlink" title="2.删除倒数第k个结点"></a>2.删除倒数第k个结点</h3><p>​         给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p>
<p><img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], n = 2</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure>


<p><strong>解法一</strong> ： 遍历整个链表后，算出结点数，反推正序第几个 O(N) N 为链表的长度 ，T（N)</p>
<p><strong>解法二</strong> ：双指针，一个前指针一个指针，前指针先走n步，然后 后指针和前指针一起走，前指针走到尾后，后指针指向待删除节点的前一部分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);  <span class="comment">//设置一个虚拟的前置结点</span></span><br><span class="line">		pre-&gt;next = head;</span><br><span class="line">		ListNode* h1 = pre; <span class="comment">//前指针</span></span><br><span class="line">		ListNode* h2 = pre; <span class="comment">//后指针</span></span><br><span class="line">        ListNode* temp = <span class="literal">nullptr</span>; </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n+<span class="number">1</span>; ++i)</span><br><span class="line">			h1 = h1-&gt;next;</span><br><span class="line">		<span class="keyword">while</span> (h1)</span><br><span class="line">		&#123;</span><br><span class="line">			h1 = h1-&gt;next;</span><br><span class="line">			h2 = h2-&gt;next;</span><br><span class="line">		&#125;	</span><br><span class="line">	    temp = h2-&gt;next;</span><br><span class="line">		h2-&gt;next = h2-&gt;next-&gt;next;</span><br><span class="line">	    <span class="keyword">delete</span> temp;</span><br><span class="line">	    head = pre-&gt;next;</span><br><span class="line">	    <span class="keyword">delete</span> pre;</span><br><span class="line">		<span class="keyword">return</span> head;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<hr>
<h3 id="3-盛最多水的容器（双指针）"><a href="#3-盛最多水的容器（双指针）" class="headerlink" title="3.盛最多水的容器（双指针）"></a>3.<a href="https://leetcode-cn.com/problems/container-with-most-water/">盛最多水的容器（双指针）</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span><br></pre></td></tr></table></figure>


<p><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,8,6,2,5,4,8,3,7]</span><br><span class="line">输出：49 </span><br><span class="line">解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><br></pre></td></tr></table></figure>


<p>解法一：暴力求解</p>
<p>​            遍历每一个容器， 时间复杂度O（n^2)</p>
<p>解法二：  <strong>双指针</strong> </p>
<ul>
<li><p>一个指针在头，一个指针在后，分别向中间靠拢，如何移动呢（移动的条件）？</p>
</li>
<li><p>那个指针指向的值比较小就先移动那个.</p>
</li>
<li><p>容器的大小<br />min（头，尾） * （头到尾直接的距离）<br />为啥移动小的呢？<br />容器的大小取决于最小的那个板，移动最大的那个板子，容器只会变得最小或者不变（板子可能变大，容器大小不变，板子变小若是比原来较小的那个板子还小，容器则会变得更小）移动较大的那个板子则是可能变大，会不会错过同个长度的其他搭配呢？其实我也没琢磨透…</p>
</li>
<li><p>代码</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> l = <span class="number">0</span>, r = height.<span class="built_in">size</span>() - <span class="number">1</span>;<span class="comment">//减一是要换成逻辑地址下标</span></span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>; </span><br><span class="line">		<span class="keyword">while</span> (l&lt;r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> area = <span class="built_in">min</span>(height[l], height[r]) * (r - l);</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, area);</span><br><span class="line">			<span class="keyword">if</span> (height[l] &lt; height[r])</span><br><span class="line">				l++;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				r--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<h3 id="4-冒泡排序"><a href="#4-冒泡排序" class="headerlink" title="4.冒泡排序"></a>4.冒泡排序</h3><p>​    今天去面试，笔试要写个冒泡排序，这题应该信手拈来的，可我还推了那么久！！不行啊！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maopao</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; x)</span>	</span>&#123;		<span class="keyword">int</span> i, y;		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; x.<span class="built_in">size</span>() - <span class="number">1</span>; i++)		&#123;			<span class="keyword">for</span> ( y = <span class="number">0</span>; y &lt; x.<span class="built_in">size</span>()<span class="number">-1</span> - i; y++)			&#123;				<span class="keyword">if</span> (x[y] &gt; x[y + <span class="number">1</span>])				&#123;					<span class="built_in">swap</span>(x[y], x[y + <span class="number">1</span>]);				&#125;			&#125;				&#125;		<span class="keyword">return</span> x;	&#125;</span><br></pre></td></tr></table></figure>


<p>时间复杂度为O( n^2）  两遍循环</p>
<hr>
<h3 id="5数组中重复的数字"><a href="#5数组中重复的数字" class="headerlink" title="5数组中重复的数字"></a>5数组中重复的数字</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">找出数组中重复的数字。在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例 1：输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 </span><br></pre></td></tr></table></figure>


<p>解法1 :  用set容器（该容器没有重复的数字），遍历vector ，遍历一个插入一个，插入失败则是重复的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;	 <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());		 		 <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; nums.<span class="built_in">size</span>(); x++) 			<span class="keyword">if</span> (nums[x] == nums[x + <span class="number">1</span>]) 				<span class="keyword">return</span> nums[x + <span class="number">1</span>];      <span class="keyword">return</span> <span class="number">0</span>;     &#125;; </span><br></pre></td></tr></table></figure>


<p>解法2： 原地交换，有0- n-1个数字， 每个数都对应一个下标 i，当然 下标 i 不一定等于  nums[i],</p>
<p>若是等于的话，则有可能一个下标对应很多个数，</p>
<p><img src="C:%5CUsers%5Cadmin%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1622255058092.png" alt="1622255058092"></p>
<p>遍历每一个数，将其数值作为下标，即</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nums[nums[i]] = nums[i];</span><br></pre></td></tr></table></figure>


<p>这样一来就做到  数值就是其索引值</p>
<p>继续遍历 ，若是发现  交换时   索引值对应的数值已经存在了，则说明有重复的了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (nums[nums[i]]== nums[i])	return nums[i];</span><br></pre></td></tr></table></figure>


<p>看代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;       <span class="keyword">int</span> i = <span class="number">0</span>;		<span class="keyword">while</span> (i&lt;nums.<span class="built_in">size</span>())  <span class="comment">//遍历		&#123;			if (nums[i] == i)  //判断索引值和当前的值是否对应			&#123;				i++;		//是，则继续遍历下一个				continue;			&#125;				if (nums[nums[i]] == nums[i])  //核心： 判断是否有重复                							//判断当前的值 和以当前值为索引的所对应的值是否相等				return nums[i];			swap(nums[i], nums[nums[i]]);	//不相等，则交换			i++;		&#125;		return -1;    &#125;</span></span><br></pre></td></tr></table></figure>


<h3 id="6-二叉树的三种遍历"><a href="#6-二叉树的三种遍历" class="headerlink" title="6.二叉树的三种遍历"></a>6.二叉树的三种遍历</h3><h4 id="递归-和迭代的方法"><a href="#递归-和迭代的方法" class="headerlink" title="递归 和迭代的方法"></a><strong>递归</strong> 和迭代的方法</h4><h4 id="前序-（根左右）"><a href="#前序-（根左右）" class="headerlink" title="前序  （根左右）"></a>前序  （根左右）</h4><p>递归：先往左边一直遍历，遍历一个抽一个，，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">forn_tree</span><span class="params">(TreeNode* root,vector&lt;<span class="keyword">int</span>&gt;&amp; res)</span> </span>&#123;		<span class="keyword">if</span> (root = <span class="literal">NULL</span>)    <span class="comment">//递归出口 该节点不存在			return ;  //遍历每一个元素都是根节点		res.push_back(root-&gt;val);  //遍历每一个元素都是根节点		forn_tree(root-&gt;left, res);		forn_tree(root-&gt;right, res);		&#125;vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123;	vector&lt;int&gt; res;	forn_tree(root, res);  //递归函数	return res;&#125;</span></span><br></pre></td></tr></table></figure>


<p>利用栈来完成递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;	vector&lt;<span class="keyword">int</span>&gt; res;		stack&lt;TreeNode*&gt; s;		<span class="keyword">while</span> (!s.<span class="built_in">empty</span>() || root)		&#123;			<span class="keyword">if</span> (root)			&#123;				res.<span class="built_in">push_back</span>(root-&gt;val);				s.<span class="built_in">push</span>(root);				root = root-&gt;left;			&#125;			<span class="keyword">else</span>			&#123;				root = s.<span class="built_in">top</span>();				s.<span class="built_in">pop</span>();	    		root = root-&gt;right;			&#125;		&#125;        <span class="keyword">return</span> res;	&#125;</span><br></pre></td></tr></table></figure>


<h4 id="中序-（左根右）"><a href="#中序-（左根右）" class="headerlink" title="中序  （左根右）"></a>中序  （左根右）</h4><p>同上，递归遍历，问题是何时打印出来该节点  总结：跟在哪里就先打印哪里，如中序  根在左右节点中间</p>
<p>所以， 先遍历左边，一直往左遍历，到最左边的时候打印节点，然后往右遍历</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;		vector&lt;<span class="keyword">int</span>&gt; res;		<span class="built_in">inorderTraversal_tree</span>(root, res);		<span class="keyword">return</span> res;	&#125;	<span class="function"><span class="keyword">void</span> <span class="title">inorderTraversal_tree</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span> </span>&#123;		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>)			<span class="keyword">return</span> ;		<span class="built_in">inorderTraversal_tree</span>(root-&gt;left, res);		res.<span class="built_in">push_back</span>(root-&gt;val);		<span class="built_in">inorderTraversal_tree</span>(root-&gt;right, res);&#125;</span><br></pre></td></tr></table></figure>


<p>使用栈来递归：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;	vector&lt;<span class="keyword">int</span>&gt; res;	stack&lt;TreeNode*&gt; s;	<span class="keyword">while</span> (!s.<span class="built_in">empty</span>() || root)	&#123;		<span class="keyword">if</span> (root)		&#123;			s.<span class="built_in">push</span>(root);			root = root-&gt;left;		&#125;		<span class="keyword">else</span>		&#123;			root = s.<span class="built_in">top</span>();			s.<span class="built_in">pop</span>();			res.<span class="built_in">push_back</span>(root-&gt;val);			root = root-&gt;right;		&#125;	&#125;&#125;</span><br></pre></td></tr></table></figure>


<h4 id="后续-（左右根）"><a href="#后续-（左右根）" class="headerlink" title="后续 （左右根）"></a>后续 （左右根）</h4><p>原理同上</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;		vector&lt;<span class="keyword">int</span>&gt; res;		<span class="built_in">inorderTraversal_tree</span>(root, res);		<span class="keyword">return</span> res;	&#125;	<span class="function"><span class="keyword">void</span> <span class="title">postorderTraversal_tree</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt; &amp;res)</span> </span>&#123;		<span class="keyword">if</span> (root == <span class="literal">nullptr</span>)			<span class="keyword">return</span> ;		<span class="built_in">postorderTraversal_tree</span>(root-&gt;left, res);			<span class="built_in">postorderTraversal_tree</span>(root-&gt;right, res);        	res.<span class="built_in">push_back</span>(root-&gt;val);&#125;</span><br></pre></td></tr></table></figure>


<p>使用栈来递归：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123;		vector&lt;int&gt; res;		inorderTraversal_tree(root, res);		return res;&#125;</span><br></pre></td></tr></table></figure>


<h3 id="7-合并两个有序链表"><a href="#7-合并两个有序链表" class="headerlink" title="7. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">7. 合并两个有序链表</a></h3><p>将两个升序链表合并为一个新的 <strong>升序</strong>  链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>
<p>思路：</p>
<p>​            两个链表，建立一个新的头结点，每次比较两个链表当x较大小，那个小则头结点指向那个（尾插法），当前节点值小的链表则指向下一个节点，空间复杂度为O（1），没有用到额外的空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;public:  ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123;    ListNode* preHead = new ListNode(-1);    ListNode* prev = preHead;	while (l1 != nullptr &amp;&amp; l2 != nullptr) &#123;	if (l1-&gt;val &lt; l2-&gt;val) &#123;		 prev-&gt;next = l1;	     l1 = l1-&gt;next;	    &#125; else &#123;    prev-&gt;next = l2;    l2 = l2-&gt;next;   &#125;    prev = prev-&gt;next; //尾插法  &#125;   // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可   prev-&gt;next = (l1 == nullptr ? l2 : l1);    return preHead-&gt;next;  &#125;</span><br></pre></td></tr></table></figure>


<h3 id="8-合并K个升序链表"><a href="#8-合并K个升序链表" class="headerlink" title="8.合并K个升序链表"></a>8.合并K个升序链表</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p>
<p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]输出：[1,1,2,3,4,4,5,6]解释：链表数组如下：[  1-&gt;4-&gt;5,  1-&gt;3-&gt;4,  2-&gt;6]将它们合并到一个有序链表中得到。1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure>


<p>多个链表升序，也才用合并两个链表的思路来，用一个临时链表ans来保存两个链表合并后的结果，然后遍历每一个有序链表</p>
<p>没有用到额外的空间，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">twoLists1</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;		ListNode* preHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);		ListNode* prev = preHead;		<span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;			<span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;				prev-&gt;next = l1;				l1 = l1-&gt;next;			&#125;			<span class="keyword">else</span> &#123;				prev-&gt;next = l2;				l2 = l2-&gt;next;			&#125;			prev = prev-&gt;next; <span class="comment">//尾插法		&#125;		// 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可		prev-&gt;next = l1 == nullptr ? l2 : l1; //三则表达式   如果l1为空了，则l2还有		return preHead-&gt;next;	&#125;ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123;	  ListNode *ans = nullptr;		int len = lists.size();		for (int i = 0; i &lt; len; i++)&#123;			ans = twoLists1(ans, lists[i]); //遍历每一个链表		&#125;		return ans;	&#125;</span></span><br></pre></td></tr></table></figure>


<h3 id="9-有效的括号"><a href="#9-有效的括号" class="headerlink" title="9.有效的括号"></a>9.<a href="https://leetcode-cn.com/problems/valid-parentheses/">有效的括号</a></h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">给定一个只包括 <span class="string">&#x27;(&#x27;</span>，<span class="string">&#x27;)&#x27;</span>，<span class="string">&#x27;&#123;&#x27;</span>，<span class="string">&#x27;&#125;&#x27;</span>，<span class="string">&#x27;[&#x27;</span>，<span class="string">&#x27;]&#x27;</span> 的字符串 s ，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。</span><br></pre></td></tr></table></figure>


<p>思路：</p>
<p>​    利用堆栈的特性（FIFO） ，遍历字符串每一个元素时，逐个入栈，一定是左括号的先入栈</p>
<p>遍历到右括号则检查栈的顶部是否匹配，匹配则出栈，为了方便建立对应 哈希表 方便判断出 左右括号是否匹配，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span> <span class="keyword">public</span>:  <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;    <span class="keyword">int</span> x = <span class="number">0</span>, z = <span class="number">0</span>, d = <span class="number">0</span>;    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();       <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) <span class="comment">//括号肯定为偶数      return false;      //建立无序表 逐一做匹配    unordered_map&lt;char, char&gt; pairs = &#123;    &#123;&#x27;)&#x27;, &#x27;(&#x27;&#125;,    &#123;&#x27;]&#x27;, &#x27;[&#x27;&#125;,     &#123;&#x27;&#125;&#x27;, &#x27;&#123;&#x27;&#125;    &#125;;    stack&lt;char&gt; stk;    for (auto ch : s) //遍历字符串元素    &#123;      if (pairs.count(ch))  //判断改字符是否为右括号      &#123;       if (stk.empty() || stk.top() != pairs[ch])  //若果栈空了或者栈顶的右括号和刚遍历的左括号不匹配则返回false          return false;        stk.pop(); //匹配成功则把出栈，把栈顶匹配完成的元素去掉      &#125;     else &#123;        stk.push(ch);//没有遍历到右括号则出栈      &#125;    &#125;     return stk.empty();  &#125;&#125;;</span></span><br></pre></td></tr></table></figure>


<h3 id="10-斐波那契数列"><a href="#10-斐波那契数列" class="headerlink" title=" 10. 斐波那契数列"></a><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/"> 10. 斐波那契数列</a></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：F(0) = 0,   F(1) = 1F(N) = F(N - 1) + F(N - 2), 其中 N &gt; 1.斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</span><br></pre></td></tr></table></figure>


<p>递归的接法：</p>
<p>​        将大问题分解成若干个小问题</p>
<p>​        F(5)= F(4)+F(3);</p>
<p>​        F(4)=F(3)+F(2)…..</p>
<p>​        以此类推</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;	<span class="keyword">if</span> (n &lt;= <span class="number">0</span>)		<span class="keyword">return</span> <span class="number">0</span>;	<span class="keyword">if</span> (n == <span class="number">1</span>)		<span class="keyword">return</span> <span class="number">1</span>;	<span class="keyword">return</span> <span class="built_in">fib</span>(n - <span class="number">1</span>) + <span class="built_in">fib</span>(n - <span class="number">2</span>);&#125;</span><br></pre></td></tr></table></figure>


<p>非递归的接法（从下往上，求出每个数 ,时间复杂度 O(n)）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib_1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;	<span class="keyword">int</span> arr[<span class="number">2</span>] = &#123; <span class="number">0</span>,<span class="number">1</span> &#125;;	<span class="keyword">int</span> pre = <span class="number">0</span>;	<span class="keyword">int</span> now = <span class="number">1</span>;	<span class="keyword">int</span> next = <span class="number">0</span>;	<span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">2</span>; i &lt;= n; ++i)	&#123;		next = pre + now;   <span class="comment">//用next 保留两个数相加的和		pre = now;			//pre 和 now 变量向前推进		now = next;	&#125; 			return next;&#125;</span></span><br></pre></td></tr></table></figure>


<p>也可以用以下的方法（和上面的思路一样，只是采用了数组的形式，很妙！）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;	arr[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;      arr[i &amp; <span class="number">1</span>] = (arr[<span class="number">0</span>] + arr[<span class="number">1</span>]) % (<span class="keyword">int</span>)(<span class="number">1e9</span> + <span class="number">7</span>);    &#125;    <span class="keyword">return</span> arr[n &amp; <span class="number">1</span>];  <span class="comment">//n &amp;1 的用意是： 定位到数组的小标 ， n&amp;1 的值只能为 0 或 1  &#125;</span></span><br></pre></td></tr></table></figure>


<p>11.青蛙跳台阶（和斐波那契数列一样）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。</span><br></pre></td></tr></table></figure>


<p>青蛙可以跳一步或者两步  顶一个函数  f（n）  n表示台阶</p>
<p>​    跳第一个台阶的时候，有一种选择 f(1)，跳第二台阶的时候 f(2) ，有两种选择，跳第三个的时候，第二台阶到第三个台阶只有一种选择–跳一个；第一个台阶到第三台阶跳两个，需要考虑的是当前阶梯数 n 和 n -2 和n与n-2之间的的数目  f（n） = f（n-1） +f ( n -2 )</p>
<p>f(3) = f(2)+f(1)  这样就是斐波那契数列啦，可以用递归，但重复计算很多</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int numWays(int n) &#123;  if(n ==0)   	return 1;  else if(n ==1)    return 1;  else if(n ==2)    return 2;  int pre = 1;  int now = 2;  int next = 0;  for (int i =3; i &lt;= n; ++i)  &#123;      next = (pre + now)%(int(1e9+7));  //用next 保留两个数相加的和 	  pre = now%(int(1e9+7));     //pre 和 now 变量向前推进      now = next%(int(1e9+7));  &#125;      return next;&#125;</span><br></pre></td></tr></table></figure>


<h3 id="11-二分查找"><a href="#11-二分查找" class="headerlink" title="11.二分查找"></a>11.二分查找</h3><p>二分查找是针对<strong>有序数列</strong> 的，对无序数列是无效的，在有序序列中使用二分查找能大大提高查找效率，通常能将时间按复杂度从       <strong>O(n)降至O(logn)</strong> </p>
<p>eg:</p>
<p>在一个有序数组中查找某个元素的位置</p>
<ul>
<li>递归</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_gui</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;	<span class="keyword">int</span> right = r;	<span class="keyword">int</span> left = l;	<span class="keyword">int</span> mid  = left + (right - left) / <span class="number">2</span>;			<span class="keyword">if</span> (right &lt; left)		<span class="keyword">return</span> <span class="number">-1</span>;	<span class="keyword">if</span> (nums[mid] &lt; target)		<span class="built_in">se_gui</span>(nums, target,mid + <span class="number">1</span>,r);	<span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)		<span class="built_in">se_gui</span>(nums, target, l, mid- <span class="number">1</span>);	<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target)		<span class="keyword">return</span> mid;		&#125;		</span><br></pre></td></tr></table></figure>


<ul>
<li>非递归</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- int search1(vector&lt;int&gt;&amp; nums, int target) &#123;		int len = nums.size() - 1;		int left = 0, right = len;		int mid;		while (left &lt; right)		&#123;			mid = left + (right - left) / 2;			if (nums[mid] &lt; target)				left = mid + 1;			else if (nums[mid] &gt; target)				right = mid - 1;			else				return mid;						&#125;		return -1;	&#125;</span><br></pre></td></tr></table></figure>


<p>相关题目：</p>
<p>​    在升序的序列中找到指定数字出现的次数</p>
<h3 id="12-查找两个链表的相同节点（）"><a href="#12-查找两个链表的相同节点（）" class="headerlink" title="12.查找两个链表的相同节点（）"></a>12.查找两个链表的相同节点（）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) &#123;	ListNode* At = headA;	ListNode* Bt = headB;	while (At!=Bt)	&#123;		if (At != nullptr)			At = At-&gt;next;		else        	At =headB;        			if (Bt == nullptr)			Bt = Bt-&gt;next;		else			Bt = headA;	&#125;	return Bt;&#125;</span><br></pre></td></tr></table></figure>


<h3 id="13-排序大总结"><a href="#13-排序大总结" class="headerlink" title="13.排序大总结"></a>13.排序大总结</h3><p>快排（被问了好几次…）</p>
<p>复杂度是O（nlogn）</p>
<p>思路是：</p>
<p>​    每一次的遍历把首元素放到他应该在的位置</p>
<p>如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5，1 ，4，3</span><br></pre></td></tr></table></figure>


<p>​        5 的位置应该是  在四位的，第一轮目标就时要包5 放在第四位，其他的不用管</p>
<p>其它的数字 经过一轮的排序后，会以选定数字的为轴，大的右边，小的在左边；</p>
<p>​      以定位好的数字为轴，对左边的数字在重复一次以上的操作，对右边的也是，这就是用到递归了;</p>
<p>递归的层数越多是时间复杂度也越大，   平均的时间复杂度是 nO(logn)</p>
<p>n 代表层数，  logn带边每层遍历的次数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; sortArray_1(vector&lt;int&gt;&amp; nums) &#123;	int high = nums.size() - 1;	QSort(nums, 0, high);	return nums;&#125;void QSort(vector&lt;int&gt; &amp;nums,int low,int high)&#123;	int mid;	if (low &lt; high)  	&#123;		mid = Partition(nums, low, high);		QSort(nums, low, mid - 1); //递归左边的		QSort(nums, mid + 1,high); //递归右边的	&#125;&#125;int Partition(vector&lt;int&gt;&amp; nums,int low,int high)&#123;	int r = high;	int l = low;	int std = nums[l]; //选定需要定位的目标数	while (l &lt; r)  //首尾各自开始向中心靠齐	&#123;	//要从后面开始，判断数字是否大于目标数，知道遇到大于的		while (l &lt; r &amp;&amp; nums[r] &gt;= std)  		&#123;			r--;		&#125;		//然后交换数字		swap(nums[l], nums[r]);		//然后在来左边 		while (l &lt; r &amp;&amp; nums[l] &lt;= std)		&#123;			l++;		&#125;//同理		swap(nums[l], nums[r]);	&#125;	return l;&#125;</span><br></pre></td></tr></table></figure>


<h3 id="14-2n-1个数字，找出一个不对的数字"><a href="#14-2n-1个数字，找出一个不对的数字" class="headerlink" title="14. 2n+1个数字，找出一个不对的数字"></a>14. 2n+1个数字，找出一个不对的数字</h3><h3 id="15-1000瓶药水有一瓶毒药，怎么快速检测出来（可用小白鼠）"><a href="#15-1000瓶药水有一瓶毒药，怎么快速检测出来（可用小白鼠）" class="headerlink" title="15.1000瓶药水有一瓶毒药，怎么快速检测出来（可用小白鼠）"></a>15.1000瓶药水有一瓶毒药，怎么快速检测出来（可用小白鼠）</h3><p>讲一千瓶药水用二进制排序，2的10次方 为1024 故需要10位</p>
<p>00000 00000    1</p>
<p>00000 00001    2</p>
<p>00000 00010    3</p>
<p>…..</p>
<p>1111101000    1000</p>
<p>有10 位，我们用10只老鼠（每个老鼠都有编号 0-9）来检测，    瓶子序号中，第n位为1（n的取值为（0~9）） ，就用给对应编号为 n 的老鼠喝 如：</p>
<p>00001 00001       第0 位和第5位为1 ，则用调 编号 为 0 和 5的老去和药水</p>
<p>最后看是那些老鼠死了，死老鼠的序号，对应二进制的第几位，如 编号 二 和 三老鼠死了，  则二进制  为 0110  ，该编号对应的药水的编号，就是有毒的了</p>
<h3 id="16-接雨水"><a href="#16-接雨水" class="headerlink" title="16.接雨水"></a>16.接雨水</h3><p>给定 <em>n</em>  个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p>思路：</p>
<ul>
<li>暴力解法<br />判断每个柱子能否装水，得看柱子左右两边的柱子 ，水的高度取决于最短的<br />并且中间的柱子也有高度，所以也要减去当前柱子（即中间的柱子）的高度<br />每一个柱子 装水量为<br />​     s =  min（left，right） - mid<br />总结： 遍历每一个柱子，取柱子左边最高的柱子，柱子右边最高的柱子，然后以左右两边最低的为标准来计算</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Solution &#123;public:  int trap(vector&lt;int&gt;&amp; height) &#123;  int n = height.size();  int ans = 0;  //遍历每一个柱子  for (int i = 1; i &lt; n - 1; i++) &#123;   int l_max = 0, r_max = 0;    // 找右边最高的柱子   for (int j = i; j &lt; n; j++)    r_max = max(r_max, height[j]);    // 找左边最高的柱子    for (int j = i; j &gt;= 0; j--)    l_max = max(l_max, height[j]);    // 如果自己就是最高的话，    // l_max == r_max == height[i]    ans += min(l_max, r_max) - height[i];  &#125;  return ans;  &#125;&#125;;</span><br></pre></td></tr></table></figure>


<h3 id="17-top-k-问题"><a href="#17-top-k-问题" class="headerlink" title="17 . top k 问题"></a>17 . top k 问题</h3><p>在n个无序的数据中，找到最大的k个数据</p>
<p>解法 一:</p>
<ul>
<li>完全排序好，取前k个数据</li>
</ul>
<p>解法 二：</p>
<ul>
<li>用快排思想排序， 每次排序都定位一个数的位置，假设这个数下标为 X ，在X左边的数都比X小，右边的都比X大，右边的数若干好是k个的话，就说明k个的数就是答案，有分为三情况</li>
</ul>
<ol>
<li>X 右边的数 正好是 k个</li>
</ol>
<p>&ensp;&ensp;&ensp;&ensp;- 就说明k个的数就是答案</p>
<ol start="2">
<li>X 右边的数 小于 k 个</li>
</ol>
<p>&ensp;&ensp;&ensp;&ensp;- X右边的数肯定是 k个数字中的，剩下的 k-（n-x） 个数字肯定是在 下标X的左边，X 左边的数据再继续划分，知道 划分右边的数据 和 剩下的 k-（n-x） 个数据数量相同时</p>
<ol start="3">
<li>X 右边的数 大于 k个</li>
</ol>
<p>&ensp;&ensp;&ensp;&ensp;- k个数字中的是在X的右边，但是但是有 n-x -k个 不符合条件，同理</p>
]]></content>
      <categories>
        <category>LeetCode 刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
