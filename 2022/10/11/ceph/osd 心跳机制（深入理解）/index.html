

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/R.png">
  <link rel="icon" href="/img/R.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Rui">
  <meta name="keywords" content="">
  
    <meta name="description" content="使用场景   在分布式系统中有很多节点，节点数量多了，各种异常就会经常发生，如：宕机、磁盘损坏、网络故障等；如果集群的某个节点出现什么故障是难以知道的；还有就是监测各个节点的健康状况，快速定位集群中的异常节点。 心跳机制是什么 通俗解释： 客户端每隔 N秒发送心跳数据包给服务端，正常来说在M秒内，服务端会回复客户端消息，若是 服务端大于M秒内没回复，则客户端会认为是出现心跳超时的异常，客户端会进一">
<meta property="og:type" content="article">
<meta property="og:title" content="osd 心跳（深入理解）">
<meta property="og:url" content="http://example.com/2022/10/11/ceph/osd%20%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%EF%BC%88%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%EF%BC%89/index.html">
<meta property="og:site_name" content="后台开发技术总结">
<meta property="og:description" content="使用场景   在分布式系统中有很多节点，节点数量多了，各种异常就会经常发生，如：宕机、磁盘损坏、网络故障等；如果集群的某个节点出现什么故障是难以知道的；还有就是监测各个节点的健康状况，快速定位集群中的异常节点。 心跳机制是什么 通俗解释： 客户端每隔 N秒发送心跳数据包给服务端，正常来说在M秒内，服务端会回复客户端消息，若是 服务端大于M秒内没回复，则客户端会认为是出现心跳超时的异常，客户端会进一">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://img.rui.vin/202209190006673.png">
<meta property="article:published_time" content="2022-10-11T12:11:39.000Z">
<meta property="article:modified_time" content="2023-02-18T10:10:37.835Z">
<meta property="article:author" content="Rui">
<meta property="article:tag" content="ceph">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://img.rui.vin/202209190006673.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>osd 心跳（深入理解） - 后台开发技术总结</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.1","typing":{"enable":true,"typeSpeed":70,"cursorChar":".","loop":false,"scope":[],"Options":"home | post | tag | category | about | links | page | 404"},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"C++"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":false,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":"ture","follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Rui</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://api.dujin.org/bing/1366.php') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="osd 心跳（深入理解）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-10-11 20:11" pubdate>
          October 11, 2022 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          6.9k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          58 mins
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> views
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">osd 心跳（深入理解）</h1>
            
            <div class="markdown-body">
              
              <h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>   在分布式系统中有很多节点，节点数量多了，各种异常就会经常发生，如：宕机、<strong>磁盘损坏</strong>、网络故障等；如果集群的某个节点出现什么故障是难以知道的；还有就是监测各个节点的健康状况，快速定位集群中的异常节点。</p>
<h3 id="心跳机制是什么"><a href="#心跳机制是什么" class="headerlink" title="心跳机制是什么"></a>心跳机制是什么</h3><p> 通俗解释： 客户端每隔 N秒发送心跳数据包给服务端，正常来说在M秒内，服务端会回复客户端消息，若是 服务端大于M秒内没回复，则客户端会认为是出现心跳超时的异常，客户端会进一步对超时异常做处理。<br>     以上只是一个大概的流程，在发送心跳的前后都需要做很多处理，对于收到的心跳包可能有很多种类型，需要分不同情况处理（后续会说明）；</p>
<h3 id="在ceph-中-能解决了什么问题"><a href="#在ceph-中-能解决了什么问题" class="headerlink" title="在ceph 中 能解决了什么问题"></a>在ceph 中 能解决了什么问题</h3><ul>
<li><p>osd之间互相检测健康情况，以便及时发现故障节点进入相应的故障处理流程，此外可以分担mon检测的压力</p>
</li>
<li><p>检测到  public和cluster  网络异常</p>
</li>
<li><p>发送心跳的前提是自身状态的是正常的，所以自身也会先检测：</p>
<ul>
<li><p>内部操作是否超时（内部线程的操作）</p>
</li>
<li><p>自身osdmap不与集群的一致</p>
</li>
<li><p>自身osd状态 检测</p>
</li>
</ul>
</li>
</ul>
<h3 id="osd-和osd-之间心跳"><a href="#osd-和osd-之间心跳" class="headerlink" title="osd 和osd 之间心跳"></a>osd 和osd 之间心跳</h3><img src="http://img.rui.vin/202210122013513.png" alt="image-20221009173539395" style="zoom: 33%;">	

<h3 id="mon和osd-之间"><a href="#mon和osd-之间" class="headerlink" title="mon和osd 之间"></a>mon和osd 之间</h3><ul>
<li>osd 会向 mon上报 超时的osd给mon，mon会根据 osd超时的上报数来决策 该超时的osd 状态</li>
</ul>
<img src="http://img.rui.vin/202210122013626.png" alt="image-20221012113736642" style="zoom: 33%;">	

<ul>
<li>osd  会每隔  osd_mon_heartbeat_interval  时间（30s）向mon获取最新的 epoch（Monitors 、 OSD 和 PG上的每一次状态变更的都会递增epoch数值） ，这个操作在一个定时器内进行</li>
</ul>
<p><img src="http://img.rui.vin/202210122013653.png" alt="image-20221012143544894">	</p>
<hr>
<p><strong>以下是心跳模块实现细节</strong></p>
<h3 id="osd-是如何选择发送对象"><a href="#osd-是如何选择发送对象" class="headerlink" title="osd 是如何选择发送对象"></a>osd 是如何选择发送对象</h3><p>在ceph 中 ，osd并没有广播式的向集群内所有osd发送心跳，因为这样会有心跳风暴对集群造成比较大的压力；osd每次发送心跳时发送的数量为 osd_heartbeat_min_peers（默认为10），这10个发送对象（peer osd） 并不是直接随机选取，而是有选取的规则，选取的  osd会保存在  heartbeat_peers  中；   以下有三种场景下会触发 刷新  heartbeat_peers  的函数</p>
<p>触发更新peer osd有两种方式 (本质上是更新标志位)：</p>
<ul>
<li>osd 刚启动时</li>
<li>距离上一次更新peer osd时间超时限定时间</li>
</ul>
<p>可以触发的场景：</p>
<ul>
<li>定时器内定期触发</li>
<li>handle_pg  </li>
<li>handle_map</li>
</ul>
<p>选取的规则（原则上尽可能选取到指定数量的osd）：</p>
<ul>
<li>在PG副本所在OSD的集合中选取   <strong>[可选]</strong></li>
<li>选取相邻的osd （eg: 当前osd id为5，则会尝试获取 6或者 4 ）  <strong>[必选]</strong></li>
<li>基于报错处理的原则： 需要来自至少两个不同的故障域的osd；所以会在指定的故障域下随机找两个osd；**[必选]**</li>
<li>每次发送的对象数量都有所限定，若是大于指定数量则会从 <strong>[可选]</strong> 集合中剔除掉osd；而太少则会从相邻的osd中再次选取</li>
</ul>
<p>问题：heartbeat_peer 会自动清掉吗？什么场景会 reset？</p>
<ul>
<li>会自动清楚掉但有条件；为了保证 heartbeat_peer  里面没有 “常驻” osd； 距离上一次更新peer osd时间超过限定时间时，会尝试去清除 heartbeat_peer 中的osd，其条件是在过去的十分钟内都没有对该osd发送过心跳，则这种条件下则会清除；因为10分钟都没更新很有可能这个osd已经down掉了；还有一种情况时 osd 主动shutdown时候，会全部清除掉（释放内存）</li>
</ul>
<p>问题：选取 peer osd时为什么要通过好几种方式来选择，直接在集群内随机选osd可以吗？ 会不会出现个别osd 一直没有选到的情况？？</p>
<ul>
<li><p>不能直接的随机选；心跳发送并不是广播式的，每次发送的数量是有限定的（避免集群压力过大）；在数量一定的情况下首先需要保证检测结果即准确又要快速</p>
<ul>
<li><p>【必要】从所在节点中选osd，这样检测本身节点的一个健康状况 （至少两个，后续发现数量不够会继续获取）</p>
</li>
<li><p>【必要】方便mon快速决策，满足报错处理的原则，随机选两个不同的故障域的osd （至多两个）</p>
</li>
<li><p>【补充】在PG副本所在OSD的集合中选取 （数量过多则从这里剔除）</p>
</li>
</ul>
</li>
</ul>
<h3 id="osd发送心跳实现"><a href="#osd发送心跳实现" class="headerlink" title="osd发送心跳实现"></a>osd发送心跳实现</h3><p>​	osd 会单独起一个线程来发送心跳，每隔6s发送一次（官方文档是这么说），但实际操作中是小于6的随机秒数，因为固定数值可能造成网络拥塞；然后遍历 一组osd，逐个发送心跳，发送的时候会先<strong>算好超时期限</strong>并保存起来，方便检测心跳超时；对于发送的内容是一个<strong>MOSDPing</strong>类的实例 ；对于集群内只有一个osd的情况每隔 osd_mon_heartbeat_interval 时间会更新osdmap。</p>
<img src="http://img.rui.vin/202210122013612.png" alt="image-20221012194234663" style="zoom: 50%;">	



<ul>
<li><p><strong>简要描述</strong> ：对于osd之间心跳传输，ceph使用了一个单独的线程来做处理，每隔6s向随机选取的osd发送 PING类型的心跳包；正常情况下osd 会在 <strong>osd_heartbeat_grace</strong> 时间内收到相应osd的 PING_REPLY 类型心跳回复，对于处理osd 的回复ceph 也是注册了message 回调函数专门来处理；若没在指定时间内收到，会将超时回复的osd上报给mon，交给mon来决策该超时osd的状态；</p>
</li>
<li><p>实现细节：</p>
<ul>
<li><p>发送前的准备</p>
<ul>
<li>获取 发送对象（peer osd）</li>
<li>根据发送对象（osd 的id）找到相应的ping记录，上次更新ping记录的时间和现在相隔超过一个钟（osd_mon_heartbeat_stat_stale 可设置），则需要清空osd的ping记录；</li>
<li>检测 osd 容量使用情况</li>
<li>计算并记录出此次心跳  回复的<strong>截止期限</strong>，以及记录发送心跳的时间点 （截止时间必须要，再检测超时的时候有用到）</li>
</ul>
</li>
<li><p>如何发送</p>
<ul>
<li>构造并发送PING类型 心跳包</li>
</ul>
</li>
<li><p>特殊处理</p>
<ul>
<li>没有发送对象（集群中可以只有一个osd）: 在自身状态正常下（active）每隔 osd_mon_heartbeat_interval时间 向mon 订阅更新osdmap</li>
</ul>
</li>
</ul>
</li>
<li><p>问题：  心跳线程中间隔时间发送是怎么实现的？sleep？定时器？需要考虑线程同步问题吗?</p>
<p>这里是使用了互斥锁和条件变量实现，间隔时间内，线程是休眠状态（此时会释放锁），达到间隔时间后会唤醒线程； 线程执行过程过程中 有heartbeat_lock 进行保护；</p>
</li>
<li><p>问题：  心跳间隔时间可以修改吗？ 时间大小对集群的影响是？</p>
<p>间隔时间可以 由于参数 osd heartbeat interval 设置，默认为6s，但实际上逻辑上实现是基于这个参数生成的随机值，发送的频率的高低会影响集群的性能，对于间隔时间的设置，设置的太短了，有可能会因为当前网络阻塞导致误判；设置的太长，会导致判断“迟缓”，固定的间隔时间也不是是权宜之计，索性就取一定时间内的随机值，一来可以使得发送的频率不会一直都是最高的，；二来随机的发送心跳，对检测结果正确性更有保障；</p>
</li>
<li><p>问题：  心跳线程有没有可能被内部 kill掉呢？</p>
<p>心跳线程的根据一个标志位来判断是否要继续执行，  从代码上看，在osd shutdown的时候会；</p>
</li>
</ul>
<h3 id="osd是如何检测超时的"><a href="#osd是如何检测超时的" class="headerlink" title="osd是如何检测超时的"></a>osd是如何检测超时的</h3><p>概述：  检测心跳回复超时也是在一个<strong>定时器</strong>中，具体操作是遍历 osd已经发送的心跳的对象（peer osd），根据osd 找到当时算好超时期限，并和现在时间做比较，如果小于已经是超时了，代码实现中只会挑出小于当前时间的记录做处理；对于超时的osd会添加到failure_queue里，接下来统一发给mon；</p>
<h3 id="osd-是何如上报给mon的"><a href="#osd-是何如上报给mon的" class="headerlink" title="osd 是何如上报给mon的"></a>osd 是何如上报给mon的</h3><ul>
<li><p>触发条件</p>
<p>上报mon也是在一个定时器里（同检测超时一个定时器），当前osd状态有变更的时候或者间隔时间大于osd_mon_report_interval 时就会触发上报mon</p>
</li>
<li><p>实现流程</p>
<p>遍历超时检测收集到的超时osd，然后构造 <strong>MOSDFailure</strong>类，发送给mon</p>
</li>
<li><p>问题 ：failure_queue  和 failure_pending 逻辑是怎么处理的？</p>
<ul>
<li><p>failure_queue 里保存了报错的osd，failure_pending 保存的是已经上报mon的osd（防止重复上报）；假如 failure_queue里面有osd.1的report，此时会验证failure_pending 里面有无osd.1 的记录，没有则会上报，并将osd保存到failure_pending中，若是failure_pending 有纪录，则不会上报，这样做可以避免重复上报；</p>
</li>
<li><p>failure_queue 是上报一次就清除一个（不管是否上报成功）</p>
</li>
</ul>
</li>
<li><p>问题： MOSDFailure 有几种类型，mon是怎么处理的？ </p>
<ul>
<li>FLAG_ALIVE： 当检测到异常的osd并上报后，后续又发现该异常的osd又正常了，需要重新告知mon，此时就需要FLAG_ALIVE 类型的 MOSDFailure </li>
<li>FLAG_FAILED： 上报  心跳超时 的异常osd时，默认使用 FLAG_FAILED</li>
<li>FLAG_IMMEDIATE： 并不是超时引起的异常，mon直接标记为dowm</li>
</ul>
</li>
</ul>
<h3 id="osd处理-心跳消息"><a href="#osd处理-心跳消息" class="headerlink" title="osd处理 心跳消息"></a>osd处理 心跳消息</h3><p> 其他osd发来的 心跳包</p>
<ul>
<li><p>心跳通知（PING）： 其他osd发来的 心跳检测</p>
<ul>
<li><p>回复前准备</p>
<ul>
<li>检测内部子系统健康（操作超时）</li>
</ul>
</li>
<li><p>构建并发送 PING_REPLY 包</p>
<ul>
<li>心跳回复的构造<ul>
<li>构造 MOSDPing::PING_REPLY 类型的心跳包</li>
<li>心跳回复包的大小限定，构造的时候可以指定包大小的最小值，没有满足会自动填充，这样做是在保证心跳包完整下，节省空间；</li>
</ul>
</li>
</ul>
</li>
<li><p>回复后的操作</p>
<ul>
<li><p>保存&#x2F;更新 发送方的epoch（从发来的消息中获取）</p>
</li>
<li><p>在自身osd状态为up下，验证当前osd的epoch 和发送方的epoch是否一致（原则是向新的靠拢）</p>
<ul>
<li>当前的epoch比发送方的大，会share给发送方</li>
<li>内部更新发送方的epoch</li>
</ul>
</li>
<li><p>从自身的osdmap中验证发送方的状态</p>
<ul>
<li>发送方不存在，会发送 YOU_DIED 类型的心跳包</li>
</ul>
</li>
</ul>
</li>
<li><p>问题：  回复心跳包前 检测内部子系统健康目的是什么？有什么设计细节？</p>
<ul>
<li><p>对于内部子系统（subsystems）健康机制都是由一个HeartbeatMap 类负责，每个子系统对应一个结构体，这些子系统初始化时将该结构体加入 HeartbeatMap 类中一个链表里以方便后续访问；每个结构体内部会定期更新  grace （容忍时间期限）；当我们需要验证内部子系统健康状态时，只需遍历HeartbeatMap中的 链表用以访问每个子系统，以现在的时间去逐个比较子系统 的grace，若是大于grace 则说明是超时了，此外这个步骤也会顺便验证 子系统的自杀时间，若超时也会杀掉子系统。</p>
<p>结合代码看，这些结构体 多数是由线程work注册的，work一些操作可能会超时…..</p>
</li>
</ul>
</li>
<li><p>问题：  心跳回复包的构造有个参数是指定 心跳回复包的最小大小，为什么要设计最小大小呢？</p>
<ul>
<li><p>默认值是2000，在处理解包信息时候，不足会自动填充，</p>
</li>
<li><p>至于设计的大小….</p>
</li>
</ul>
</li>
<li><p>问题：  回复才来来验证epoch，以及验证对方状态，这两者先后有什么区别呢？</p>
<ul>
<li><p>不管对方状况如何，都应该回复（总之收到了包就应该回复，不管对方是否收到），验证和回复先后顺序无所谓；也不会因为从当前map中发现对方异常而不回复（有可能是自身问题导致map有误？，而实际上对方是正常的）；后续验证主要对epoch 进行简单的同步，自身的epoch 比较大则会发送给对方</p>
</li>
<li><p>从自身的osdmap验证对方的存在，不存在则会发送YOU_DIED 类型的心跳包，告知对方已经died（多重验证）</p>
</li>
</ul>
</li>
<li><p>问题：  有无复现回复丢包的手段（比如发送不成功），以及内部子系统 出现问题无法回复的现象？</p>
<ul>
<li><p>模拟丢包率：osd_debug_drop_ping_probability 可以是设定丢包概率，也就是在检测内部子系统健康之前，做一个判断，实际就是跳过回复心跳流程从而实现丢包的场景</p>
</li>
<li><p>模拟内部子系统不健康场景： heartbeat_inject_failure 该参数设定是接下来时间内都是不健康的，实际就是验证健康之前会对这数值做比较</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>心跳回复（<strong>PING_REPLY</strong>）</p>
<ul>
<li><p>回复心跳包中带有该心跳发起的时间戳，在本地（osd内存）可以通过该时间戳来找到对应的心跳记录（每一次的心跳收发时间都会在本机有记录）从而更新收到心跳回复的时间（这是判断超时的关键），心跳回复的来源可能来自前端或者后端，更新接收时间前有对来源做区分；正常情况下，前后端的回复都收到后，会统计这次心跳收发的时长，并且也会记录到本地（方面后续统计收发的平均时长）；</p>
</li>
<li><p>在做完心跳接收时间的更新，会对当前收到心跳回复做一次超时检验（收到回复的时间和超时期限时间比较），这里只对非超时(正常)的回复做处理： 在检测超时回复的逻辑中，都会将超时的report 保存到一个 map中，我们这里暂且将这个map 称为failure_queue；如果回复是正常的，则会尝试在failure_queue找到以往的超时report（通过回复方的osd id找）并清楚掉；</p>
<p>为什么这样处理呢？ 给mon上报消息是有时间间隔的，假如osd.1的回复超时了被加入到report中，而在<strong>最新</strong>的心跳中osd.1的回复是正常的，如果此时还没有上报，会从failure_queue清楚掉osd.1的超时记录，这样可以使report更为准确（省资源）；</p>
</li>
</ul>
</li>
</ul>
<p>​     </p>
<ul>
<li><p>问题： 本地记录的心跳记录会不会重置的？</p>
<ul>
<li><p>会，在一个完整的心跳流程(即心跳发送了有回复)结束后，起始到现在的记录都会清除掉，在这个期间的心跳记录不管是否有完成了，都会清楚掉，因为最新的已经完成了，所以不用考虑以往的</p>
</li>
<li><p>osd 心跳的之间通信有专门的模块 message 来负责连接通信，当连接出问题时候，会重置message模块，此时会将心跳记录重新清楚掉</p>
</li>
</ul>
</li>
<li><p>问题： 对于心跳往返平均时间从哪里可以看到？取样的频率可以设定吗？</p>
<ul>
<li>amidn socke 提供了相应接口可以查看（ dump_osd_network），对于取样频率通过参数 debug_heartbeat_testing_span 可以调整（这值是采样得间隔时间，默认为0）</li>
</ul>
</li>
<li><p>问题： 为什么需要最后做超时验证呢？  </p>
<p> 使 failure_queue的存放的failure report更加准确</p>
</li>
<li><p>问题： failure_queue  和 failure_pending 区别</p>
<ul>
<li><p>failure_queue 里保存了报错的osd，failure_pending 保存的是已经上报mon的osd（防止重复上报）；假如 failure_queue里面有osd.1的report，此时会验证failure_pending 里面有无osd.1 的记录，没有则会上报，并将osd保存到failure_pending中，若是failure_pending 有纪录，则不会上报，这样做可以避免重复上报；</p>
</li>
<li><p>failure_queue 是上报一次就清除一个（不管是否上报成功）</p>
</li>
</ul>
</li>
<li><p>收到消息是 YOU_DIED</p>
<p>​	对方在osdmap 中找不到我，当收到这种类型的信息是需要主动从mon中获取最近osdmap</p>
</li>
</ul>
<h3 id="mon处理-failed-report"><a href="#mon处理-failed-report" class="headerlink" title="mon处理  failed report"></a>mon处理  failed report</h3><ul>
<li><p>处理 report 分为两步</p>
<ul>
<li><p>预处理</p>
<ul>
<li>验证report 来源（是谁上报的）</li>
<li>从 osdmap 中验证目标osd是否已经 dowm</li>
<li>从 osdmap 中校对 目标osd的IP地址（report 中有包含）</li>
<li>从 集群osd  up状态来判定，默认up状态的osd 所占集群总osd的比例为 0.3</li>
</ul>
</li>
<li><p>预更新</p>
<ul>
<li><p>验证 目标osd状态（期望是 up） 和  地址（通过osdmap中的记录的地址做匹配）</p>
</li>
<li><p>通过report 中osd 超时时间，反推出 osd异常的时间点（读去这个 report 的时间减去 osd超时时间，虽然不能很精确的定位到osd异常时间点，但可以保证是在这个时间段），根据这个时间点最终计算出 <strong>超时时间</strong></p>
<img src="/C:/Users/h00165/AppData/Roaming/Typora/typora-user-images/image-20221024142827258.png" alt="image-20221024142827258" style="zoom: 50%;">	


</li>
<li><p>mon 需要两个以上来自不同故障域osd上报，才能判定；如果osd处于同一个故障域，假如说是 rack级，若机柜出问题了则可能导致处于统一给故障域的osd与外界隔离（比如网络问题），此时上报可能会有误，为了校对这种情况，mon决策时会遍历每一条<strong>failure report</strong> ，将来自同一个故障域的当作一个report failure处理，这里故障域粒度可以由 mon_osd_reporter_subtree_level 指定；这种情况也不是百分百准确，还需要校对超时时间</p>
</li>
<li><p>对于超时时间也需要进行校对；每个osd down的时间都有记录，遍历 <strong>failure report</strong>时， 根据发送report的osd上一次down和现在的时间差来校对（我认为这样做是 弥补 故障域的误判）</p>
</li>
<li><p>问题：  为什么时间超时时间进行 “校对”？</p>
<p>有一种情况： 当mon通过 failure report 将有问题的osd 置为down之后，过了一会 该osd又正常了（反复这样就不乐观了），可能这个osd并不是真的有问题，可能这个o	sd就是慢半拍，如果可以稍微缩放一下容忍时间，可能就不会出现这种现象；但又不能单独为这个osd调节整体的容忍时间；为了“缓解”这个问题，通过每一次  osd down 到恢复正常的时间间隔推算出  “laggy” 的概率，通过这个系数来缩放 容忍时间；</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>&#x2F;&#x2F; mon -&gt; 方敏</p>
<hr>
<h3 id="其他问题汇总："><a href="#其他问题汇总：" class="headerlink" title="其他问题汇总："></a>其他问题汇总：</h3><p>问题： 其他辅助检测方式</p>
<ul>
<li><p>osd 周期性的（300s）发送信息给mon保活，需要构建 MOSDBeacon 类并发送给mon，mon会对这类信息做验证（通过osdmap验证），如果发现该osd是异常的，也会尝试 通知改osd自身处于异常状态</p>
</li>
<li><p>osd 主动关闭时，会构造  MOSDMarkMeDown  类信息发给mon，mon那边收到后 会验证消息来源后，将改osd置为down</p>
</li>
<li><p>osd 周期性检测 osd使用容量状态（FULL，BACKFILLFULL，NEARFULL），并将这个状态发送给mon</p>
</li>
<li></li>
</ul>
<p>问题： 心跳包中为什么要携带 epoch  </p>
<p>问</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/ceph/">#ceph</a>
      
    </div>
  
</div>


              

              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/12/11/%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%88%E5%A4%8D%E4%B9%A0%E7%AF%87%EF%BC%89/" title="关于指针的一些问题">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">关于指针的一些问题</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/10/01/ceph/osd%20%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/" title="osd 心跳">
                        <span class="hidden-mobile">osd 心跳</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments">
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.18/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"4tz8f6FTi0BVSOcKQPAnAAkg-gzGzoHsz","appKey":"ltYlWD7ItrDou5czyO7XrpbJ","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":true,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;Table of Contents</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        Views: 
        <span id="busuanzi_value_site_pv"></span>
        
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        Visitors: 
        <span id="busuanzi_value_site_uv"></span>
        
      </span>
    
    
  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      粤ICP备2022011229号
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/police_beian.png" alt="police-icon"/>
          
          <span>粤ICP备2022011229号</span>
        </a>
      </span>
    
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  

  

  

  

  

  

  







  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
